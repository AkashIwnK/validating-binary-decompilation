\section{Single Instruction Validation}\label{sec:siv}

The \siv is responsible for validating the lifting (using McSema) of an \ISA 
instruction \s{I} to \LLVM sequence \s{S}. This is achieved by (1) 
%Identifying the input/output variables for \s{I} and \s{S} and 
Establishing variable correspondence between \s{I} and \s{S}, (2) Generating 
symbolic summaries 
individually for \s{I} and \s{S} for each output variable, (3) Generating 
verification conditions meant to establish semantic equivalence between the 
corresponding pair of summaries, and solving those using an SMT solver (\Z). 
Next, we describe each one of these steps.

\paragraph{(1) Establishing variable correspondence:}   
%First, we need to identify the input/output variables of an \ISA instruction 
%and the corresponding lifted IR sequence. For each \ISA instruction, this 
%information is ready accessible using Stoke libraries to determine what are 
%the 
%implicit and explicit 
%register/memory/flags which are read or written by the instruction.
``Variable correspondence'' between \s{I} and \s{S} refers to identifying the 
correspondence between the input/output variables of \s{I}\footnote{By 
input/output variables of an instruction we mean implicit and explicit 
    register/memory/flags which are read or written.} and the 
    virtual registers in 
\s{S}. As described in Section~\ref{par:mcsema}, \mcsema uses a \Mcstate 
structure to
model the architecture state, which holds all the simulated architectural
registers at different offsets of the structure.\footnote{Another decompiler,
  fcd~\cite{FCD}, also has the similar approach of modeling.
    Rev.Ng~\cite{DiFederico:CC2017} models the architecture registers as LLVM
    globals.}  Hence, the input and output variables in the context of
    \mcsema are particular \emph{struct} fields, identified by constant offsets.
%
 As an example, for an instruction \instr{adcq \%rax, \%rbx}, the input variables are
 \reg{cf}, \reg{rax} \& \reg{rbx}, and output variables are \reg{rbx}, \reg{cf},
 \reg{pf}, \reg{sf}, \reg{zf}, \reg{of} and \reg{af}. 
The following shows how
 these input/output registers are mapped to the \mcsema \Mcstate structure.

\begin{lstlisting}[style=KRULE]
// State structure type (irrelevant fields shown as ...)
%struct.State (*$\mapsto$*) type { %struct.ArchState, ..., 
    %struct.ArithFlags,..., ..., ..., %struct.GPR, ...}

// Pointers to simulated registers are accessed as below
getelementptr inbounds %struct.State, %struct.State* 
    %state, i64 0, i32 (*\textbf{m}*), i32 (*\textbf{n}*), i32 0, i32 0

// Mapping of various simulated registers to getelementptr offsets
    rax (*$\mapsto$*) m = 6  n = 1;  rbx (*$\mapsto$*) m = 6  n = 3
     cf (*$\mapsto$*) m = 1  n = 1;   pf (*$\mapsto$*) m = 1  n = 3
     af (*$\mapsto$*) m = 1  n = 5;   zf (*$\mapsto$*) m = 1  n = 7
     sf (*$\mapsto$*) m = 1  n = 9;   of (*$\mapsto$*) m = 1  n = 13
\end{lstlisting}

We use the above architectural state representation of \mcsema to infer the
``variable correspondence'' between the \ISA instruction and its corresponding
lifted IR sequence\footnote{Similar inference
    for fcd~\cite{FCD}. For Rev.Ng~\cite{DiFederico:CC2017}, ``variable
    correspondence''  refers to  mapping between the \ISA registers and the
    LLVM globals}.

\cmt{  
For \mcsema, the ``variable correspondence''  means identifying the one-on-one
mapping between the \ISA registers and the \emph{struct} offsets.
%
\footnote{Same
  with fcd~\cite{FCD}. For Rev.Ng~\cite{DiFederico:CC2017}, ``variable
    correspondence''  refers to  mapping between the \ISA registers and the
    LLVM globals},}
%
% which is a trivial task once the input/output variable are already identified.
%
%\todo[inline,color=yellow]{I think we should use "variable correspondence" to 
%mean the mapping
%of operands of I to operands of S for each I in the input program. The mapping 
%above 
%is an architectural state representation, not a variable correspondence.  Your 
%%%tools 
%use the knowledge of the
%latter to extract the former automatically for each I.  Need to add a brief 
%paragraph here to describe that.}

%One may very rightfully think that it may not be easy or scalable to look into 
%the 
%implementation details of an arbitrary decompiler to collect such information. 
%To avoid that we developed an automated tool which will collect the such 
%variable correspondence information. The idea is to feed carefully selected 
%\ISA instructions to the  
 
\paragraph{(2) Generating symbolic summaries:}
The \K framework takes the formal semantics of \ISA and \LLVM and generates 
symbolic execution engines automatically, which we leverage to do 
symbolic execution of an \ISA instruction and the corresponding lifted \LLVM sequence 
individually. Before symbolic execution, we assign symbolic values to the input 
variables to obtain a summary over those. For the running example of 
\instr{adcq, \%rax, \%rbx}, the following shows the symbolic summary for just the 
output register \reg{rbx}\footnote{All the values or
    addresses, stored in registers, memory or
    flags, are represented as bit-vectors which are depicted in
    this paper as $V_W$ and interpreted as a bit-vector of size $W$
    and value $V$.}. 

\vspace{45pt}
%\todo[inline,color=yellow]{Usual notation is with a footnote: $V_W$. You could 
%use footnotes
%in formatted text and use W.V in the listings.  W.V makes the listing
%below very cluttered, though: wish there was a better choice.}

%\begin{minipage}{\linewidth}
%\vspace{10pt}
\begin{lstlisting}[style=KRULE]
// VX_CF, VX_RAX and VX_RBX are the symbolic values
// assigned to input variables.
extract ( 
    add ( 
        (#if eq ( VX_CF(*$_1$*) , (*$1_1$*) ) #then 
            add ( concat ( 0(*$_1$*) , VX_RAX(*$_{64}$*) ) , 1(*$_{65}$*) ) 
        #else 
            concat ( 0(*$_1$*) , VX_RAX(*$_{64}$*) ) 
        #fi)
        , concat ( 0(*$_1$*) , VX_RBX(*$_{64}$*)) 
        ) 
    , 1 , 65 ) 
\end{lstlisting}
%\end{minipage}

Similar symbolic summaries will be obtained for
 every simulated register in the lifter IR sequence,
which is omitted for brevity.

%%
\cmt{and 
(3) The fact that x86-64 ISA is largely stable and changes slowly
over time, we can keep a database of \emph{most} of the (\ISA
instruction,
validated IR sequence) pairs computed offline, but one-time, and
the phase two, on the other hand, can use the database for
composition.  Some
instructions variants like immediate, memory and control-flow cannot
be stored before-hand because it is impractical to compute the IR
sequence for all possible constant values. In these case, the IR
sequence can either be generalized from similar instances already
populated in the database or generated afresh and validated on the fly.}

The \ISA ISA includes instructions with Repeat String Operation 
Prefix (e.g. \instr{rep}, \instr{repz} etc.) to repeat a string instruction the 
number of times specified in the 
count register or until the indicated condition by the prefix is no longer met.
That is, their specification involves a loop which the symbolic 
execution must handle. We address this by symbolically executing those 
instruction with symbolic input state and comparing the summaries (using 
solver checks) of any single $i^{th}$ iteration of the two loops. This suffices 
to establish equivalence between the two loops, by coinductive 
reasoning~\cite{bisimulations} and the fact that such loops are bounded by a 
constant thus must terminate.

%\todo{"Capturing core behaviors" is not enough for soundness: can we make
%    a stronger argument?}

% Although we can only see a limited number of 
%iterations, this is sound as a single symbolic iteration is enough to 
%correctly capture the core behaviors of such instructions.

% how is this diff from Meandiff
% Meandiff converts the ind. iR to UIR and then to z3 quesries.
% wheeras we use the correctby construction K symbolic ex for the purpose.

\paragraph{(3) Generating \& Solving the verification conditions:}

First, we convert the summaries written in \K builtin operators to SMTLIB 
expressions. Given two symbolic summaries sum$_{\ISA}^{rbx}$ and 
sum$_{ir}^{rbx}$ for output \ISA register \reg{rbx} and corresponding 
simulated register, we emit a  query 
%\begin{center}
%\begin{tabular}{c}
\begin{lstlisting}[style=KRULEWOBORDER]
            (assert (not (= sum(*$_{\ISA}^{rbx}$*) (*sum$_{ir}^{rbx}$*))))
\end{lstlisting}
%\end{tabular}
%\end{center}

Similar  queries are generated for all registers, memory and 
flags (for examples, refer to~\cite{Suppl}). Note that we
generate queries for all registers/flags, not just the
ones clobbered, because the registers and flags not modified by
the instruction should have equivalent summaries (which is the unmodified value
    of the input symbolic value).

The verification condition queries are then dispatched to the \Z solver. If any 
two summaries 
fail to match, we have found a bug in McSema.

%\paragraph{\TV of instructions accessing data sections}

%\paragraph{Dispatching queries to solver}
Note that, even though we are using solver checks during the first phase, this
should not hamper the scalability of our program validation pipeline for 
the following
reasons.
First, the instruction-level validation is done for each instruction. 
Thus its verification condition is much simpler than that of whole program-level 
validation.
Second, the validation result of each instruction can be reused 
within a program  or across different programs, thus the validation cost can be 
amortized, or, done offline. 

%(1) Instruction lifting is checked one at a time and hence the solver
%queries are simple, (2) Most \ISA instructions do not have loops
%in their semantics (and the few that do are converted to a loop-free form),
%and therefore checking their equivalence is much easier than
%checking program-level equivalence using heavy-weight equivalence checkers.

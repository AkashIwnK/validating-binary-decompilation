\makeatletter
\makeatother

\begin{figure*}
\begin{tikzpicture}[%node distance=2.5cm,
every node/.style={fill=white}, align=center]
\tikzset{%
    %>={Latex[width=2mm,length=2mm]},
    % Specifications for style of nodes:
    base/.style = {rectangle, rounded corners,
         text centered},
    process/.style = {base,  fill=orange!15, font=\ttfamily, draw=black},
    basic box/.style = {
        shape = rectangle,
        align = center,
        draw  = #1,
        %fill  = #1!25,
        rounded corners},
      header node/.style = {
        %Minimum Width = header nodes,
        font          = \strut\Large\ttfamily,
        text depth    = +0pt,
        fill          = white,
        draw},
      header/.style = {%
        inner ysep = +1.5em,
        append after command = {
            \pgfextra{\let\TikZlastnode\tikzlastnode}
            node [header node] (header-\TikZlastnode) at (\TikZlastnode.north) {#1}
            %node [span = (\TikZlastnode)(header-\TikZlastnode)] at (fit bounding box) (h-\TikZlastnode) {}
        }
      },
}
\def\blockhdist{2cm}
\def\blockvdist{1.5cm}
\def\phasehdist{8cm}

%%%%%%%%%%%%%%% PHASE I
\node (instr)          [base]  {\ISA\\ Instruction, $I$};
\node (SIVmcsema)   [process, below of=instr, yshift=-0.5cm, 
xshift=\blockhdist]  {Lifter,$D$\\(under test)};
\node (irseq)          [base,below of=SIVmcsema, xshift=\blockvdist]  {IR 
Sequence, $S$};
\node (instrSymEx)   [process, below of=instr, yshift=-2*\blockvdist, xshift=-\blockhdist] {Symbolic Ex.\\(\ISA semantics) };
\node (irSymEx)   [process, below of=irseq, yshift=-0.5cm] {Symbolic Ex.\\IR semantics};
\node (proofGen)   [process, below of=instr, yshift=-4*\blockvdist] 
{Verification Condition Generator};
\node (solver)   [process, below of=proofGen, yshift=-\blockvdist] {Z3 Solver};
\node (decide1)     [draw, below of=solver, yshift=-1cm, diamond, aspect=2]  {$R == unsat$};
\node (report1)       [left of=decide1, xshift=-\phasehdist/4]  {Report};
\node (caption1)     [below of=solver, yshift=-2.5cm] {(a) Single Instruction
    Validation};

\draw[->]             (instr) -- (SIVmcsema);
\draw[->]             (SIVmcsema) -- (irseq);
\draw[->]     (instr) -- (instrSymEx);
\draw[->]     (irseq) -- (irSymEx);
\draw[->]     (instrSymEx) -- node {Symbolic\\Summary, $sum_{\ISA}$} (proofGen);
\draw[->]     (irSymEx) -- node {Summary\\$sum_{ir}$ } (proofGen);
\draw[->]     (proofGen) -- node {Verification Condition\\$z3.solve(sum_{\ISA} 
\ne 
sum_{ir})$} (solver);
\draw[->]     (solver.south) -- node {$R$} (decide1.north);
\draw[->]     (decide1.west) -- node {no} (report1);

%%%%%% Store
\node (store)     [process, right of=solver, 
xshift=\phasehdist/2]{Database\\({$I$,$S$}), \dots};
\draw[->]       (decide1.east) -| node[xshift=-2cm] {$yes$} (store.south);


%%%%%%%%%%%% PHASE II
\node (start)             [base,right of=instr, 
xshift=\phasehdist]                       {\ISA Program, $P$};
\node (compd)             [process, below of=start, yshift=-0.5cm, 
xshift=-\blockhdist]          {Compositional\\Lifter,$D^\prime$};
\node (mcsema)             [process, below of=start, yshift=-0.5cm, 
xshift=\blockhdist]          {Lifter,$D$\\(under test)};
\node (normalizer1)             [process, below of=compd, yshift=-\blockvdist]   {Normalizer};
\node (normalizer2)         [process, below of=mcsema, yshift=-\blockvdist]   {Normalizer};
\node (matcher)     [process, below of=normalizer2, yshift=-\blockvdist, 
xshift=-\blockhdist]   {Matcher};
\node (decide2)     at (decide1 -| matcher) [draw,  diamond, aspect=2]  {$M == equiv$};
\node (caption2)     at (caption1 -| matcher) {(b) Program-level Validation};
\node (report2)       [left of=decide2, xshift=-\phasehdist/4]  {Report};
\node (fine)       [right of=decide2, xshift=\phasehdist/4]  {\checkmark}; 
 
\draw[->]             (start) -- (compd);
\draw[->]             (start) -- (mcsema);
\draw[->]     (compd) -- node {Proposed IR, $T^\prime$} (normalizer1);
\draw[->]     (mcsema) -- node {Lifted IR, $T$} (normalizer2);
\draw[->]     (normalizer1) -- node {normalized\\IR, $N^\prime$} (matcher);
\draw[->]     (normalizer2) -- node {normalized\\IR, $N$} (matcher);
\draw[->]     (matcher) -- node {Matcher Results, $M$} (decide2);
\draw[->]     (store.north) |-  (compd.west);
\draw[->]     (decide2.west) -- node {no} (report2);
\draw[->]     (decide2.east) -- node {yes} (fine);

%% Reloc info
\node (reloc)             [base,right of=instr, 
xshift=\phasehdist/2]                       {Address Reloc. \\ info. 
$R$ of $P$};
\draw[->]       (reloc.south) |-  (compd.west);

%% Outter box
\begin{scope}[on background layer]
\node[fit = (compd)(mcsema)(start)(matcher), basic box = black,] (Phase1) {};
    \node[fit = (compd)(mcsema)(start)(matcher)(instr)(solver)(irseq)(instrSymEx)(irSymEx)(caption1)(caption2), basic box = black,] (Overview) {};
\end{scope}

\end{tikzpicture}
\caption{Overview diagram of the \tv framework}\label{fig:overview}
\end{figure*}

% \tikzset{
%     database/.style={
%         path picture={
%             \draw (0, 1.5*\database@segmentheight) circle [x radius=\database@radius,y radius=\database@aspectratio*\database@radius];
%             \draw (-\database@radius, 0.5*\database@segmentheight) arc [start angle=180,end angle=360,x radius=\database@radius, y radius=\database@aspectratio*\database@radius];
%             \draw (-\database@radius,-0.5*\database@segmentheight) arc [start angle=180,end angle=360,x radius=\database@radius, y radius=\database@aspectratio*\database@radius];
%             \draw (-\database@radius,1.5*\database@segmentheight) -- ++(0,-3*\database@segmentheight) arc [start angle=180,end angle=360,x radius=\database@radius, y radius=\database@aspectratio*\database@radius] -- ++(0,3*\database@segmentheight);
%         },
%         minimum width=2*\database@radius + \pgflinewidth,
%         minimum height=3*\database@segmentheight + 2*\database@aspectratio*\database@radius + \pgflinewidth,
%     },
%     database segment height/.store in=\database@segmentheight,
%     database radius/.store in=\database@radius,
%     database aspect ratio/.store in=\database@aspectratio,
%     database segment height=0.1cm,
%     database radius=0.25cm,
%     database aspect ratio=0.35,
% }


%As black box technique 
%such as ours requires no effort to 
%instrument the compiler or understand the specific transformations it 
%performs, 
%and further enables the comparison of programs produced by different people or 
%compilers (as illustrated in our case study of glibc strlen).



%Our first attempt to solve the problem of \tv of \ISA program was to use a
%language-independent equivalence checking
%algorithm, called \m{Keq} ~\cite{TheoSAS19}, that can be parameterized with the
%input  and output language semantics\footnote{We leveraged the available
%    semantics of
%    \LLVM~\cite{LLVMSEMA} and \ISA~\cite{DasguptaAdve:PLDI19} for this
%    purpose}.
%The algorithm employs the notion of cut-bisimulation where the pair of
%program points and the invariants, needed to be satisfied at each cut point,
%needed to be provided as an input to the algorithm.




%\subsection{Challenges with naive \tv of \ISA program lifting}
%\label{sec:challenges-program-lifting}
%
%Our first attempt to solve the problem of \tv of \ISA program was to use a
%language-independent equivalence checking
%algorithm, called \m{Keq} ~\cite{TheoSAS19}, that can be parameterized with the
%input  and output language semantics\footnote{We leveraged the available
%    semantics of
%    \LLVM~\cite{LLVMSEMA} and \ISA~\cite{DasguptaAdve:PLDI19} for this
%    purpose}.
%The algorithm employs the notion of cut-bisimulation where the pair of
%program points and the invariants, needed to be satisfied at each cut point,
%needed to be provided as an input to the algorithm.
%
%%
%
%Such synchronizations points can be generated by the lifter upon
%instrumentation. This is roughly the same attempt made by
%~\cite{Galois:SPISA19} with the limitation that it will make the approach
%severely tied to the lifter. Hence, we decided to find the \syncp in a
%lifter-agnostic way without doing any instrumentation.
%However, in principle, it is not straight-forward to extract the
%synchronization points using just the \ISA program and lifted \LLVM mainly
%because the two  program are structurally very different with potentially
%different number of basic blocks.
%
%For example, instructions like \instr{adcq \%rax, \%rbx} upon lifting to \LLVM
%generates  additional basic blocks, because of the different actions to  take
%based on the carry flag, which is not explicitly visible in the X86 program;
%Hence finding \syncp in a decompiler agnostic way is not trivial.

\subsection{Compositional Lifter}\label{sec:compd}
The \compd is responsible for generating the proposed \LLVM \s{T$^\prime$} by
composing the validated McSema-lifted IR sequences of the constituent binary
instructions of the \ISA program \s{P}. Importantly, the \compd design 
(Algorithm~\ref{alg:compd}) is simple---and took us about 
three man-weeks to implement. 

\s{P} is disassembled (line 2) to
identify function boundaries, and to decode 
instructions.
%Identifying functions is
%important because the Matcher (Section~\ref{sec:matcher}) will work at
%function-level granularity\todo{SD:makes sense?  CF: unclear whether this was 
%%%fundamental or just a design choice}. 
\cmt{Moreover, the framework 
is
plug-and-play in
using disassemblers other than ObjDump (line 2), like Intel's  XED~\cite{xed}.}
If the disassembled instruction $I_{disass}$ is already in Store, then its
corresponding (validated) IR sequence is reused.
Otherwise $I_{disass}$
is assembled (line 6) and lifted (using \mcsema) to
generate an \LLVM sequence that will be validated using Phase 1. The validated IR 
sequences are then composed (line 17) following program order.

\begin{algorithm}
    \SetKwInOut{Input}{Inputs}
    \SetKwInOut{Output}{Output}
    %\TitleOfAlgo{How to write algorithms}
    %\underline{function Euclid} $(a,b)$\;
    \Input{ \\
     \textbf{P:} \ISA binary program. \\
     \textbf{Store:} Validated pairs (<\s{I}, \s{S}> ) of instruction \s{I}
        and
        lifted IR sequence
        \s{S}. (possibly empty) \\
     \textbf{R:} Address Relocation information of binary P.
    }
    \Output{Lifted IR Program \s{T$^\prime$}}
    \BlankLine
    $T^\prime \gets \phi$ \\
    $P_{disass} \gets$ ObjDump($P$) \\
    \ForEach{\textup{function} $F_{disass}$ \textup{in} $P_{disass}$}{%
    \ForEach{\textup{instruction} $I_{disass}$ \textup{in} $F_{disass}$}{%
        \uIf{$I_{disass}$ \textup{not in} Store}{%
            $I \gets$ Assembler($I_{disass}$) \\
            $S \gets$ McSema($I$) \\
            Perform \TV of $I$ and $S$ (Phase 1) \\
            \uIf{\textup{Validation successful}}{%
            Add $<I_{disass},S>$ to $Store$
            }
            \Else {
            Report Bug
            }

        }
        \Else {
            \textup{Extract} $S$ \textup{from} $Store$ \textup{for}
            $I_{disass}$ \\
        }
        $T^\prime \gets$ \textup{Compose($T^\prime, S, R$)}
    }
    }
    \KwRet{$T^\prime$}
    %\NoCaptionOfAlgo
    \caption{\textbf{Compositional Lifting}}\label{alg:compd}
\end{algorithm}

\paragraph{Single instruction validation of control-flow instructions (line
8)}\label{sec:sivcntrl}

The \siv strategy described in Section~\ref{sec:siv} cannot be applied naively  
to control flow instructions. This is because the instruction fed to \mcsema 
(line 7), for \siv, is obtained from the disassembled instruction \s{I$_{disass}$},
wherein the relative offsets of binary jump/call instructions are specified as labels. 
Hence, the binary instruction \s{I} which we obtain from assembling \s{I$_{disass}$} 
(line 6), without program context, has an incorrect relative offset, which gets 
propagated to the lifted IR \s{S}.

We get around this problem by symbolically executing \s{I} with 
symbolic values 
assigned to the current PC and label.
That way, we get symbolic
summaries agnostic of the actual (incorrect) value of the relative offset.
Similarly, we symbolically execute  lifted IR sequence by assigning symbolic
values to the virtual register holding the simulated relative offset.

%Translation validation of control-flow instructions like \instr{jmp label} and
%\instr{call label} w/o the program context is a bit tricky because the behavior
%of these instruction are not context-free. For example, the behavior of
%\instr{jz rel\_off}, which updates the PC value to either PC +
%sizeInBytesOf(\instr{jz rel\_off}) or PC + sizeInBytesOf(\instr{jz rel\_off}) +
%rel\_off, is based on the value of current PC value \cmt{and the rel\_off}
%which depends on the position of the instruction in the \emph{.text} section of
%binary.

\paragraph{The ``Compose'' step}
Below we describe the step ``Compose'' (line 17), responsible for
composing the IR sequences together, using a few example binary
instructions.
%\todo{say, at a high level, what is going on with compose?  E.g., ``At a 
%high-level, Compose concatenates the instructions that were validated in Phase 
%1, based on the program P.''}

The composed program is initially empty. Upon encountering a function label, we
append the following code to it\footnote{\emph{mem} is pointer to an opaque 
struct type which together with return type allows ordering of memory
    operations if required.}.

\begin{lstlisting}[style=LLVM]
define %struct.Mem* @composedFunc(%struct.State*, i64, 
        %struct.Mem* mem)  {}
\end{lstlisting}

For an instruction \instr{adcq \%rax, \%rbx}, \mcsema generates the following
IR sequence.

\begin{lstlisting}[style=LLVM]
define internal %struct.Mem* @ADCImpl(
    %struct.Mem*, %struct.State*, i64*, i64, i64) {
    ; Does adc computation and updates destination RBX
    ; and flags (omitted for brevity)
}

define %struct.Mem* @sub_adcq_rax_rbx(%struct.State*, 
        i64, %struct.Mem* ) {
 %RIP = getelementptr ... ; Compute simulated RIP address
 %RAX = getelementptr ... ; Compute simulated RAX address
 %RBX = getelementptr ... ; Compute simulated RBX address
 %VAL_RBX = load i64, i64* %RBX
 %VAL_RAX = load i64, i64* %RAX
 ; RIP update based on instruction size
 %VAL_RIP = load i64, i64* %RIP
 %UPDATED_RIP = add i64 %VAL_RIP, 3
 store i64 %UPDATED_RIP, i64* %RIP
 %retval = call %struct.Mem* @ADCImpl(
        %struct.Mem* %2, %struct.State* %0, i64* %RBX,
        i64 %VAL_RBX, i64 %VAL_RAX)
 ret %struct.Mem* %retval
}
\end{lstlisting}

The above IR sequence is then appended to the composed program as below.

\begin{lstlisting}[style=LLVM]
define %struct.Mem* @composedFunc(%struct.State*, 
        i64, %struct.Mem* mem)  {
    ; Code: adcq %rax, %rbx	
    %loadMem = load %struct.Mem*, %struct.Mem** %mem
    %retval = call %struct.Mem* @routine_adcq_rax_rbx(
        %struct.State* %0, %struct.Mem* %loadMem)
    store %struct.Mem* %call, %struct.Mem** %mem

    ret %struct.Mem* retval
}
; Definitions of called functions omitted for brevity
\end{lstlisting}

A similar composition happens for most instructions, the exceptions being the control-flow
data section-accessing instructions, which we elaborate on next.

\paragraph{Composing control-flow instructions} As mentioned previously, the
``labeled'' control-flow assembly instructions, when assembled without program
context, generate incorrect offsets which get propagated to the lifted IR.
We fix this IR by replacing said incorrect relative offsets with the correct
offsets.

For instance, when \mcsema lifts \instr{jne .L\_40087e} in isolation,
it generates the following IR sequence:
%\vspace{10pt}
\begin{lstlisting}[style=LLVM]
define %struct.Mem* @sub_jne_.L_40087e(%struct.State*, 
        i64, %struct.Mem* ) {
  %RIP = getelementptr ... ; Compute simulated RIP address
  %RIP_VAL = load i64, i64* %RIP
  ; Compute true target (using incorrect offset)
  %TARGET1 = add i64 %RIP_VAL, <incorrect_val>
  ; Compute fall-through target
  %TARGET2 = add i64 %RIP_VAL, <instr. size>
  %retval = call %struct.Mem* @JNEImpl(..., i64 %TARGET1, i64 %TARGET2)
  ret %struct.Mem* %retval
}
\end{lstlisting}

And the composed program with transformed IR looks like
\begin{lstlisting}[style=LLVM]
define %struct.Mem* @sub_jne_.L_40087e(%struct.State*, 
        i64, %struct.Mem*,
        i64 %(*\textbf{true\_tgt}*), i64 %(*\textbf{false\_tgt}*)) {
  %RIP = getelementptr ... ; Compute RIP address
  %RIP_VAL = load i64, i64* %RIP
  ; Transformed code
  %TARGET1 = add i64 %RIP_VAL,  %(*\textbf{true\_tgt}*)
  %TARGET2 = add i64 %RIP_VAL,  %(*\textbf{false\_tgt}*)
  ; Rest same as above
}

define %struct.Mem* @composedFunc( %struct.State*, 
        i64, %struct.Mem* mem)  {
  ; ... previously composed code ...
  ; Code: jne .L_40087e	 RIP: 400855	 Bytes: 6
  %loadMem = load %struct.Mem*, %struct.Mem** %mem
  %retval = call %struct.Mem* @routine_jne_.L_40087e(
        %struct.State* %0, %struct.Mem* %loadMem, 
        i64 (*\textbf{41}*), i64 (*\textbf{6}*))
  store %struct.Mem* %retval, %struct.Mem** %mem
  ret %struct.Mem* %retval
}
\end{lstlisting}

\paragraph{Composing data-section access instructions}
Instructions accessing the data section, like \instr{movq 0x602040, \%rdi}
with the first operand being an address, cannot be lifted correctly in
isolation (without program context) because \mcsema does not have sufficient information to to distinguish constant from address. 
\Siv can only validate the fact whether the constant
(which could potentially be an address) is correctly moved to the destination register. 
However, the problem is the \plv cannot use that lifting because the resulting 
composed IR \s{T$^\prime$}, with a constant moved to \reg{rdi}, will be   
different from the
one lifted by \mcsema \s{T}, with a global address moved to \reg{rdi}.
Upon normalization, two such IRs will be optimized differently by LLVM, leading to two syntactically 
divergent normalized forms, even when the initial programs were equal.

%Note that this will not pose any
%problem while \siv, as we can validate just the fact whether the constant
%(which could potentially be an address) is moved to the destination register.
%However, the \plv cannot use that lifting because the resulting composed IR
%\s{T$^\prime$}, with a constant moved to \reg{rdi}, will be different from the
%one lifted by \mcsema \s{T}, with a \dlifted global address moved to \reg{rdi}.
%Two such IRs upon normalization (Section~\ref{sec:normalizer}) using LLVM
%optimizer
%allows different optimization opportunities leading two syntactically divergent
%normalized forms.

To aid in testing, we compile binaries with options to retain auxiliary
information. To disambiguate between cases where a constant is a reference
into the data section (e.g., an \texttt{int*}) v/s a scalar (e.g., an
\texttt{int}), we use relocation information, denoted by \s{R} in
algorithm~\ref{alg:compd}.  We allow \mcsema to (incorrectly) lift such
instructions in isolation and then we course-correct the lifted IR by
consulting the binary's relocation information to determine if an immediate
operand should be considered as an address or constant --- every immediate
operand that is a reference has a corresponding entry in the relocation table.
Missing this entry would automatically mean that the immediate is a constant.

For example, the incorrect IR generated by \mcsema when lifting \instr{movq
0x602040, \%rdi} in isolation is:
\begin{lstlisting}[style=LLVM]
define %struct.Mem* @sub_movq_0x602040___rdi(
        %struct.State*, i64, %struct.Mem* ) {
    ...
    %retval = call %struct.Mem* @MOVImpl(
        %struct.Mem* %2, %struct.State* %0,
        ; data-section addr 0x602040
        ; lifted as a constant
        %i64* %RDI, i64 6299712)

    ret %struct.Mem* %retval
}
\end{lstlisting}

The address relocation information in the binary allows us to identify the address
and the following correct lifting:
\begin{lstlisting}[style=LLVM]
%G_0x602040_type = type <{ [8 x i8] }>
@G_0x602040= global %G_0x602040_type zeroinitializer
define %struct.Mem* @sub_movq_0x602040___rdi(
        %struct.State*, i64, %struct.Mem* ) {
    ...
    %retval = call %struct.Mem* @MOVImpl(
     %struct.Mem* %2, %struct.State* %0,
     %i64* %RDI,
     i64 ptrtoint( %G_0x602040_type* @G_0x602040 to i64))

    ret %struct.Mem* %retval
}
\end{lstlisting}

We reiterate that \compd only uses relocation information to strengthen the
generated golden reference, \s{T$^\prime$}, when such information is
available, e.g., during test or development time. This allows for a tighter
specification, allowing our technique to find bugs at testing that would 
otherwise
be missed. During use of \compd in the field to validate the lifting of
\mcsema on an unknown, blackbox binary, we do not require this additional
information, at the cost of potentially missing bugs described above. Note
that this is a fundamental limitation because \ISA semantics for an
instruction has no notion of types, and therefore \s{T$^\prime$}, which is
based on \ISA semantics, should allow for the ambiguity and cannot enforce
stricter type requirements. McSema on the other hand is never given this
additional information as it is expected to work in the field where relocation
information is rarely available, except in library code.

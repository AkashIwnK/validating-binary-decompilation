\chapter{Scalable Validation of Binary Lifters}\label{chap:scalable-val}

Validating the correctness of binary lifters is pivotal to gain trust in
binary analysis, especially when used in scenarios where correctness is
important, e.g., in security analysis, binary patching, or recompilation
to other ISAs. Existing approaches focus on validating the correctness of
lifting a single instruction and do not scale to full programs. In this
work we show that formal translation validation of single instructions for
x86-64 is practical and develop a novel technique that uses validated
instructions to scale to program level validation, thereby eliminating the
bottleneck of heavy-weight equivalence checkers at the program level. Our
work is the first to to do \tv of single instructions on an architecture as 
extensive as \ISA,
uses the most precise formal semantics available, and has the widest
coverage in terms of number of instructions tested for correctness. 
%
To scale to whole programs, our \emph{compositional lifter} composes the validated IR
sequences to create a reference standard. The semantic equivalence check between the
reference and the lifter output is then reduced to a syntactic equivalence check through
use of a normalizer --- a procedure that reduces IR sequences to a
canonical representation.
%    
Using our approach, we find \sivFail new bugs in McSema, a mature open-source
lifter from x86-64 to LLVM IR. For whole programs, our approach was able to
prove equivalence of lifted code for \plvP/\plvT functions taken
from single-source benchmark test-suite.

\input{scalable-validation/introduction.tex}
\input{scalable-validation/approach.tex}
\input{scalable-validation/preliminaries.tex}
\input{scalable-validation/siv.tex}
\input{scalable-validation/plv.tex}
\input{scalable-validation/evaluation.tex}
\input{scalable-validation/discussion.tex}
\input{scalable-validation/relatedwork.tex}
\input{scalable-validation/conclusion.tex}

\subsection{Normalizer}\label{sec:normalizer}

Algorithm~\ref{alg:NM} summaries the normalization and subsequent matching 
phase.
Due to the nature of the composition, the composed program  is 
very similar to the lifted program. We leverage this observation to establish 
semantic equivalence between the two 
programs using an iterative matching and pruning strategy, realized by a tool 
we develop called the \matcher. Failure of the  
\matcher should be interpreted as a \emph{potential} bug in the lifted program. 
%comparing (using \emph{Matcher}) 
%the \emph{canonical 
%representations} of the input programs
%generated using LLVM  \emph{O3} passes \& iterative pruning. 
%uisng an iterative strategy of matching the LLVM 03 assisted canonicalized 
%program and sbsequent pruning.
\newcommand\mycommfont[1]{\footnotesize\textcolor{blue}{#1}}
\SetCommentSty{mycommfont}
\begin{algorithm}
    \SetKwInOut{Input}{Inputs}
    \SetKwInOut{Output}{Output}
    \Input{
        \textbf{T:} \dlifted IR. \\
        \textbf{T$^\prime$:} \compd lifted IR.
    }
   \Output{\textbf{True} $\implies$   \textbf{T} \& \textbf{T$^\prime$} 
   semantically equivalent \\
   \textbf{False} $\implies$   \textbf{T} \& \textbf{T$^\prime$} \emph{may-be}
   non-equivalent
}


    \BlankLine
    
    \ForEach{\textup{corresponding function pair (\F,\FP) in 
        (\T, \TP)}}{%
        
        \If{\textup{!Matcher(\F, \FP)}}{%
            \tcp{\textup{A potential bug in McSema while lifting \s{F}}}
            \KwRet{false}  \\ 
        }
        
    }
    \KwRet{true}
    %\NoCaptionOfAlgo
    \caption{\textbf{Normalization \& Matching}}\label{alg:NM}
\end{algorithm}
%\Output{ 
%    \textf{True} $\implies$  \textbf{T} \& \textbf{T$^\prime$} semantically 
%    equivalent \\
%    False: \textbf{T} \& \textbf{T$^\prime$}  equivalent
%}



%two programs we are comparing (\s{T} \& \s{T$^\prime$}) start out being very
%similar:   
%% Why we need a normalizer
%There is no control-flow changes 
%
%\mcsema generally does not change control flow, and does not add or remove
%almost \emph{any} operations. However, it hoists the address computations of
%all the simulated registers (using \emph{getelelementptr}) in the \emph{entry}
%basic block so that the simulated instruction semantics does not have to
%compute them again. Whereas, the \compd recomputes those address at every
%instruction site.  
%%
%Our approach is to leverage this observation and to syntactically compare
%\emph{canonical representations} of the input programs.  We generate such
%representations using a tool we develop called a \emph{normalizer}.  Our
%normalizer is current implemented using LLVM  \emph{O3} passes to be applied to
%both \s{T} \& \s{T$^\prime$}.




%During the canonicalization step performed by the compiler, the strand (in our
%case a procedure with a single basic block) is repre- sented by a directed
%acyclic graph (DAG) which stores the expression. Even though comparing DAGs is
%possible, we wanted to simplify our representation to some kind of tex- tual
%form, allowing for fast and simple comparison. This is accomplished by using
%opt to output a linearized version of the computationâ€™s DAG. To finalize the
%transformation which eliminates the origin and compilation choices made in the
%creation of the binary code, the final refinement to our representation is
%normalizing the strands. This is done by re- naming all symbols in the strand,
%i.e., its registers and tem- porary values, into sequentially named symbols.
%This step is crucial for cross-architecture comparison, as the names of the
%specific registers used in a given computation have nothing to do with its
%actual semantics, and are completely different between architectures.

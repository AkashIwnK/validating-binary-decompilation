\section{Preliminaries}
\label{sec:prelim}

In this section, we provide background on various pieces of our work:
(i) The binary lifter under test, McSema, (ii) The formal \ISA semantics, and
(iii) The formal \LLVM semantics.

\paragraph{McSema}\label{par:mcsema} \mcsema~\cite{McSema:Recon14} is the most
mature, well tested, open-source lifter to raise binaries from \ISA
instructions to LLVM bitcode.  At a high-level, \mcsema is split into two
parts: (a) frontend, and (b) backend. The frontend is responsible for parsing,
loading, and disassembling a binary and exports an interface to the backend to
query for the required information, e.g., the defined symbols, sizes of
various binary sections, instruction listings etc. The backend then uses this
information and Remill~\cite{Remill} library to lift the individual
instructions. McSema supports multiple different frontends with IDA Pro being
the most robust, and supported option.

Conceptually, the backend implementation of \mcsema is fairly straightforward:
\mcsema exposes all of architecture state, i.e., the program registers,
conditional flags, and program memory, through an LLVM \emph{struct}, aptly
named \Mcstate. 
Member fields
of the structure correspond to every register (register name, not a physical
register) and flags that can be used during the execution of the program. Instructions
operating on the stack must retrieve the current top of stack from the
appropriate member field (corresponding to \reg{rsp}) in the structure.
\mcsema simply scans through the disassembly of the binary
and lifts each instruction one by one, emitting code to read and update the
members of \emph{state} as defined by the instruction semantics. In essence,
the code lifted by \mcsema simply \emph{simulates} the binary in \LLVM.

%The main idea behind \mcsema lies in the simulation of the original binary,
%which in turns requires architectural state and memory of the target
%processor. There is no explicit stack by default.  To simulate state of the
%processor, an LLVM structure type called \emph{state} is used. Member fields
%of the structure correspond to every register (register name, not a physical
%register) that can be used during the execution of the program. Instructions
%operating on the stack must retrieve the current top of stack from the
%appropriate member field (corresponding to \reg{rsp}) in the structure.
%%\todo[inline]{Unclear: Since structure only holds registers, say which
%%register is used to retrieve "current top of stack."}
%\mcsema  performs decompilation of the binary code by translating the machine
%instructions to operations on this \emph{state} structure, according to the
%machine specification. This lifting process works by translating each assembly
%instruction in the procedure into an IR sequence,  which explicitly specifies
%how it affects the machine's memory and registers, including the flags.
%\paragraph{\ISA \& LLVM formal semantics}
%The present work needs the formal
%semantics of \ISA and LLVM, which we borrowed from~\cite{DasguptaAdve:PLDI19}
%and~\cite{LLVMSEMA} respectively. Both semantics are developed using
%\K~\cite{k-primer-2013-v32}\cmt{\url{http://kframework.org}}, which is a
%framework for defining formal language semantics.

\paragraph{K-Framework}\label{par:k} The presented work needs the formal
semantics of \ISA and LLVM, which we borrowed from~\cite{DasguptaAdve:PLDI19}
and~\cite{LLVMSEMA} respectively (and described next). Both semantics are developed using
\K~\cite{k-primer-2013-v32}\cmt{\url{http://kframework.org}}, which is a
framework for defining formal language semantics. Given a syntax and a
semantics of a language, \K automatically generates a parser, an interpreter, 
a symbolic execution engine, as well as
formal analysis tools such as model checkers and deductive program verifiers,
at no additional effort. Using the interpreter, one can test their
semantics immediately, which significantly increases the efficiency of
semantics developments. Furthermore, the formal analysis tools
facilitate formal reasoning about the given language semantics.  This
helps both the applicability of the semantics and in the
engineering the semantics itself.

\paragraph{\ISA Formal Semantics} Our work uses the state-of-the-art \ISA
semantics developed by Dasgupta et al.~\cite{DasguptaAdve:PLDI19}, which
presents the most complete and thoroughly tested formal semantics of x86-64 to
date, and faithfully formalizes all non-deprecated, sequential
user-level instructions of x86-64 Haswell instruction set architecture.
This totals to 3155 instruction variants, corresponding to 774 mnemonics.
Their semantics are fully executable, and includes a symbolic execution engine
automatically generated by \K framework
%
    \footnote{Given a syntax and a semantics of a language, \K automatically
    generates a parser, an interpreter, a symbolic execution engine, as well
    as formal analysis tools such as model checkers and deductive program
    verifiers, at no additional effort.}.
%

\paragraph{\LLVM Formal Semantics} We use the LLVM formal semantics as defined
in \K~\cite{LLVMSEMA}, which models LLVM types (integers, composite arrays and
structs, corresponding pointers), the \texttt{getelementptr} instruction (used
to compute the address of an element nested within a composite),  integer
arithmetic \& comparison operators, memory operations (\texttt{load},
\texttt{store}, and \texttt{alloca}), control flow instructions for
unconditional and conditional branches, as well as function calls and returns.
However, the semantics does not support: floating point, vector types, and
most LLVM intrinsic functions and therefore we cannot validate the \tv for
such instructions.  This is a limitation of the available LLVM semantics, and
not a limitation of our work.

.
%\todo[inline]{The last 2 sentences are nice, but could be dropped if space is tight.}
%\todo[color=yellow]{These two semantics are two of the most
%    important building blocks. Can we make them top-level paragraphs?}
%\paragraph{\ISA Semantics} \todo{These two semantics are two of the most
%important building blocks. Can we make them top-level paragraphs?}
%The formal model~\cite{DasguptaAdve:PLDI19}
%presents the most complete and thoroughly tested formal semantics of x86-64 to
%date, which faithfully formalizes all the  non-deprecated, sequential
%user-level instructions of the x86-64 Haswell instruction set architecture.
%This totals 3155 instruction variants, corresponding to 774 mnemonics.  The
%semantics is fully executable, and comes with an
%automatically generated symbolic execution engine (thanks to the \K framework),
%which we leverage in this work.
%
%\paragraph{LLVM Semantics} The formal semantics of \LLVM is provided by
%~\cite{LLVMSEMA}, which models  various LLVM types (like integer types,
%    composite array and struct types, the  corresponding pointer types, and the
%    \texttt{getelementptr} instruction used to compute the address of an element nested
%    within a composite type),  integer arithmetic \& comparison operators,
%  memory operations (like \texttt{load}, \texttt{store}, and \texttt{alloca}), 
%  control flow instructions
%  for unconditional and conditional branches, as well as function calls and
%  returns. The current version of the semantics does not support floating point
%  or vector types and most LLVM intrinsic functions, which constrains our experiments
%  but does not affect the overall approach proposed and evaluation in this work.
%  \todo{Check last sentence.}

%\paragraph{Stoke Libraries}\label{par:stoke} Stoke~\cite{Stoke2013} is a
%stochastic superoptimizer and program synthesizer for the x86-64 instruction
%set.  The project comes with many useful libraries to (1) query interesting
%properties of \ISA instructions (like type, size, inputs \& outputs etc.),
%(2) disassemble \ISA programs, and (3) analyze  \ISA programs to infer
%properties related to control- \& data-flow. We make use of these in our
%work.
%
%The rest of this paper is organized as follows: we discuss our \siv
%in~\ref{sec:siv}, and then move on to show how we use the validated sequences of
%IR instructions to construct a \emph{\compd} and use it to for \plv
%in~\ref{sec:plv}. Finally, we show the effectiveness of our developed techniques
%through our evaluation in~\ref{sec:eval}.

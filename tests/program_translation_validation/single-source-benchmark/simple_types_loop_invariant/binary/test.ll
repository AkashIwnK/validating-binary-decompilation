; ModuleID = '/home/ubuntu/Github/validating-binary-decompilation/tests/program_translation_validation/single-source-benchmark/bc-seeds/simple_types_loop_invariant/simple_types_loop_invariant.bc'
source_filename = "llvm-link"
target datalayout = "e-m:e-i64:64-f80:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%struct.one_result = type { double, i8* }
%struct._IO_FILE = type { i32, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, i8*, %struct._IO_marker*, %struct._IO_FILE*, i32, i32, i64, i16, i8, [1 x i8], i8*, i64, i8*, i8*, i8*, i8*, i64, i32, [20 x i8] }
%struct._IO_marker = type { %struct._IO_marker*, %struct._IO_FILE*, i32 }

$_Z4fillIPaaEvT_S1_T0_ = comdat any

$_Z14test_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia28custom_add_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia19custom_sub_variableIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia28custom_sub_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia24custom_multiply_variableIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia33custom_multiply_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ia34custom_multiply_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia22custom_divide_variableIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia31custom_divide_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ia32custom_divide_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ia30custom_mixed_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia19custom_variable_andIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia28custom_multiple_variable_andIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia18custom_variable_orIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia27custom_multiple_variable_orIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ia19custom_variable_xorIaEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ia28custom_multiple_variable_xorIaEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z4fillIPhhEvT_S1_T0_ = comdat any

$_Z14test_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih28custom_add_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih19custom_sub_variableIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih28custom_sub_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih24custom_multiply_variableIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih33custom_multiply_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ih34custom_multiply_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih22custom_divide_variableIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih31custom_divide_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ih32custom_divide_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ih30custom_mixed_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih19custom_variable_andIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih28custom_multiple_variable_andIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih18custom_variable_orIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih27custom_multiple_variable_orIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ih19custom_variable_xorIhEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ih28custom_multiple_variable_xorIhEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z4fillIPssEvT_S1_T0_ = comdat any

$_Z14test_variable1Is19custom_add_variableIsEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Is19custom_add_variableIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is28custom_add_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is19custom_sub_variableIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is28custom_sub_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is24custom_multiply_variableIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is33custom_multiply_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Is34custom_multiply_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is22custom_divide_variableIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is31custom_divide_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Is32custom_divide_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Is30custom_mixed_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is19custom_variable_andIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is28custom_multiple_variable_andIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is18custom_variable_orIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is27custom_multiple_variable_orIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Is19custom_variable_xorIsEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Is28custom_multiple_variable_xorIsEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z4fillIPttEvT_S1_T0_ = comdat any

$_Z14test_variable1It19custom_add_variableItEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1It19custom_add_variableItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It28custom_add_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It19custom_sub_variableItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It28custom_sub_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It24custom_multiply_variableItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It33custom_multiply_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4It34custom_multiply_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It22custom_divide_variableItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It31custom_divide_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4It32custom_divide_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4It30custom_mixed_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It19custom_variable_andItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It28custom_multiple_variable_andItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It18custom_variable_orItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It27custom_multiple_variable_orItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1It19custom_variable_xorItEEvPT_iS2_PKc = comdat any

$_Z14test_variable4It28custom_multiple_variable_xorItEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z4fillIPiiEvT_S1_T0_ = comdat any

$_Z14test_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii28custom_add_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii19custom_sub_variableIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii28custom_sub_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii24custom_multiply_variableIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii33custom_multiply_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ii34custom_multiply_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii22custom_divide_variableIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii31custom_divide_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ii32custom_divide_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ii30custom_mixed_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii19custom_variable_andIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii28custom_multiple_variable_andIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii18custom_variable_orIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii27custom_multiple_variable_orIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ii19custom_variable_xorIiEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ii28custom_multiple_variable_xorIiEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z4fillIPjjEvT_S1_T0_ = comdat any

$_Z14test_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij28custom_add_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij19custom_sub_variableIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij28custom_sub_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij24custom_multiply_variableIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij33custom_multiply_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ij34custom_multiply_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij22custom_divide_variableIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij31custom_divide_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ij32custom_divide_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Ij30custom_mixed_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij19custom_variable_andIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij28custom_multiple_variable_andIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij18custom_variable_orIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij27custom_multiple_variable_orIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Ij19custom_variable_xorIjEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Ij28custom_multiple_variable_xorIjEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z4fillIPllEvT_S1_T0_ = comdat any

$_Z14test_variable1Il19custom_add_variableIlEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Il19custom_add_variableIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il28custom_add_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il19custom_sub_variableIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il28custom_sub_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il24custom_multiply_variableIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il33custom_multiply_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Il34custom_multiply_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il22custom_divide_variableIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il31custom_divide_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Il32custom_divide_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Il30custom_mixed_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il19custom_variable_andIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il28custom_multiple_variable_andIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il18custom_variable_orIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il27custom_multiple_variable_orIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Il19custom_variable_xorIlEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Il28custom_multiple_variable_xorIlEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z4fillIPmmEvT_S1_T0_ = comdat any

$_Z14test_variable1Im19custom_add_variableImEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Im19custom_add_variableImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im28custom_add_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im19custom_sub_variableImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im28custom_sub_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im24custom_multiply_variableImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im33custom_multiply_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Im34custom_multiply_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im22custom_divide_variableImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im31custom_divide_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Im32custom_divide_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Im30custom_mixed_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im19custom_variable_andImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im28custom_multiple_variable_andImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im18custom_variable_orImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im27custom_multiple_variable_orImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Im19custom_variable_xorImEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Im28custom_multiple_variable_xorImEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z4fillIPffEvT_S1_T0_ = comdat any

$_Z14test_variable1If19custom_add_variableIfEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1If19custom_add_variableIfEEvPT_iS2_PKc = comdat any

$_Z14test_variable4If28custom_add_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1If19custom_sub_variableIfEEvPT_iS2_PKc = comdat any

$_Z14test_variable4If28custom_sub_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1If24custom_multiply_variableIfEEvPT_iS2_PKc = comdat any

$_Z14test_variable4If33custom_multiply_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4If34custom_multiply_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1If22custom_divide_variableIfEEvPT_iS2_PKc = comdat any

$_Z14test_variable4If31custom_divide_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4If32custom_divide_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4If30custom_mixed_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z4fillIPddEvT_S1_T0_ = comdat any

$_Z14test_variable1Id19custom_add_variableIdEEvPT_iS2_PKc = comdat any

$_Z22test_hoisted_variable1Id19custom_add_variableIdEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Id28custom_add_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Id19custom_sub_variableIdEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Id28custom_sub_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Id24custom_multiply_variableIdEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Id33custom_multiply_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Id34custom_multiply_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable1Id22custom_divide_variableIdEEvPT_iS2_PKc = comdat any

$_Z14test_variable4Id31custom_divide_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Id32custom_divide_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_Z14test_variable4Id30custom_mixed_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc = comdat any

$_ZN30custom_mixed_multiple_variableIdE8do_shiftEddddd = comdat any

$_Z26check_shifted_variable_sumId30custom_mixed_multiple_variableIdEEvT_S2_S2_S2_S2_ = comdat any

$_Z15tolerance_equalIdEbRT_S1_ = comdat any

$_ZN32custom_divide_multiple_variable2IdE8do_shiftEddddd = comdat any

$_Z26check_shifted_variable_sumId32custom_divide_multiple_variable2IdEEvT_S2_S2_S2_S2_ = comdat any

$_ZN31custom_divide_multiple_variableIdE8do_shiftEddddd = comdat any

$_Z26check_shifted_variable_sumId31custom_divide_multiple_variableIdEEvT_S2_S2_S2_S2_ = comdat any

$_ZN22custom_divide_variableIdE8do_shiftEdd = comdat any

$_Z26check_shifted_variable_sumId22custom_divide_variableIdEEvT_S2_ = comdat any

$_ZN34custom_multiply_multiple_variable2IdE8do_shiftEddddd = comdat any

$_Z26check_shifted_variable_sumId34custom_multiply_multiple_variable2IdEEvT_S2_S2_S2_S2_ = comdat any

$_ZN33custom_multiply_multiple_variableIdE8do_shiftEddddd = comdat any

$_Z26check_shifted_variable_sumId33custom_multiply_multiple_variableIdEEvT_S2_S2_S2_S2_ = comdat any

$_ZN24custom_multiply_variableIdE8do_shiftEdd = comdat any

$_Z26check_shifted_variable_sumId24custom_multiply_variableIdEEvT_S2_ = comdat any

$_ZN28custom_sub_multiple_variableIdE8do_shiftEddddd = comdat any

$_Z26check_shifted_variable_sumId28custom_sub_multiple_variableIdEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_sub_variableIdE8do_shiftEdd = comdat any

$_Z26check_shifted_variable_sumId19custom_sub_variableIdEEvT_S2_ = comdat any

$_ZN28custom_add_multiple_variableIdE8do_shiftEddddd = comdat any

$_Z26check_shifted_variable_sumId28custom_add_multiple_variableIdEEvT_S2_S2_S2_S2_ = comdat any

$_Z26check_shifted_variable_sumId19custom_add_variableIdEEvT_S2_ = comdat any

$_ZN19custom_add_variableIdE8do_shiftEdd = comdat any

$_ZN30custom_mixed_multiple_variableIfE8do_shiftEfffff = comdat any

$_Z26check_shifted_variable_sumIf30custom_mixed_multiple_variableIfEEvT_S2_S2_S2_S2_ = comdat any

$_Z15tolerance_equalIfEbRT_S1_ = comdat any

$_ZSt4fabsf = comdat any

$_ZN32custom_divide_multiple_variable2IfE8do_shiftEfffff = comdat any

$_Z26check_shifted_variable_sumIf32custom_divide_multiple_variable2IfEEvT_S2_S2_S2_S2_ = comdat any

$_ZN31custom_divide_multiple_variableIfE8do_shiftEfffff = comdat any

$_Z26check_shifted_variable_sumIf31custom_divide_multiple_variableIfEEvT_S2_S2_S2_S2_ = comdat any

$_ZN22custom_divide_variableIfE8do_shiftEff = comdat any

$_Z26check_shifted_variable_sumIf22custom_divide_variableIfEEvT_S2_ = comdat any

$_ZN34custom_multiply_multiple_variable2IfE8do_shiftEfffff = comdat any

$_Z26check_shifted_variable_sumIf34custom_multiply_multiple_variable2IfEEvT_S2_S2_S2_S2_ = comdat any

$_ZN33custom_multiply_multiple_variableIfE8do_shiftEfffff = comdat any

$_Z26check_shifted_variable_sumIf33custom_multiply_multiple_variableIfEEvT_S2_S2_S2_S2_ = comdat any

$_ZN24custom_multiply_variableIfE8do_shiftEff = comdat any

$_Z26check_shifted_variable_sumIf24custom_multiply_variableIfEEvT_S2_ = comdat any

$_ZN28custom_sub_multiple_variableIfE8do_shiftEfffff = comdat any

$_Z26check_shifted_variable_sumIf28custom_sub_multiple_variableIfEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_sub_variableIfE8do_shiftEff = comdat any

$_Z26check_shifted_variable_sumIf19custom_sub_variableIfEEvT_S2_ = comdat any

$_ZN28custom_add_multiple_variableIfE8do_shiftEfffff = comdat any

$_Z26check_shifted_variable_sumIf28custom_add_multiple_variableIfEEvT_S2_S2_S2_S2_ = comdat any

$_Z26check_shifted_variable_sumIf19custom_add_variableIfEEvT_S2_ = comdat any

$_ZN19custom_add_variableIfE8do_shiftEff = comdat any

$_ZN28custom_multiple_variable_xorImE8do_shiftEmmmmm = comdat any

$_Z26check_shifted_variable_sumIm28custom_multiple_variable_xorImEEvT_S2_S2_S2_S2_ = comdat any

$_Z15tolerance_equalImEbRT_S1_ = comdat any

$_ZN19custom_variable_xorImE8do_shiftEmm = comdat any

$_Z26check_shifted_variable_sumIm19custom_variable_xorImEEvT_S2_ = comdat any

$_ZN27custom_multiple_variable_orImE8do_shiftEmmmmm = comdat any

$_Z26check_shifted_variable_sumIm27custom_multiple_variable_orImEEvT_S2_S2_S2_S2_ = comdat any

$_ZN18custom_variable_orImE8do_shiftEmm = comdat any

$_Z26check_shifted_variable_sumIm18custom_variable_orImEEvT_S2_ = comdat any

$_ZN28custom_multiple_variable_andImE8do_shiftEmmmmm = comdat any

$_Z26check_shifted_variable_sumIm28custom_multiple_variable_andImEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_variable_andImE8do_shiftEmm = comdat any

$_Z26check_shifted_variable_sumIm19custom_variable_andImEEvT_S2_ = comdat any

$_ZN30custom_mixed_multiple_variableImE8do_shiftEmmmmm = comdat any

$_Z26check_shifted_variable_sumIm30custom_mixed_multiple_variableImEEvT_S2_S2_S2_S2_ = comdat any

$_ZN32custom_divide_multiple_variable2ImE8do_shiftEmmmmm = comdat any

$_Z26check_shifted_variable_sumIm32custom_divide_multiple_variable2ImEEvT_S2_S2_S2_S2_ = comdat any

$_ZN31custom_divide_multiple_variableImE8do_shiftEmmmmm = comdat any

$_Z26check_shifted_variable_sumIm31custom_divide_multiple_variableImEEvT_S2_S2_S2_S2_ = comdat any

$_ZN22custom_divide_variableImE8do_shiftEmm = comdat any

$_Z26check_shifted_variable_sumIm22custom_divide_variableImEEvT_S2_ = comdat any

$_ZN34custom_multiply_multiple_variable2ImE8do_shiftEmmmmm = comdat any

$_Z26check_shifted_variable_sumIm34custom_multiply_multiple_variable2ImEEvT_S2_S2_S2_S2_ = comdat any

$_ZN33custom_multiply_multiple_variableImE8do_shiftEmmmmm = comdat any

$_Z26check_shifted_variable_sumIm33custom_multiply_multiple_variableImEEvT_S2_S2_S2_S2_ = comdat any

$_ZN24custom_multiply_variableImE8do_shiftEmm = comdat any

$_Z26check_shifted_variable_sumIm24custom_multiply_variableImEEvT_S2_ = comdat any

$_ZN28custom_sub_multiple_variableImE8do_shiftEmmmmm = comdat any

$_Z26check_shifted_variable_sumIm28custom_sub_multiple_variableImEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_sub_variableImE8do_shiftEmm = comdat any

$_Z26check_shifted_variable_sumIm19custom_sub_variableImEEvT_S2_ = comdat any

$_ZN28custom_add_multiple_variableImE8do_shiftEmmmmm = comdat any

$_Z26check_shifted_variable_sumIm28custom_add_multiple_variableImEEvT_S2_S2_S2_S2_ = comdat any

$_Z26check_shifted_variable_sumIm19custom_add_variableImEEvT_S2_ = comdat any

$_ZN19custom_add_variableImE8do_shiftEmm = comdat any

$_ZN28custom_multiple_variable_xorIlE8do_shiftElllll = comdat any

$_Z26check_shifted_variable_sumIl28custom_multiple_variable_xorIlEEvT_S2_S2_S2_S2_ = comdat any

$_Z15tolerance_equalIlEbRT_S1_ = comdat any

$_ZN19custom_variable_xorIlE8do_shiftEll = comdat any

$_Z26check_shifted_variable_sumIl19custom_variable_xorIlEEvT_S2_ = comdat any

$_ZN27custom_multiple_variable_orIlE8do_shiftElllll = comdat any

$_Z26check_shifted_variable_sumIl27custom_multiple_variable_orIlEEvT_S2_S2_S2_S2_ = comdat any

$_ZN18custom_variable_orIlE8do_shiftEll = comdat any

$_Z26check_shifted_variable_sumIl18custom_variable_orIlEEvT_S2_ = comdat any

$_ZN28custom_multiple_variable_andIlE8do_shiftElllll = comdat any

$_Z26check_shifted_variable_sumIl28custom_multiple_variable_andIlEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_variable_andIlE8do_shiftEll = comdat any

$_Z26check_shifted_variable_sumIl19custom_variable_andIlEEvT_S2_ = comdat any

$_ZN30custom_mixed_multiple_variableIlE8do_shiftElllll = comdat any

$_Z26check_shifted_variable_sumIl30custom_mixed_multiple_variableIlEEvT_S2_S2_S2_S2_ = comdat any

$_ZN32custom_divide_multiple_variable2IlE8do_shiftElllll = comdat any

$_Z26check_shifted_variable_sumIl32custom_divide_multiple_variable2IlEEvT_S2_S2_S2_S2_ = comdat any

$_ZN31custom_divide_multiple_variableIlE8do_shiftElllll = comdat any

$_Z26check_shifted_variable_sumIl31custom_divide_multiple_variableIlEEvT_S2_S2_S2_S2_ = comdat any

$_ZN22custom_divide_variableIlE8do_shiftEll = comdat any

$_Z26check_shifted_variable_sumIl22custom_divide_variableIlEEvT_S2_ = comdat any

$_ZN34custom_multiply_multiple_variable2IlE8do_shiftElllll = comdat any

$_Z26check_shifted_variable_sumIl34custom_multiply_multiple_variable2IlEEvT_S2_S2_S2_S2_ = comdat any

$_ZN33custom_multiply_multiple_variableIlE8do_shiftElllll = comdat any

$_Z26check_shifted_variable_sumIl33custom_multiply_multiple_variableIlEEvT_S2_S2_S2_S2_ = comdat any

$_ZN24custom_multiply_variableIlE8do_shiftEll = comdat any

$_Z26check_shifted_variable_sumIl24custom_multiply_variableIlEEvT_S2_ = comdat any

$_ZN28custom_sub_multiple_variableIlE8do_shiftElllll = comdat any

$_Z26check_shifted_variable_sumIl28custom_sub_multiple_variableIlEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_sub_variableIlE8do_shiftEll = comdat any

$_Z26check_shifted_variable_sumIl19custom_sub_variableIlEEvT_S2_ = comdat any

$_ZN28custom_add_multiple_variableIlE8do_shiftElllll = comdat any

$_Z26check_shifted_variable_sumIl28custom_add_multiple_variableIlEEvT_S2_S2_S2_S2_ = comdat any

$_Z26check_shifted_variable_sumIl19custom_add_variableIlEEvT_S2_ = comdat any

$_ZN19custom_add_variableIlE8do_shiftEll = comdat any

$_ZN28custom_multiple_variable_xorIjE8do_shiftEjjjjj = comdat any

$_Z26check_shifted_variable_sumIj28custom_multiple_variable_xorIjEEvT_S2_S2_S2_S2_ = comdat any

$_Z15tolerance_equalIjEbRT_S1_ = comdat any

$_ZN19custom_variable_xorIjE8do_shiftEjj = comdat any

$_Z26check_shifted_variable_sumIj19custom_variable_xorIjEEvT_S2_ = comdat any

$_ZN27custom_multiple_variable_orIjE8do_shiftEjjjjj = comdat any

$_Z26check_shifted_variable_sumIj27custom_multiple_variable_orIjEEvT_S2_S2_S2_S2_ = comdat any

$_ZN18custom_variable_orIjE8do_shiftEjj = comdat any

$_Z26check_shifted_variable_sumIj18custom_variable_orIjEEvT_S2_ = comdat any

$_ZN28custom_multiple_variable_andIjE8do_shiftEjjjjj = comdat any

$_Z26check_shifted_variable_sumIj28custom_multiple_variable_andIjEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_variable_andIjE8do_shiftEjj = comdat any

$_Z26check_shifted_variable_sumIj19custom_variable_andIjEEvT_S2_ = comdat any

$_ZN30custom_mixed_multiple_variableIjE8do_shiftEjjjjj = comdat any

$_Z26check_shifted_variable_sumIj30custom_mixed_multiple_variableIjEEvT_S2_S2_S2_S2_ = comdat any

$_ZN32custom_divide_multiple_variable2IjE8do_shiftEjjjjj = comdat any

$_Z26check_shifted_variable_sumIj32custom_divide_multiple_variable2IjEEvT_S2_S2_S2_S2_ = comdat any

$_ZN31custom_divide_multiple_variableIjE8do_shiftEjjjjj = comdat any

$_Z26check_shifted_variable_sumIj31custom_divide_multiple_variableIjEEvT_S2_S2_S2_S2_ = comdat any

$_ZN22custom_divide_variableIjE8do_shiftEjj = comdat any

$_Z26check_shifted_variable_sumIj22custom_divide_variableIjEEvT_S2_ = comdat any

$_ZN34custom_multiply_multiple_variable2IjE8do_shiftEjjjjj = comdat any

$_Z26check_shifted_variable_sumIj34custom_multiply_multiple_variable2IjEEvT_S2_S2_S2_S2_ = comdat any

$_ZN33custom_multiply_multiple_variableIjE8do_shiftEjjjjj = comdat any

$_Z26check_shifted_variable_sumIj33custom_multiply_multiple_variableIjEEvT_S2_S2_S2_S2_ = comdat any

$_ZN24custom_multiply_variableIjE8do_shiftEjj = comdat any

$_Z26check_shifted_variable_sumIj24custom_multiply_variableIjEEvT_S2_ = comdat any

$_ZN28custom_sub_multiple_variableIjE8do_shiftEjjjjj = comdat any

$_Z26check_shifted_variable_sumIj28custom_sub_multiple_variableIjEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_sub_variableIjE8do_shiftEjj = comdat any

$_Z26check_shifted_variable_sumIj19custom_sub_variableIjEEvT_S2_ = comdat any

$_ZN28custom_add_multiple_variableIjE8do_shiftEjjjjj = comdat any

$_Z26check_shifted_variable_sumIj28custom_add_multiple_variableIjEEvT_S2_S2_S2_S2_ = comdat any

$_Z26check_shifted_variable_sumIj19custom_add_variableIjEEvT_S2_ = comdat any

$_ZN19custom_add_variableIjE8do_shiftEjj = comdat any

$_ZN28custom_multiple_variable_xorIiE8do_shiftEiiiii = comdat any

$_Z26check_shifted_variable_sumIi28custom_multiple_variable_xorIiEEvT_S2_S2_S2_S2_ = comdat any

$_Z15tolerance_equalIiEbRT_S1_ = comdat any

$_ZN19custom_variable_xorIiE8do_shiftEii = comdat any

$_Z26check_shifted_variable_sumIi19custom_variable_xorIiEEvT_S2_ = comdat any

$_ZN27custom_multiple_variable_orIiE8do_shiftEiiiii = comdat any

$_Z26check_shifted_variable_sumIi27custom_multiple_variable_orIiEEvT_S2_S2_S2_S2_ = comdat any

$_ZN18custom_variable_orIiE8do_shiftEii = comdat any

$_Z26check_shifted_variable_sumIi18custom_variable_orIiEEvT_S2_ = comdat any

$_ZN28custom_multiple_variable_andIiE8do_shiftEiiiii = comdat any

$_Z26check_shifted_variable_sumIi28custom_multiple_variable_andIiEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_variable_andIiE8do_shiftEii = comdat any

$_Z26check_shifted_variable_sumIi19custom_variable_andIiEEvT_S2_ = comdat any

$_ZN30custom_mixed_multiple_variableIiE8do_shiftEiiiii = comdat any

$_Z26check_shifted_variable_sumIi30custom_mixed_multiple_variableIiEEvT_S2_S2_S2_S2_ = comdat any

$_ZN32custom_divide_multiple_variable2IiE8do_shiftEiiiii = comdat any

$_Z26check_shifted_variable_sumIi32custom_divide_multiple_variable2IiEEvT_S2_S2_S2_S2_ = comdat any

$_ZN31custom_divide_multiple_variableIiE8do_shiftEiiiii = comdat any

$_Z26check_shifted_variable_sumIi31custom_divide_multiple_variableIiEEvT_S2_S2_S2_S2_ = comdat any

$_ZN22custom_divide_variableIiE8do_shiftEii = comdat any

$_Z26check_shifted_variable_sumIi22custom_divide_variableIiEEvT_S2_ = comdat any

$_ZN34custom_multiply_multiple_variable2IiE8do_shiftEiiiii = comdat any

$_Z26check_shifted_variable_sumIi34custom_multiply_multiple_variable2IiEEvT_S2_S2_S2_S2_ = comdat any

$_ZN33custom_multiply_multiple_variableIiE8do_shiftEiiiii = comdat any

$_Z26check_shifted_variable_sumIi33custom_multiply_multiple_variableIiEEvT_S2_S2_S2_S2_ = comdat any

$_ZN24custom_multiply_variableIiE8do_shiftEii = comdat any

$_Z26check_shifted_variable_sumIi24custom_multiply_variableIiEEvT_S2_ = comdat any

$_ZN28custom_sub_multiple_variableIiE8do_shiftEiiiii = comdat any

$_Z26check_shifted_variable_sumIi28custom_sub_multiple_variableIiEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_sub_variableIiE8do_shiftEii = comdat any

$_Z26check_shifted_variable_sumIi19custom_sub_variableIiEEvT_S2_ = comdat any

$_ZN28custom_add_multiple_variableIiE8do_shiftEiiiii = comdat any

$_Z26check_shifted_variable_sumIi28custom_add_multiple_variableIiEEvT_S2_S2_S2_S2_ = comdat any

$_Z26check_shifted_variable_sumIi19custom_add_variableIiEEvT_S2_ = comdat any

$_ZN19custom_add_variableIiE8do_shiftEii = comdat any

$_ZN28custom_multiple_variable_xorItE8do_shiftEttttt = comdat any

$_Z26check_shifted_variable_sumIt28custom_multiple_variable_xorItEEvT_S2_S2_S2_S2_ = comdat any

$_Z15tolerance_equalItEbRT_S1_ = comdat any

$_ZN19custom_variable_xorItE8do_shiftEtt = comdat any

$_Z26check_shifted_variable_sumIt19custom_variable_xorItEEvT_S2_ = comdat any

$_ZN27custom_multiple_variable_orItE8do_shiftEttttt = comdat any

$_Z26check_shifted_variable_sumIt27custom_multiple_variable_orItEEvT_S2_S2_S2_S2_ = comdat any

$_ZN18custom_variable_orItE8do_shiftEtt = comdat any

$_Z26check_shifted_variable_sumIt18custom_variable_orItEEvT_S2_ = comdat any

$_ZN28custom_multiple_variable_andItE8do_shiftEttttt = comdat any

$_Z26check_shifted_variable_sumIt28custom_multiple_variable_andItEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_variable_andItE8do_shiftEtt = comdat any

$_Z26check_shifted_variable_sumIt19custom_variable_andItEEvT_S2_ = comdat any

$_ZN30custom_mixed_multiple_variableItE8do_shiftEttttt = comdat any

$_Z26check_shifted_variable_sumIt30custom_mixed_multiple_variableItEEvT_S2_S2_S2_S2_ = comdat any

$_ZN32custom_divide_multiple_variable2ItE8do_shiftEttttt = comdat any

$_Z26check_shifted_variable_sumIt32custom_divide_multiple_variable2ItEEvT_S2_S2_S2_S2_ = comdat any

$_ZN31custom_divide_multiple_variableItE8do_shiftEttttt = comdat any

$_Z26check_shifted_variable_sumIt31custom_divide_multiple_variableItEEvT_S2_S2_S2_S2_ = comdat any

$_ZN22custom_divide_variableItE8do_shiftEtt = comdat any

$_Z26check_shifted_variable_sumIt22custom_divide_variableItEEvT_S2_ = comdat any

$_ZN34custom_multiply_multiple_variable2ItE8do_shiftEttttt = comdat any

$_Z26check_shifted_variable_sumIt34custom_multiply_multiple_variable2ItEEvT_S2_S2_S2_S2_ = comdat any

$_ZN33custom_multiply_multiple_variableItE8do_shiftEttttt = comdat any

$_Z26check_shifted_variable_sumIt33custom_multiply_multiple_variableItEEvT_S2_S2_S2_S2_ = comdat any

$_ZN24custom_multiply_variableItE8do_shiftEtt = comdat any

$_Z26check_shifted_variable_sumIt24custom_multiply_variableItEEvT_S2_ = comdat any

$_ZN28custom_sub_multiple_variableItE8do_shiftEttttt = comdat any

$_Z26check_shifted_variable_sumIt28custom_sub_multiple_variableItEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_sub_variableItE8do_shiftEtt = comdat any

$_Z26check_shifted_variable_sumIt19custom_sub_variableItEEvT_S2_ = comdat any

$_ZN28custom_add_multiple_variableItE8do_shiftEttttt = comdat any

$_Z26check_shifted_variable_sumIt28custom_add_multiple_variableItEEvT_S2_S2_S2_S2_ = comdat any

$_Z26check_shifted_variable_sumIt19custom_add_variableItEEvT_S2_ = comdat any

$_ZN19custom_add_variableItE8do_shiftEtt = comdat any

$_ZN28custom_multiple_variable_xorIsE8do_shiftEsssss = comdat any

$_Z26check_shifted_variable_sumIs28custom_multiple_variable_xorIsEEvT_S2_S2_S2_S2_ = comdat any

$_Z15tolerance_equalIsEbRT_S1_ = comdat any

$_ZN19custom_variable_xorIsE8do_shiftEss = comdat any

$_Z26check_shifted_variable_sumIs19custom_variable_xorIsEEvT_S2_ = comdat any

$_ZN27custom_multiple_variable_orIsE8do_shiftEsssss = comdat any

$_Z26check_shifted_variable_sumIs27custom_multiple_variable_orIsEEvT_S2_S2_S2_S2_ = comdat any

$_ZN18custom_variable_orIsE8do_shiftEss = comdat any

$_Z26check_shifted_variable_sumIs18custom_variable_orIsEEvT_S2_ = comdat any

$_ZN28custom_multiple_variable_andIsE8do_shiftEsssss = comdat any

$_Z26check_shifted_variable_sumIs28custom_multiple_variable_andIsEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_variable_andIsE8do_shiftEss = comdat any

$_Z26check_shifted_variable_sumIs19custom_variable_andIsEEvT_S2_ = comdat any

$_ZN30custom_mixed_multiple_variableIsE8do_shiftEsssss = comdat any

$_Z26check_shifted_variable_sumIs30custom_mixed_multiple_variableIsEEvT_S2_S2_S2_S2_ = comdat any

$_ZN32custom_divide_multiple_variable2IsE8do_shiftEsssss = comdat any

$_Z26check_shifted_variable_sumIs32custom_divide_multiple_variable2IsEEvT_S2_S2_S2_S2_ = comdat any

$_ZN31custom_divide_multiple_variableIsE8do_shiftEsssss = comdat any

$_Z26check_shifted_variable_sumIs31custom_divide_multiple_variableIsEEvT_S2_S2_S2_S2_ = comdat any

$_ZN22custom_divide_variableIsE8do_shiftEss = comdat any

$_Z26check_shifted_variable_sumIs22custom_divide_variableIsEEvT_S2_ = comdat any

$_ZN34custom_multiply_multiple_variable2IsE8do_shiftEsssss = comdat any

$_Z26check_shifted_variable_sumIs34custom_multiply_multiple_variable2IsEEvT_S2_S2_S2_S2_ = comdat any

$_ZN33custom_multiply_multiple_variableIsE8do_shiftEsssss = comdat any

$_Z26check_shifted_variable_sumIs33custom_multiply_multiple_variableIsEEvT_S2_S2_S2_S2_ = comdat any

$_ZN24custom_multiply_variableIsE8do_shiftEss = comdat any

$_Z26check_shifted_variable_sumIs24custom_multiply_variableIsEEvT_S2_ = comdat any

$_ZN28custom_sub_multiple_variableIsE8do_shiftEsssss = comdat any

$_Z26check_shifted_variable_sumIs28custom_sub_multiple_variableIsEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_sub_variableIsE8do_shiftEss = comdat any

$_Z26check_shifted_variable_sumIs19custom_sub_variableIsEEvT_S2_ = comdat any

$_ZN28custom_add_multiple_variableIsE8do_shiftEsssss = comdat any

$_Z26check_shifted_variable_sumIs28custom_add_multiple_variableIsEEvT_S2_S2_S2_S2_ = comdat any

$_Z26check_shifted_variable_sumIs19custom_add_variableIsEEvT_S2_ = comdat any

$_ZN19custom_add_variableIsE8do_shiftEss = comdat any

$_ZN28custom_multiple_variable_xorIhE8do_shiftEhhhhh = comdat any

$_Z26check_shifted_variable_sumIh28custom_multiple_variable_xorIhEEvT_S2_S2_S2_S2_ = comdat any

$_Z15tolerance_equalIhEbRT_S1_ = comdat any

$_ZN19custom_variable_xorIhE8do_shiftEhh = comdat any

$_Z26check_shifted_variable_sumIh19custom_variable_xorIhEEvT_S2_ = comdat any

$_ZN27custom_multiple_variable_orIhE8do_shiftEhhhhh = comdat any

$_Z26check_shifted_variable_sumIh27custom_multiple_variable_orIhEEvT_S2_S2_S2_S2_ = comdat any

$_ZN18custom_variable_orIhE8do_shiftEhh = comdat any

$_Z26check_shifted_variable_sumIh18custom_variable_orIhEEvT_S2_ = comdat any

$_ZN28custom_multiple_variable_andIhE8do_shiftEhhhhh = comdat any

$_Z26check_shifted_variable_sumIh28custom_multiple_variable_andIhEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_variable_andIhE8do_shiftEhh = comdat any

$_Z26check_shifted_variable_sumIh19custom_variable_andIhEEvT_S2_ = comdat any

$_ZN30custom_mixed_multiple_variableIhE8do_shiftEhhhhh = comdat any

$_Z26check_shifted_variable_sumIh30custom_mixed_multiple_variableIhEEvT_S2_S2_S2_S2_ = comdat any

$_ZN32custom_divide_multiple_variable2IhE8do_shiftEhhhhh = comdat any

$_Z26check_shifted_variable_sumIh32custom_divide_multiple_variable2IhEEvT_S2_S2_S2_S2_ = comdat any

$_ZN31custom_divide_multiple_variableIhE8do_shiftEhhhhh = comdat any

$_Z26check_shifted_variable_sumIh31custom_divide_multiple_variableIhEEvT_S2_S2_S2_S2_ = comdat any

$_ZN22custom_divide_variableIhE8do_shiftEhh = comdat any

$_Z26check_shifted_variable_sumIh22custom_divide_variableIhEEvT_S2_ = comdat any

$_ZN34custom_multiply_multiple_variable2IhE8do_shiftEhhhhh = comdat any

$_Z26check_shifted_variable_sumIh34custom_multiply_multiple_variable2IhEEvT_S2_S2_S2_S2_ = comdat any

$_ZN33custom_multiply_multiple_variableIhE8do_shiftEhhhhh = comdat any

$_Z26check_shifted_variable_sumIh33custom_multiply_multiple_variableIhEEvT_S2_S2_S2_S2_ = comdat any

$_ZN24custom_multiply_variableIhE8do_shiftEhh = comdat any

$_Z26check_shifted_variable_sumIh24custom_multiply_variableIhEEvT_S2_ = comdat any

$_ZN28custom_sub_multiple_variableIhE8do_shiftEhhhhh = comdat any

$_Z26check_shifted_variable_sumIh28custom_sub_multiple_variableIhEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_sub_variableIhE8do_shiftEhh = comdat any

$_Z26check_shifted_variable_sumIh19custom_sub_variableIhEEvT_S2_ = comdat any

$_ZN28custom_add_multiple_variableIhE8do_shiftEhhhhh = comdat any

$_Z26check_shifted_variable_sumIh28custom_add_multiple_variableIhEEvT_S2_S2_S2_S2_ = comdat any

$_Z26check_shifted_variable_sumIh19custom_add_variableIhEEvT_S2_ = comdat any

$_ZN19custom_add_variableIhE8do_shiftEhh = comdat any

$_ZN28custom_multiple_variable_xorIaE8do_shiftEaaaaa = comdat any

$_Z26check_shifted_variable_sumIa28custom_multiple_variable_xorIaEEvT_S2_S2_S2_S2_ = comdat any

$_Z15tolerance_equalIaEbRT_S1_ = comdat any

$_ZN19custom_variable_xorIaE8do_shiftEaa = comdat any

$_Z26check_shifted_variable_sumIa19custom_variable_xorIaEEvT_S2_ = comdat any

$_ZN27custom_multiple_variable_orIaE8do_shiftEaaaaa = comdat any

$_Z26check_shifted_variable_sumIa27custom_multiple_variable_orIaEEvT_S2_S2_S2_S2_ = comdat any

$_ZN18custom_variable_orIaE8do_shiftEaa = comdat any

$_Z26check_shifted_variable_sumIa18custom_variable_orIaEEvT_S2_ = comdat any

$_ZN28custom_multiple_variable_andIaE8do_shiftEaaaaa = comdat any

$_Z26check_shifted_variable_sumIa28custom_multiple_variable_andIaEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_variable_andIaE8do_shiftEaa = comdat any

$_Z26check_shifted_variable_sumIa19custom_variable_andIaEEvT_S2_ = comdat any

$_ZN30custom_mixed_multiple_variableIaE8do_shiftEaaaaa = comdat any

$_Z26check_shifted_variable_sumIa30custom_mixed_multiple_variableIaEEvT_S2_S2_S2_S2_ = comdat any

$_ZN32custom_divide_multiple_variable2IaE8do_shiftEaaaaa = comdat any

$_Z26check_shifted_variable_sumIa32custom_divide_multiple_variable2IaEEvT_S2_S2_S2_S2_ = comdat any

$_ZN31custom_divide_multiple_variableIaE8do_shiftEaaaaa = comdat any

$_Z26check_shifted_variable_sumIa31custom_divide_multiple_variableIaEEvT_S2_S2_S2_S2_ = comdat any

$_ZN22custom_divide_variableIaE8do_shiftEaa = comdat any

$_Z26check_shifted_variable_sumIa22custom_divide_variableIaEEvT_S2_ = comdat any

$_ZN34custom_multiply_multiple_variable2IaE8do_shiftEaaaaa = comdat any

$_Z26check_shifted_variable_sumIa34custom_multiply_multiple_variable2IaEEvT_S2_S2_S2_S2_ = comdat any

$_ZN33custom_multiply_multiple_variableIaE8do_shiftEaaaaa = comdat any

$_Z26check_shifted_variable_sumIa33custom_multiply_multiple_variableIaEEvT_S2_S2_S2_S2_ = comdat any

$_ZN24custom_multiply_variableIaE8do_shiftEaa = comdat any

$_Z26check_shifted_variable_sumIa24custom_multiply_variableIaEEvT_S2_ = comdat any

$_ZN28custom_sub_multiple_variableIaE8do_shiftEaaaaa = comdat any

$_Z26check_shifted_variable_sumIa28custom_sub_multiple_variableIaEEvT_S2_S2_S2_S2_ = comdat any

$_ZN19custom_sub_variableIaE8do_shiftEaa = comdat any

$_Z26check_shifted_variable_sumIa19custom_sub_variableIaEEvT_S2_ = comdat any

$_ZN28custom_add_multiple_variableIaE8do_shiftEaaaaa = comdat any

$_Z26check_shifted_variable_sumIa28custom_add_multiple_variableIaEEvT_S2_S2_S2_S2_ = comdat any

$_Z26check_shifted_variable_sumIa19custom_add_variableIaEEvT_S2_ = comdat any

$_ZN19custom_add_variableIaE8do_shiftEaa = comdat any

@results = global %struct.one_result* null, align 8
@current_test = global i32 0, align 4
@allocated_results = global i32 0, align 4
@start_time = global i64 0, align 8
@end_time = global i64 0, align 8
@iterations = global i32 1000, align 4
@init_value = global double 1.000000e+00, align 8
@dataDouble = global [8000 x double] zeroinitializer, align 16
@dataFloat = global [8000 x float] zeroinitializer, align 16
@data64unsigned = global [8000 x i64] zeroinitializer, align 16
@data64 = global [8000 x i64] zeroinitializer, align 16
@data32unsigned = global [8000 x i32] zeroinitializer, align 16
@data32 = global [8000 x i32] zeroinitializer, align 16
@data16unsigned = global [8000 x i16] zeroinitializer, align 16
@data16 = global [8000 x i16] zeroinitializer, align 16
@data8unsigned = global [8000 x i8] zeroinitializer, align 16
@data8 = global [8000 x i8] zeroinitializer, align 16
@.str = private unnamed_addr constant [31 x i8] c"Could not allocate %d results\0A\00", align 1
@.str.1 = private unnamed_addr constant [60 x i8] c"\0Atest %*s description   absolute   operations   ratio with\0A\00", align 1
@.str.2 = private unnamed_addr constant [2 x i8] c" \00", align 1
@.str.3 = private unnamed_addr constant [43 x i8] c"number %*s time       per second   test0\0A\0A\00", align 1
@.str.4 = private unnamed_addr constant [43 x i8] c"%2i %*s\22%s\22  %5.2f sec   %5.2f M     %.2f\0A\00", align 1
@.str.5 = private unnamed_addr constant [1 x i8] zeroinitializer, align 1
@.str.6 = private unnamed_addr constant [39 x i8] c"\0ATotal absolute time for %s: %.2f sec\0A\00", align 1
@.str.7 = private unnamed_addr constant [20 x i8] c"\0A%s Penalty: %.2f\0A\0A\00", align 1
@.str.8 = private unnamed_addr constant [34 x i8] c"\0Atest %*s description   absolute\0A\00", align 1
@.str.9 = private unnamed_addr constant [18 x i8] c"number %*s time\0A\0A\00", align 1
@.str.10 = private unnamed_addr constant [24 x i8] c"%2i %*s\22%s\22  %5.2f sec\0A\00", align 1
@.str.11 = private unnamed_addr constant [20 x i8] c"int8_t variable add\00", align 1
@.str.12 = private unnamed_addr constant [28 x i8] c"int8_t variable add hoisted\00", align 1
@.str.13 = private unnamed_addr constant [30 x i8] c"int8_t multiple variable adds\00", align 1
@.str.14 = private unnamed_addr constant [25 x i8] c"int8_t variable subtract\00", align 1
@.str.15 = private unnamed_addr constant [35 x i8] c"int8_t multiple variable subtracts\00", align 1
@.str.16 = private unnamed_addr constant [25 x i8] c"int8_t variable multiply\00", align 1
@.str.17 = private unnamed_addr constant [36 x i8] c"int8_t multiple variable multiplies\00", align 1
@.str.18 = private unnamed_addr constant [37 x i8] c"int8_t multiple variable multiplies2\00", align 1
@.str.19 = private unnamed_addr constant [23 x i8] c"int8_t variable divide\00", align 1
@.str.20 = private unnamed_addr constant [33 x i8] c"int8_t multiple variable divides\00", align 1
@.str.21 = private unnamed_addr constant [34 x i8] c"int8_t multiple variable divides2\00", align 1
@.str.22 = private unnamed_addr constant [31 x i8] c"int8_t multiple variable mixed\00", align 1
@.str.23 = private unnamed_addr constant [20 x i8] c"int8_t variable and\00", align 1
@.str.24 = private unnamed_addr constant [29 x i8] c"int8_t multiple variable and\00", align 1
@.str.25 = private unnamed_addr constant [19 x i8] c"int8_t variable or\00", align 1
@.str.26 = private unnamed_addr constant [28 x i8] c"int8_t multiple variable or\00", align 1
@.str.27 = private unnamed_addr constant [20 x i8] c"int8_t variable xor\00", align 1
@.str.28 = private unnamed_addr constant [29 x i8] c"int8_t multiple variable xor\00", align 1
@.str.29 = private unnamed_addr constant [21 x i8] c"uint8_t variable add\00", align 1
@.str.30 = private unnamed_addr constant [29 x i8] c"uint8_t variable add hoisted\00", align 1
@.str.31 = private unnamed_addr constant [31 x i8] c"uint8_t multiple variable adds\00", align 1
@.str.32 = private unnamed_addr constant [26 x i8] c"uint8_t variable subtract\00", align 1
@.str.33 = private unnamed_addr constant [36 x i8] c"uint8_t multiple variable subtracts\00", align 1
@.str.34 = private unnamed_addr constant [26 x i8] c"uint8_t variable multiply\00", align 1
@.str.35 = private unnamed_addr constant [37 x i8] c"uint8_t multiple variable multiplies\00", align 1
@.str.36 = private unnamed_addr constant [38 x i8] c"uint8_t multiple variable multiplies2\00", align 1
@.str.37 = private unnamed_addr constant [24 x i8] c"uint8_t variable divide\00", align 1
@.str.38 = private unnamed_addr constant [34 x i8] c"uint8_t multiple variable divides\00", align 1
@.str.39 = private unnamed_addr constant [35 x i8] c"uint8_t multiple variable divides2\00", align 1
@.str.40 = private unnamed_addr constant [32 x i8] c"uint8_t multiple variable mixed\00", align 1
@.str.41 = private unnamed_addr constant [21 x i8] c"uint8_t variable and\00", align 1
@.str.42 = private unnamed_addr constant [30 x i8] c"uint8_t multiple variable and\00", align 1
@.str.43 = private unnamed_addr constant [20 x i8] c"uint8_t variable or\00", align 1
@.str.44 = private unnamed_addr constant [29 x i8] c"uint8_t multiple variable or\00", align 1
@.str.45 = private unnamed_addr constant [21 x i8] c"uint8_t variable xor\00", align 1
@.str.46 = private unnamed_addr constant [30 x i8] c"uint8_t multiple variable xor\00", align 1
@.str.47 = private unnamed_addr constant [21 x i8] c"int16_t variable add\00", align 1
@.str.48 = private unnamed_addr constant [29 x i8] c"int16_t variable add hoisted\00", align 1
@.str.49 = private unnamed_addr constant [31 x i8] c"int16_t multiple variable adds\00", align 1
@.str.50 = private unnamed_addr constant [26 x i8] c"int16_t variable subtract\00", align 1
@.str.51 = private unnamed_addr constant [36 x i8] c"int16_t multiple variable subtracts\00", align 1
@.str.52 = private unnamed_addr constant [26 x i8] c"int16_t variable multiply\00", align 1
@.str.53 = private unnamed_addr constant [37 x i8] c"int16_t multiple variable multiplies\00", align 1
@.str.54 = private unnamed_addr constant [38 x i8] c"int16_t multiple variable multiplies2\00", align 1
@.str.55 = private unnamed_addr constant [24 x i8] c"int16_t variable divide\00", align 1
@.str.56 = private unnamed_addr constant [34 x i8] c"int16_t multiple variable divides\00", align 1
@.str.57 = private unnamed_addr constant [35 x i8] c"int16_t multiple variable divides2\00", align 1
@.str.58 = private unnamed_addr constant [32 x i8] c"int16_t multiple variable mixed\00", align 1
@.str.59 = private unnamed_addr constant [21 x i8] c"int16_t variable and\00", align 1
@.str.60 = private unnamed_addr constant [30 x i8] c"int16_t multiple variable and\00", align 1
@.str.61 = private unnamed_addr constant [20 x i8] c"int16_t variable or\00", align 1
@.str.62 = private unnamed_addr constant [29 x i8] c"int16_t multiple variable or\00", align 1
@.str.63 = private unnamed_addr constant [21 x i8] c"int16_t variable xor\00", align 1
@.str.64 = private unnamed_addr constant [30 x i8] c"int16_t multiple variable xor\00", align 1
@.str.65 = private unnamed_addr constant [22 x i8] c"uint16_t variable add\00", align 1
@.str.66 = private unnamed_addr constant [30 x i8] c"uint16_t variable add hoisted\00", align 1
@.str.67 = private unnamed_addr constant [32 x i8] c"uint16_t multiple variable adds\00", align 1
@.str.68 = private unnamed_addr constant [27 x i8] c"uint16_t variable subtract\00", align 1
@.str.69 = private unnamed_addr constant [37 x i8] c"uint16_t multiple variable subtracts\00", align 1
@.str.70 = private unnamed_addr constant [27 x i8] c"uint16_t variable multiply\00", align 1
@.str.71 = private unnamed_addr constant [38 x i8] c"uint16_t multiple variable multiplies\00", align 1
@.str.72 = private unnamed_addr constant [39 x i8] c"uint16_t multiple variable multiplies2\00", align 1
@.str.73 = private unnamed_addr constant [25 x i8] c"uint16_t variable divide\00", align 1
@.str.74 = private unnamed_addr constant [35 x i8] c"uint16_t multiple variable divides\00", align 1
@.str.75 = private unnamed_addr constant [36 x i8] c"uint16_t multiple variable divides2\00", align 1
@.str.76 = private unnamed_addr constant [33 x i8] c"uint16_t multiple variable mixed\00", align 1
@.str.77 = private unnamed_addr constant [22 x i8] c"uint16_t variable and\00", align 1
@.str.78 = private unnamed_addr constant [31 x i8] c"uint16_t multiple variable and\00", align 1
@.str.79 = private unnamed_addr constant [21 x i8] c"uint16_t variable or\00", align 1
@.str.80 = private unnamed_addr constant [30 x i8] c"uint16_t multiple variable or\00", align 1
@.str.81 = private unnamed_addr constant [22 x i8] c"uint16_t variable xor\00", align 1
@.str.82 = private unnamed_addr constant [31 x i8] c"uint16_t multiple variable xor\00", align 1
@.str.83 = private unnamed_addr constant [21 x i8] c"int32_t variable add\00", align 1
@.str.84 = private unnamed_addr constant [29 x i8] c"int32_t variable add hoisted\00", align 1
@.str.85 = private unnamed_addr constant [31 x i8] c"int32_t multiple variable adds\00", align 1
@.str.86 = private unnamed_addr constant [26 x i8] c"int32_t variable subtract\00", align 1
@.str.87 = private unnamed_addr constant [36 x i8] c"int32_t multiple variable subtracts\00", align 1
@.str.88 = private unnamed_addr constant [26 x i8] c"int32_t variable multiply\00", align 1
@.str.89 = private unnamed_addr constant [37 x i8] c"int32_t multiple variable multiplies\00", align 1
@.str.90 = private unnamed_addr constant [38 x i8] c"int32_t multiple variable multiplies2\00", align 1
@.str.91 = private unnamed_addr constant [24 x i8] c"int32_t variable divide\00", align 1
@.str.92 = private unnamed_addr constant [34 x i8] c"int32_t multiple variable divides\00", align 1
@.str.93 = private unnamed_addr constant [35 x i8] c"int32_t multiple variable divides2\00", align 1
@.str.94 = private unnamed_addr constant [32 x i8] c"int32_t multiple variable mixed\00", align 1
@.str.95 = private unnamed_addr constant [21 x i8] c"int32_t variable and\00", align 1
@.str.96 = private unnamed_addr constant [30 x i8] c"int32_t multiple variable and\00", align 1
@.str.97 = private unnamed_addr constant [20 x i8] c"int32_t variable or\00", align 1
@.str.98 = private unnamed_addr constant [29 x i8] c"int32_t multiple variable or\00", align 1
@.str.99 = private unnamed_addr constant [21 x i8] c"int32_t variable xor\00", align 1
@.str.100 = private unnamed_addr constant [30 x i8] c"int32_t multiple variable xor\00", align 1
@.str.101 = private unnamed_addr constant [22 x i8] c"uint32_t variable add\00", align 1
@.str.102 = private unnamed_addr constant [30 x i8] c"uint32_t variable add hoisted\00", align 1
@.str.103 = private unnamed_addr constant [32 x i8] c"uint32_t multiple variable adds\00", align 1
@.str.104 = private unnamed_addr constant [27 x i8] c"uint32_t variable subtract\00", align 1
@.str.105 = private unnamed_addr constant [37 x i8] c"uint32_t multiple variable subtracts\00", align 1
@.str.106 = private unnamed_addr constant [27 x i8] c"uint32_t variable multiply\00", align 1
@.str.107 = private unnamed_addr constant [38 x i8] c"uint32_t multiple variable multiplies\00", align 1
@.str.108 = private unnamed_addr constant [39 x i8] c"uint32_t multiple variable multiplies2\00", align 1
@.str.109 = private unnamed_addr constant [25 x i8] c"uint32_t variable divide\00", align 1
@.str.110 = private unnamed_addr constant [35 x i8] c"uint32_t multiple variable divides\00", align 1
@.str.111 = private unnamed_addr constant [36 x i8] c"uint32_t multiple variable divides2\00", align 1
@.str.112 = private unnamed_addr constant [33 x i8] c"uint32_t multiple variable mixed\00", align 1
@.str.113 = private unnamed_addr constant [22 x i8] c"uint32_t variable and\00", align 1
@.str.114 = private unnamed_addr constant [31 x i8] c"uint32_t multiple variable and\00", align 1
@.str.115 = private unnamed_addr constant [21 x i8] c"uint32_t variable or\00", align 1
@.str.116 = private unnamed_addr constant [30 x i8] c"uint32_t multiple variable or\00", align 1
@.str.117 = private unnamed_addr constant [22 x i8] c"uint32_t variable xor\00", align 1
@.str.118 = private unnamed_addr constant [31 x i8] c"uint32_t multiple variable xor\00", align 1
@.str.119 = private unnamed_addr constant [21 x i8] c"int64_t variable add\00", align 1
@.str.120 = private unnamed_addr constant [29 x i8] c"int64_t variable add hoisted\00", align 1
@.str.121 = private unnamed_addr constant [31 x i8] c"int64_t multiple variable adds\00", align 1
@.str.122 = private unnamed_addr constant [26 x i8] c"int64_t variable subtract\00", align 1
@.str.123 = private unnamed_addr constant [36 x i8] c"int64_t multiple variable subtracts\00", align 1
@.str.124 = private unnamed_addr constant [26 x i8] c"int64_t variable multiply\00", align 1
@.str.125 = private unnamed_addr constant [37 x i8] c"int64_t multiple variable multiplies\00", align 1
@.str.126 = private unnamed_addr constant [38 x i8] c"int64_t multiple variable multiplies2\00", align 1
@.str.127 = private unnamed_addr constant [24 x i8] c"int64_t variable divide\00", align 1
@.str.128 = private unnamed_addr constant [34 x i8] c"int64_t multiple variable divides\00", align 1
@.str.129 = private unnamed_addr constant [35 x i8] c"int64_t multiple variable divides2\00", align 1
@.str.130 = private unnamed_addr constant [32 x i8] c"int64_t multiple variable mixed\00", align 1
@.str.131 = private unnamed_addr constant [21 x i8] c"int64_t variable and\00", align 1
@.str.132 = private unnamed_addr constant [30 x i8] c"int64_t multiple variable and\00", align 1
@.str.133 = private unnamed_addr constant [20 x i8] c"int64_t variable or\00", align 1
@.str.134 = private unnamed_addr constant [29 x i8] c"int64_t multiple variable or\00", align 1
@.str.135 = private unnamed_addr constant [21 x i8] c"int64_t variable xor\00", align 1
@.str.136 = private unnamed_addr constant [30 x i8] c"int64_t multiple variable xor\00", align 1
@.str.137 = private unnamed_addr constant [22 x i8] c"uint64_t variable add\00", align 1
@.str.138 = private unnamed_addr constant [30 x i8] c"uint64_t variable add hoisted\00", align 1
@.str.139 = private unnamed_addr constant [32 x i8] c"uint64_t multiple variable adds\00", align 1
@.str.140 = private unnamed_addr constant [27 x i8] c"uint64_t variable subtract\00", align 1
@.str.141 = private unnamed_addr constant [37 x i8] c"uint64_t multiple variable subtracts\00", align 1
@.str.142 = private unnamed_addr constant [27 x i8] c"uint64_t variable multiply\00", align 1
@.str.143 = private unnamed_addr constant [38 x i8] c"uint64_t multiple variable multiplies\00", align 1
@.str.144 = private unnamed_addr constant [39 x i8] c"uint64_t multiple variable multiplies2\00", align 1
@.str.145 = private unnamed_addr constant [25 x i8] c"uint64_t variable divide\00", align 1
@.str.146 = private unnamed_addr constant [35 x i8] c"uint64_t multiple variable divides\00", align 1
@.str.147 = private unnamed_addr constant [36 x i8] c"uint64_t multiple variable divides2\00", align 1
@.str.148 = private unnamed_addr constant [33 x i8] c"uint64_t multiple variable mixed\00", align 1
@.str.149 = private unnamed_addr constant [22 x i8] c"uint64_t variable and\00", align 1
@.str.150 = private unnamed_addr constant [31 x i8] c"uint64_t multiple variable and\00", align 1
@.str.151 = private unnamed_addr constant [21 x i8] c"uint64_t variable or\00", align 1
@.str.152 = private unnamed_addr constant [30 x i8] c"uint64_t multiple variable or\00", align 1
@.str.153 = private unnamed_addr constant [22 x i8] c"uint64_t variable xor\00", align 1
@.str.154 = private unnamed_addr constant [31 x i8] c"uint64_t multiple variable xor\00", align 1
@.str.155 = private unnamed_addr constant [19 x i8] c"float variable add\00", align 1
@.str.156 = private unnamed_addr constant [27 x i8] c"float variable add hoisted\00", align 1
@.str.157 = private unnamed_addr constant [29 x i8] c"float multiple variable adds\00", align 1
@.str.158 = private unnamed_addr constant [24 x i8] c"float variable subtract\00", align 1
@.str.159 = private unnamed_addr constant [34 x i8] c"float multiple variable subtracts\00", align 1
@.str.160 = private unnamed_addr constant [24 x i8] c"float variable multiply\00", align 1
@.str.161 = private unnamed_addr constant [35 x i8] c"float multiple variable multiplies\00", align 1
@.str.162 = private unnamed_addr constant [36 x i8] c"float multiple variable multiplies2\00", align 1
@.str.163 = private unnamed_addr constant [22 x i8] c"float variable divide\00", align 1
@.str.164 = private unnamed_addr constant [32 x i8] c"float multiple variable divides\00", align 1
@.str.165 = private unnamed_addr constant [33 x i8] c"float multiple variable divides2\00", align 1
@.str.166 = private unnamed_addr constant [30 x i8] c"float multiple variable mixed\00", align 1
@.str.167 = private unnamed_addr constant [20 x i8] c"double variable add\00", align 1
@.str.168 = private unnamed_addr constant [28 x i8] c"double variable add hoisted\00", align 1
@.str.169 = private unnamed_addr constant [30 x i8] c"double multiple variable adds\00", align 1
@.str.170 = private unnamed_addr constant [25 x i8] c"double variable subtract\00", align 1
@.str.171 = private unnamed_addr constant [35 x i8] c"double multiple variable subtracts\00", align 1
@.str.172 = private unnamed_addr constant [25 x i8] c"double variable multiply\00", align 1
@.str.173 = private unnamed_addr constant [36 x i8] c"double multiple variable multiplies\00", align 1
@.str.174 = private unnamed_addr constant [37 x i8] c"double multiple variable multiplies2\00", align 1
@.str.175 = private unnamed_addr constant [23 x i8] c"double variable divide\00", align 1
@.str.176 = private unnamed_addr constant [33 x i8] c"double multiple variable divides\00", align 1
@.str.177 = private unnamed_addr constant [34 x i8] c"double multiple variable divides2\00", align 1
@.str.178 = private unnamed_addr constant [31 x i8] c"double multiple variable mixed\00", align 1
@.str.179 = private unnamed_addr constant [16 x i8] c"test %i failed\0A\00", align 1

; Function Attrs: noinline uwtable
define void @_Z13record_resultdPKc(double %time, i8* %label) #0 {
entry:
  %time.addr = alloca double, align 8
  %label.addr = alloca i8*, align 8
  store double %time, double* %time.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  %0 = load %struct.one_result*, %struct.one_result** @results, align 8
  %cmp = icmp eq %struct.one_result* %0, null
  br i1 %cmp, label %if.then, label %lor.lhs.false

lor.lhs.false:                                    ; preds = %entry
  %1 = load i32, i32* @current_test, align 4
  %2 = load i32, i32* @allocated_results, align 4
  %cmp1 = icmp sge i32 %1, %2
  br i1 %cmp1, label %if.then, label %if.end5

if.then:                                          ; preds = %lor.lhs.false, %entry
  %3 = load i32, i32* @allocated_results, align 4
  %add = add nsw i32 %3, 10
  store i32 %add, i32* @allocated_results, align 4
  %4 = load %struct.one_result*, %struct.one_result** @results, align 8
  %5 = bitcast %struct.one_result* %4 to i8*
  %6 = load i32, i32* @allocated_results, align 4
  %conv = sext i32 %6 to i64
  %mul = mul i64 %conv, 16
  %call = call i8* @realloc(i8* %5, i64 %mul) #9
  %7 = bitcast i8* %call to %struct.one_result*
  store %struct.one_result* %7, %struct.one_result** @results, align 8
  %8 = load %struct.one_result*, %struct.one_result** @results, align 8
  %cmp2 = icmp eq %struct.one_result* %8, null
  br i1 %cmp2, label %if.then3, label %if.end

if.then3:                                         ; preds = %if.then
  %9 = load i32, i32* @allocated_results, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str, i32 0, i32 0), i32 %9)
  call void @exit(i32 -1) #10
  unreachable

if.end:                                           ; preds = %if.then
  br label %if.end5

if.end5:                                          ; preds = %if.end, %lor.lhs.false
  %10 = load double, double* %time.addr, align 8
  %11 = load %struct.one_result*, %struct.one_result** @results, align 8
  %12 = load i32, i32* @current_test, align 4
  %idxprom = sext i32 %12 to i64
  %arrayidx = getelementptr inbounds %struct.one_result, %struct.one_result* %11, i64 %idxprom
  %time6 = getelementptr inbounds %struct.one_result, %struct.one_result* %arrayidx, i32 0, i32 0
  store double %10, double* %time6, align 8
  %13 = load i8*, i8** %label.addr, align 8
  %14 = load %struct.one_result*, %struct.one_result** @results, align 8
  %15 = load i32, i32* @current_test, align 4
  %idxprom7 = sext i32 %15 to i64
  %arrayidx8 = getelementptr inbounds %struct.one_result, %struct.one_result* %14, i64 %idxprom7
  %label9 = getelementptr inbounds %struct.one_result, %struct.one_result* %arrayidx8, i32 0, i32 1
  store i8* %13, i8** %label9, align 8
  %16 = load i32, i32* @current_test, align 4
  %inc = add nsw i32 %16, 1
  store i32 %inc, i32* @current_test, align 4
  ret void
}

; Function Attrs: nounwind
declare i8* @realloc(i8*, i64) #1

declare i32 @printf(i8*, ...) #2

; Function Attrs: noreturn nounwind
declare void @exit(i32) #3

; Function Attrs: noinline uwtable
define void @_Z9summarizePKciiii(i8* %name, i32 %size, i32 %iterations, i32 %show_gmeans, i32 %show_penalty) #0 {
entry:
  %name.addr = alloca i8*, align 8
  %size.addr = alloca i32, align 4
  %iterations.addr = alloca i32, align 4
  %show_gmeans.addr = alloca i32, align 4
  %show_penalty.addr = alloca i32, align 4
  %i = alloca i32, align 4
  %millions = alloca double, align 8
  %total_absolute_times = alloca double, align 8
  %gmean_ratio = alloca double, align 8
  %longest_label_len = alloca i32, align 4
  %len = alloca i32, align 4
  store i8* %name, i8** %name.addr, align 8
  store i32 %size, i32* %size.addr, align 4
  store i32 %iterations, i32* %iterations.addr, align 4
  store i32 %show_gmeans, i32* %show_gmeans.addr, align 4
  store i32 %show_penalty, i32* %show_penalty.addr, align 4
  %0 = load i32, i32* %size.addr, align 4
  %conv = sitofp i32 %0 to double
  %1 = load i32, i32* %iterations.addr, align 4
  %conv1 = sitofp i32 %1 to double
  %mul = fmul double %conv, %conv1
  %div = fdiv double %mul, 1.000000e+06
  store double %div, double* %millions, align 8
  store double 0.000000e+00, double* %total_absolute_times, align 8
  store double 0.000000e+00, double* %gmean_ratio, align 8
  store i32 12, i32* %longest_label_len, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %2 = load i32, i32* %i, align 4
  %3 = load i32, i32* @current_test, align 4
  %cmp = icmp slt i32 %2, %3
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %4 = load %struct.one_result*, %struct.one_result** @results, align 8
  %5 = load i32, i32* %i, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds %struct.one_result, %struct.one_result* %4, i64 %idxprom
  %label = getelementptr inbounds %struct.one_result, %struct.one_result* %arrayidx, i32 0, i32 1
  %6 = load i8*, i8** %label, align 8
  %call = call i64 @strlen(i8* %6) #11
  %conv2 = trunc i64 %call to i32
  store i32 %conv2, i32* %len, align 4
  %7 = load i32, i32* %len, align 4
  %8 = load i32, i32* %longest_label_len, align 4
  %cmp3 = icmp sgt i32 %7, %8
  br i1 %cmp3, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %9 = load i32, i32* %len, align 4
  store i32 %9, i32* %longest_label_len, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %10 = load i32, i32* %i, align 4
  %inc = add nsw i32 %10, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %11 = load i32, i32* %longest_label_len, align 4
  %sub = sub nsw i32 %11, 12
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([60 x i8], [60 x i8]* @.str.1, i32 0, i32 0), i32 %sub, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2, i32 0, i32 0))
  %12 = load i32, i32* %longest_label_len, align 4
  %call5 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.3, i32 0, i32 0), i32 %12, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2, i32 0, i32 0))
  store i32 0, i32* %i, align 4
  br label %for.cond6

for.cond6:                                        ; preds = %for.inc32, %for.end
  %13 = load i32, i32* %i, align 4
  %14 = load i32, i32* @current_test, align 4
  %cmp7 = icmp slt i32 %13, %14
  br i1 %cmp7, label %for.body8, label %for.end34

for.body8:                                        ; preds = %for.cond6
  %15 = load i32, i32* %i, align 4
  %16 = load i32, i32* %longest_label_len, align 4
  %conv9 = sext i32 %16 to i64
  %17 = load %struct.one_result*, %struct.one_result** @results, align 8
  %18 = load i32, i32* %i, align 4
  %idxprom10 = sext i32 %18 to i64
  %arrayidx11 = getelementptr inbounds %struct.one_result, %struct.one_result* %17, i64 %idxprom10
  %label12 = getelementptr inbounds %struct.one_result, %struct.one_result* %arrayidx11, i32 0, i32 1
  %19 = load i8*, i8** %label12, align 8
  %call13 = call i64 @strlen(i8* %19) #11
  %sub14 = sub i64 %conv9, %call13
  %conv15 = trunc i64 %sub14 to i32
  %20 = load %struct.one_result*, %struct.one_result** @results, align 8
  %21 = load i32, i32* %i, align 4
  %idxprom16 = sext i32 %21 to i64
  %arrayidx17 = getelementptr inbounds %struct.one_result, %struct.one_result* %20, i64 %idxprom16
  %label18 = getelementptr inbounds %struct.one_result, %struct.one_result* %arrayidx17, i32 0, i32 1
  %22 = load i8*, i8** %label18, align 8
  %23 = load %struct.one_result*, %struct.one_result** @results, align 8
  %24 = load i32, i32* %i, align 4
  %idxprom19 = sext i32 %24 to i64
  %arrayidx20 = getelementptr inbounds %struct.one_result, %struct.one_result* %23, i64 %idxprom19
  %time = getelementptr inbounds %struct.one_result, %struct.one_result* %arrayidx20, i32 0, i32 0
  %25 = load double, double* %time, align 8
  %26 = load double, double* %millions, align 8
  %27 = load %struct.one_result*, %struct.one_result** @results, align 8
  %28 = load i32, i32* %i, align 4
  %idxprom21 = sext i32 %28 to i64
  %arrayidx22 = getelementptr inbounds %struct.one_result, %struct.one_result* %27, i64 %idxprom21
  %time23 = getelementptr inbounds %struct.one_result, %struct.one_result* %arrayidx22, i32 0, i32 0
  %29 = load double, double* %time23, align 8
  %div24 = fdiv double %26, %29
  %30 = load %struct.one_result*, %struct.one_result** @results, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom25 = sext i32 %31 to i64
  %arrayidx26 = getelementptr inbounds %struct.one_result, %struct.one_result* %30, i64 %idxprom25
  %time27 = getelementptr inbounds %struct.one_result, %struct.one_result* %arrayidx26, i32 0, i32 0
  %32 = load double, double* %time27, align 8
  %33 = load %struct.one_result*, %struct.one_result** @results, align 8
  %arrayidx28 = getelementptr inbounds %struct.one_result, %struct.one_result* %33, i64 0
  %time29 = getelementptr inbounds %struct.one_result, %struct.one_result* %arrayidx28, i32 0, i32 0
  %34 = load double, double* %time29, align 8
  %div30 = fdiv double %32, %34
  %call31 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([43 x i8], [43 x i8]* @.str.4, i32 0, i32 0), i32 %15, i32 %conv15, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i32 0, i32 0), i8* %22, double %25, double %div24, double %div30)
  br label %for.inc32

for.inc32:                                        ; preds = %for.body8
  %35 = load i32, i32* %i, align 4
  %inc33 = add nsw i32 %35, 1
  store i32 %inc33, i32* %i, align 4
  br label %for.cond6

for.end34:                                        ; preds = %for.cond6
  store i32 0, i32* %i, align 4
  br label %for.cond35

for.cond35:                                       ; preds = %for.inc41, %for.end34
  %36 = load i32, i32* %i, align 4
  %37 = load i32, i32* @current_test, align 4
  %cmp36 = icmp slt i32 %36, %37
  br i1 %cmp36, label %for.body37, label %for.end43

for.body37:                                       ; preds = %for.cond35
  %38 = load %struct.one_result*, %struct.one_result** @results, align 8
  %39 = load i32, i32* %i, align 4
  %idxprom38 = sext i32 %39 to i64
  %arrayidx39 = getelementptr inbounds %struct.one_result, %struct.one_result* %38, i64 %idxprom38
  %time40 = getelementptr inbounds %struct.one_result, %struct.one_result* %arrayidx39, i32 0, i32 0
  %40 = load double, double* %time40, align 8
  %41 = load double, double* %total_absolute_times, align 8
  %add = fadd double %41, %40
  store double %add, double* %total_absolute_times, align 8
  br label %for.inc41

for.inc41:                                        ; preds = %for.body37
  %42 = load i32, i32* %i, align 4
  %inc42 = add nsw i32 %42, 1
  store i32 %inc42, i32* %i, align 4
  br label %for.cond35

for.end43:                                        ; preds = %for.cond35
  %43 = load i8*, i8** %name.addr, align 8
  %44 = load double, double* %total_absolute_times, align 8
  %call44 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.6, i32 0, i32 0), i8* %43, double %44)
  %45 = load i32, i32* @current_test, align 4
  %cmp45 = icmp sgt i32 %45, 1
  br i1 %cmp45, label %land.lhs.true, label %if.end66

land.lhs.true:                                    ; preds = %for.end43
  %46 = load i32, i32* %show_penalty.addr, align 4
  %tobool = icmp ne i32 %46, 0
  br i1 %tobool, label %if.then46, label %if.end66

if.then46:                                        ; preds = %land.lhs.true
  store i32 1, i32* %i, align 4
  br label %for.cond47

for.cond47:                                       ; preds = %for.inc58, %if.then46
  %47 = load i32, i32* %i, align 4
  %48 = load i32, i32* @current_test, align 4
  %cmp48 = icmp slt i32 %47, %48
  br i1 %cmp48, label %for.body49, label %for.end60

for.body49:                                       ; preds = %for.cond47
  %49 = load %struct.one_result*, %struct.one_result** @results, align 8
  %50 = load i32, i32* %i, align 4
  %idxprom50 = sext i32 %50 to i64
  %arrayidx51 = getelementptr inbounds %struct.one_result, %struct.one_result* %49, i64 %idxprom50
  %time52 = getelementptr inbounds %struct.one_result, %struct.one_result* %arrayidx51, i32 0, i32 0
  %51 = load double, double* %time52, align 8
  %52 = load %struct.one_result*, %struct.one_result** @results, align 8
  %arrayidx53 = getelementptr inbounds %struct.one_result, %struct.one_result* %52, i64 0
  %time54 = getelementptr inbounds %struct.one_result, %struct.one_result* %arrayidx53, i32 0, i32 0
  %53 = load double, double* %time54, align 8
  %div55 = fdiv double %51, %53
  %call56 = call double @log(double %div55) #9
  %54 = load double, double* %gmean_ratio, align 8
  %add57 = fadd double %54, %call56
  store double %add57, double* %gmean_ratio, align 8
  br label %for.inc58

for.inc58:                                        ; preds = %for.body49
  %55 = load i32, i32* %i, align 4
  %inc59 = add nsw i32 %55, 1
  store i32 %inc59, i32* %i, align 4
  br label %for.cond47

for.end60:                                        ; preds = %for.cond47
  %56 = load i8*, i8** %name.addr, align 8
  %57 = load double, double* %gmean_ratio, align 8
  %58 = load i32, i32* @current_test, align 4
  %sub61 = sub nsw i32 %58, 1
  %conv62 = sitofp i32 %sub61 to double
  %div63 = fdiv double %57, %conv62
  %call64 = call double @exp(double %div63) #9
  %call65 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.7, i32 0, i32 0), i8* %56, double %call64)
  br label %if.end66

if.end66:                                         ; preds = %for.end60, %land.lhs.true, %for.end43
  store i32 0, i32* @current_test, align 4
  ret void
}

; Function Attrs: nounwind readonly
declare i64 @strlen(i8*) #4

; Function Attrs: nounwind
declare double @log(double) #1

; Function Attrs: nounwind
declare double @exp(double) #1

; Function Attrs: noinline uwtable
define void @_Z17summarize_simplefP8_IO_FILEPKc(%struct._IO_FILE* %output, i8* %name) #0 {
entry:
  %output.addr = alloca %struct._IO_FILE*, align 8
  %name.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %total_absolute_times = alloca double, align 8
  %longest_label_len = alloca i32, align 4
  %len = alloca i32, align 4
  store %struct._IO_FILE* %output, %struct._IO_FILE** %output.addr, align 8
  store i8* %name, i8** %name.addr, align 8
  store double 0.000000e+00, double* %total_absolute_times, align 8
  store i32 12, i32* %longest_label_len, align 4
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @current_test, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end

for.body:                                         ; preds = %for.cond
  %2 = load %struct.one_result*, %struct.one_result** @results, align 8
  %3 = load i32, i32* %i, align 4
  %idxprom = sext i32 %3 to i64
  %arrayidx = getelementptr inbounds %struct.one_result, %struct.one_result* %2, i64 %idxprom
  %label = getelementptr inbounds %struct.one_result, %struct.one_result* %arrayidx, i32 0, i32 1
  %4 = load i8*, i8** %label, align 8
  %call = call i64 @strlen(i8* %4) #11
  %conv = trunc i64 %call to i32
  store i32 %conv, i32* %len, align 4
  %5 = load i32, i32* %len, align 4
  %6 = load i32, i32* %longest_label_len, align 4
  %cmp1 = icmp sgt i32 %5, %6
  br i1 %cmp1, label %if.then, label %if.end

if.then:                                          ; preds = %for.body
  %7 = load i32, i32* %len, align 4
  store i32 %7, i32* %longest_label_len, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %for.body
  br label %for.inc

for.inc:                                          ; preds = %if.end
  %8 = load i32, i32* %i, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %i, align 4
  br label %for.cond

for.end:                                          ; preds = %for.cond
  %9 = load %struct._IO_FILE*, %struct._IO_FILE** %output.addr, align 8
  %10 = load i32, i32* %longest_label_len, align 4
  %sub = sub nsw i32 %10, 12
  %call2 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %9, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.8, i32 0, i32 0), i32 %sub, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2, i32 0, i32 0))
  %11 = load %struct._IO_FILE*, %struct._IO_FILE** %output.addr, align 8
  %12 = load i32, i32* %longest_label_len, align 4
  %call3 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %11, i8* getelementptr inbounds ([18 x i8], [18 x i8]* @.str.9, i32 0, i32 0), i32 %12, i8* getelementptr inbounds ([2 x i8], [2 x i8]* @.str.2, i32 0, i32 0))
  store i32 0, i32* %i, align 4
  br label %for.cond4

for.cond4:                                        ; preds = %for.inc20, %for.end
  %13 = load i32, i32* %i, align 4
  %14 = load i32, i32* @current_test, align 4
  %cmp5 = icmp slt i32 %13, %14
  br i1 %cmp5, label %for.body6, label %for.end22

for.body6:                                        ; preds = %for.cond4
  %15 = load %struct._IO_FILE*, %struct._IO_FILE** %output.addr, align 8
  %16 = load i32, i32* %i, align 4
  %17 = load i32, i32* %longest_label_len, align 4
  %conv7 = sext i32 %17 to i64
  %18 = load %struct.one_result*, %struct.one_result** @results, align 8
  %19 = load i32, i32* %i, align 4
  %idxprom8 = sext i32 %19 to i64
  %arrayidx9 = getelementptr inbounds %struct.one_result, %struct.one_result* %18, i64 %idxprom8
  %label10 = getelementptr inbounds %struct.one_result, %struct.one_result* %arrayidx9, i32 0, i32 1
  %20 = load i8*, i8** %label10, align 8
  %call11 = call i64 @strlen(i8* %20) #11
  %sub12 = sub i64 %conv7, %call11
  %conv13 = trunc i64 %sub12 to i32
  %21 = load %struct.one_result*, %struct.one_result** @results, align 8
  %22 = load i32, i32* %i, align 4
  %idxprom14 = sext i32 %22 to i64
  %arrayidx15 = getelementptr inbounds %struct.one_result, %struct.one_result* %21, i64 %idxprom14
  %label16 = getelementptr inbounds %struct.one_result, %struct.one_result* %arrayidx15, i32 0, i32 1
  %23 = load i8*, i8** %label16, align 8
  %24 = load %struct.one_result*, %struct.one_result** @results, align 8
  %25 = load i32, i32* %i, align 4
  %idxprom17 = sext i32 %25 to i64
  %arrayidx18 = getelementptr inbounds %struct.one_result, %struct.one_result* %24, i64 %idxprom17
  %time = getelementptr inbounds %struct.one_result, %struct.one_result* %arrayidx18, i32 0, i32 0
  %26 = load double, double* %time, align 8
  %call19 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %15, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.10, i32 0, i32 0), i32 %16, i32 %conv13, i8* getelementptr inbounds ([1 x i8], [1 x i8]* @.str.5, i32 0, i32 0), i8* %23, double %26)
  br label %for.inc20

for.inc20:                                        ; preds = %for.body6
  %27 = load i32, i32* %i, align 4
  %inc21 = add nsw i32 %27, 1
  store i32 %inc21, i32* %i, align 4
  br label %for.cond4

for.end22:                                        ; preds = %for.cond4
  store i32 0, i32* %i, align 4
  br label %for.cond23

for.cond23:                                       ; preds = %for.inc29, %for.end22
  %28 = load i32, i32* %i, align 4
  %29 = load i32, i32* @current_test, align 4
  %cmp24 = icmp slt i32 %28, %29
  br i1 %cmp24, label %for.body25, label %for.end31

for.body25:                                       ; preds = %for.cond23
  %30 = load %struct.one_result*, %struct.one_result** @results, align 8
  %31 = load i32, i32* %i, align 4
  %idxprom26 = sext i32 %31 to i64
  %arrayidx27 = getelementptr inbounds %struct.one_result, %struct.one_result* %30, i64 %idxprom26
  %time28 = getelementptr inbounds %struct.one_result, %struct.one_result* %arrayidx27, i32 0, i32 0
  %32 = load double, double* %time28, align 8
  %33 = load double, double* %total_absolute_times, align 8
  %add = fadd double %33, %32
  store double %add, double* %total_absolute_times, align 8
  br label %for.inc29

for.inc29:                                        ; preds = %for.body25
  %34 = load i32, i32* %i, align 4
  %inc30 = add nsw i32 %34, 1
  store i32 %inc30, i32* %i, align 4
  br label %for.cond23

for.end31:                                        ; preds = %for.cond23
  %35 = load %struct._IO_FILE*, %struct._IO_FILE** %output.addr, align 8
  %36 = load i8*, i8** %name.addr, align 8
  %37 = load double, double* %total_absolute_times, align 8
  %call32 = call i32 (%struct._IO_FILE*, i8*, ...) @fprintf(%struct._IO_FILE* %35, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.6, i32 0, i32 0), i8* %36, double %37)
  store i32 0, i32* @current_test, align 4
  ret void
}

declare i32 @fprintf(%struct._IO_FILE*, i8*, ...) #2

; Function Attrs: noinline nounwind uwtable
define void @_Z11start_timerv() #5 {
entry:
  %call = call i64 @clock() #9
  store i64 %call, i64* @start_time, align 8
  ret void
}

; Function Attrs: nounwind
declare i64 @clock() #1

; Function Attrs: noinline nounwind uwtable
define double @_Z5timerv() #5 {
entry:
  %call = call i64 @clock() #9
  store i64 %call, i64* @end_time, align 8
  %0 = load i64, i64* @end_time, align 8
  %1 = load i64, i64* @start_time, align 8
  %sub = sub nsw i64 %0, %1
  %conv = sitofp i64 %sub to double
  %div = fdiv double %conv, 1.000000e+06
  ret double %div
}

; Function Attrs: noinline norecurse uwtable
define i32 @main(i32 %argc, i8** %argv) #6 {
entry:
  %retval = alloca i32, align 4
  %argc.addr = alloca i32, align 4
  %argv.addr = alloca i8**, align 8
  %temp = alloca double, align 8
  %var1int8_1 = alloca i8, align 1
  %var1int8_2 = alloca i8, align 1
  %var1int8_3 = alloca i8, align 1
  %var1int8_4 = alloca i8, align 1
  %var1uint8_1 = alloca i8, align 1
  %var1uint8_2 = alloca i8, align 1
  %var1uint8_3 = alloca i8, align 1
  %var1uint8_4 = alloca i8, align 1
  %var1int16_1 = alloca i16, align 2
  %var1int16_2 = alloca i16, align 2
  %var1int16_3 = alloca i16, align 2
  %var1int16_4 = alloca i16, align 2
  %var1uint16_1 = alloca i16, align 2
  %var1uint16_2 = alloca i16, align 2
  %var1uint16_3 = alloca i16, align 2
  %var1uint16_4 = alloca i16, align 2
  %var1int32_1 = alloca i32, align 4
  %var1int32_2 = alloca i32, align 4
  %var1int32_3 = alloca i32, align 4
  %var1int32_4 = alloca i32, align 4
  %var1uint32_1 = alloca i32, align 4
  %var1uint32_2 = alloca i32, align 4
  %var1uint32_3 = alloca i32, align 4
  %var1uint32_4 = alloca i32, align 4
  %var1int64_1 = alloca i64, align 8
  %var1int64_2 = alloca i64, align 8
  %var1int64_3 = alloca i64, align 8
  %var1int64_4 = alloca i64, align 8
  %var1uint64_1 = alloca i64, align 8
  %var1uint64_2 = alloca i64, align 8
  %var1uint64_3 = alloca i64, align 8
  %var1uint64_4 = alloca i64, align 8
  %var1Float_1 = alloca float, align 4
  %var1Float_2 = alloca float, align 4
  %var1Float_3 = alloca float, align 4
  %var1Float_4 = alloca float, align 4
  %var1Double_1 = alloca double, align 8
  %var1Double_2 = alloca double, align 8
  %var1Double_3 = alloca double, align 8
  %var1Double_4 = alloca double, align 8
  store i32 0, i32* %retval, align 4
  store i32 %argc, i32* %argc.addr, align 4
  store i8** %argv, i8*** %argv.addr, align 8
  store double 1.000000e+00, double* %temp, align 8
  %0 = load i32, i32* %argc.addr, align 4
  %cmp = icmp sgt i32 %0, 1
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %1 = load i8**, i8*** %argv.addr, align 8
  %arrayidx = getelementptr inbounds i8*, i8** %1, i64 1
  %2 = load i8*, i8** %arrayidx, align 8
  %call = call i32 @atoi(i8* %2) #11
  store i32 %call, i32* @iterations, align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %3 = load i32, i32* %argc.addr, align 4
  %cmp1 = icmp sgt i32 %3, 2
  br i1 %cmp1, label %if.then2, label %if.end5

if.then2:                                         ; preds = %if.end
  %4 = load i8**, i8*** %argv.addr, align 8
  %arrayidx3 = getelementptr inbounds i8*, i8** %4, i64 2
  %5 = load i8*, i8** %arrayidx3, align 8
  %call4 = call double @atof(i8* %5) #11
  store double %call4, double* @init_value, align 8
  br label %if.end5

if.end5:                                          ; preds = %if.then2, %if.end
  %6 = load i32, i32* %argc.addr, align 4
  %cmp6 = icmp sgt i32 %6, 3
  br i1 %cmp6, label %if.then7, label %if.end10

if.then7:                                         ; preds = %if.end5
  %7 = load i8**, i8*** %argv.addr, align 8
  %arrayidx8 = getelementptr inbounds i8*, i8** %7, i64 3
  %8 = load i8*, i8** %arrayidx8, align 8
  %call9 = call double @atof(i8* %8) #11
  store double %call9, double* %temp, align 8
  br label %if.end10

if.end10:                                         ; preds = %if.then7, %if.end5
  %9 = load double, double* @init_value, align 8
  %conv = fptosi double %9 to i8
  call void @_Z4fillIPaaEvT_S1_T0_(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i8* getelementptr inbounds (i8, i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i64 8000), i8 signext %conv)
  %10 = load double, double* %temp, align 8
  %conv11 = fptosi double %10 to i8
  store i8 %conv11, i8* %var1int8_1, align 1
  %11 = load i8, i8* %var1int8_1, align 1
  %conv12 = sext i8 %11 to i32
  %mul = mul nsw i32 %conv12, 2
  %conv13 = trunc i32 %mul to i8
  store i8 %conv13, i8* %var1int8_2, align 1
  %12 = load i8, i8* %var1int8_1, align 1
  %conv14 = sext i8 %12 to i32
  %add = add nsw i32 %conv14, 2
  %conv15 = trunc i32 %add to i8
  store i8 %conv15, i8* %var1int8_3, align 1
  %13 = load i8, i8* %var1int8_1, align 1
  %conv16 = sext i8 %13 to i32
  %14 = load i8, i8* %var1int8_2, align 1
  %conv17 = sext i8 %14 to i32
  %15 = load i8, i8* %var1int8_3, align 1
  %conv18 = sext i8 %15 to i32
  %div = sdiv i32 %conv17, %conv18
  %add19 = add nsw i32 %conv16, %div
  %conv20 = trunc i32 %add19 to i8
  store i8 %conv20, i8* %var1int8_4, align 1
  %16 = load i8, i8* %var1int8_1, align 1
  call void @_Z14test_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %16, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.11, i32 0, i32 0))
  %17 = load i8, i8* %var1int8_1, align 1
  call void @_Z22test_hoisted_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %17, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.12, i32 0, i32 0))
  %18 = load i8, i8* %var1int8_1, align 1
  %19 = load i8, i8* %var1int8_2, align 1
  %20 = load i8, i8* %var1int8_3, align 1
  %21 = load i8, i8* %var1int8_4, align 1
  call void @_Z14test_variable4Ia28custom_add_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %18, i8 signext %19, i8 signext %20, i8 signext %21, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.13, i32 0, i32 0))
  %22 = load i8, i8* %var1int8_1, align 1
  call void @_Z14test_variable1Ia19custom_sub_variableIaEEvPT_iS2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %22, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.14, i32 0, i32 0))
  %23 = load i8, i8* %var1int8_1, align 1
  %24 = load i8, i8* %var1int8_2, align 1
  %25 = load i8, i8* %var1int8_3, align 1
  %26 = load i8, i8* %var1int8_4, align 1
  call void @_Z14test_variable4Ia28custom_sub_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %23, i8 signext %24, i8 signext %25, i8 signext %26, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.15, i32 0, i32 0))
  %27 = load i8, i8* %var1int8_1, align 1
  call void @_Z14test_variable1Ia24custom_multiply_variableIaEEvPT_iS2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %27, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.16, i32 0, i32 0))
  %28 = load i8, i8* %var1int8_1, align 1
  %29 = load i8, i8* %var1int8_2, align 1
  %30 = load i8, i8* %var1int8_3, align 1
  %31 = load i8, i8* %var1int8_4, align 1
  call void @_Z14test_variable4Ia33custom_multiply_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %28, i8 signext %29, i8 signext %30, i8 signext %31, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.17, i32 0, i32 0))
  %32 = load i8, i8* %var1int8_1, align 1
  %33 = load i8, i8* %var1int8_2, align 1
  %34 = load i8, i8* %var1int8_3, align 1
  %35 = load i8, i8* %var1int8_4, align 1
  call void @_Z14test_variable4Ia34custom_multiply_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %32, i8 signext %33, i8 signext %34, i8 signext %35, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.18, i32 0, i32 0))
  %36 = load i8, i8* %var1int8_1, align 1
  call void @_Z14test_variable1Ia22custom_divide_variableIaEEvPT_iS2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %36, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.19, i32 0, i32 0))
  %37 = load i8, i8* %var1int8_1, align 1
  %38 = load i8, i8* %var1int8_2, align 1
  %39 = load i8, i8* %var1int8_3, align 1
  %40 = load i8, i8* %var1int8_4, align 1
  call void @_Z14test_variable4Ia31custom_divide_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %37, i8 signext %38, i8 signext %39, i8 signext %40, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.20, i32 0, i32 0))
  %41 = load i8, i8* %var1int8_1, align 1
  %42 = load i8, i8* %var1int8_2, align 1
  %43 = load i8, i8* %var1int8_3, align 1
  %44 = load i8, i8* %var1int8_4, align 1
  call void @_Z14test_variable4Ia32custom_divide_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %41, i8 signext %42, i8 signext %43, i8 signext %44, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.21, i32 0, i32 0))
  %45 = load i8, i8* %var1int8_1, align 1
  %46 = load i8, i8* %var1int8_2, align 1
  %47 = load i8, i8* %var1int8_3, align 1
  %48 = load i8, i8* %var1int8_4, align 1
  call void @_Z14test_variable4Ia30custom_mixed_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %45, i8 signext %46, i8 signext %47, i8 signext %48, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.22, i32 0, i32 0))
  %49 = load i8, i8* %var1int8_1, align 1
  call void @_Z14test_variable1Ia19custom_variable_andIaEEvPT_iS2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %49, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.23, i32 0, i32 0))
  %50 = load i8, i8* %var1int8_1, align 1
  %51 = load i8, i8* %var1int8_2, align 1
  %52 = load i8, i8* %var1int8_3, align 1
  %53 = load i8, i8* %var1int8_4, align 1
  call void @_Z14test_variable4Ia28custom_multiple_variable_andIaEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %50, i8 signext %51, i8 signext %52, i8 signext %53, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.24, i32 0, i32 0))
  %54 = load i8, i8* %var1int8_1, align 1
  call void @_Z14test_variable1Ia18custom_variable_orIaEEvPT_iS2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %54, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.25, i32 0, i32 0))
  %55 = load i8, i8* %var1int8_1, align 1
  %56 = load i8, i8* %var1int8_2, align 1
  %57 = load i8, i8* %var1int8_3, align 1
  %58 = load i8, i8* %var1int8_4, align 1
  call void @_Z14test_variable4Ia27custom_multiple_variable_orIaEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %55, i8 signext %56, i8 signext %57, i8 signext %58, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.26, i32 0, i32 0))
  %59 = load i8, i8* %var1int8_1, align 1
  call void @_Z14test_variable1Ia19custom_variable_xorIaEEvPT_iS2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %59, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.27, i32 0, i32 0))
  %60 = load i8, i8* %var1int8_1, align 1
  %61 = load i8, i8* %var1int8_2, align 1
  %62 = load i8, i8* %var1int8_3, align 1
  %63 = load i8, i8* %var1int8_4, align 1
  call void @_Z14test_variable4Ia28custom_multiple_variable_xorIaEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8, i32 0, i32 0), i32 8000, i8 signext %60, i8 signext %61, i8 signext %62, i8 signext %63, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.28, i32 0, i32 0))
  %64 = load double, double* @init_value, align 8
  %conv21 = fptoui double %64 to i8
  call void @_Z4fillIPhhEvT_S1_T0_(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i8* getelementptr inbounds (i8, i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i64 8000), i8 zeroext %conv21)
  %65 = load double, double* %temp, align 8
  %conv22 = fptoui double %65 to i8
  store i8 %conv22, i8* %var1uint8_1, align 1
  %66 = load i8, i8* %var1uint8_1, align 1
  %conv23 = zext i8 %66 to i32
  %mul24 = mul nsw i32 %conv23, 2
  %conv25 = trunc i32 %mul24 to i8
  store i8 %conv25, i8* %var1uint8_2, align 1
  %67 = load i8, i8* %var1uint8_1, align 1
  %conv26 = zext i8 %67 to i32
  %add27 = add nsw i32 %conv26, 2
  %conv28 = trunc i32 %add27 to i8
  store i8 %conv28, i8* %var1uint8_3, align 1
  %68 = load i8, i8* %var1uint8_1, align 1
  %conv29 = zext i8 %68 to i32
  %69 = load i8, i8* %var1uint8_2, align 1
  %conv30 = zext i8 %69 to i32
  %70 = load i8, i8* %var1uint8_3, align 1
  %conv31 = zext i8 %70 to i32
  %div32 = sdiv i32 %conv30, %conv31
  %add33 = add nsw i32 %conv29, %div32
  %conv34 = trunc i32 %add33 to i8
  store i8 %conv34, i8* %var1uint8_4, align 1
  %71 = load i8, i8* %var1uint8_1, align 1
  call void @_Z14test_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %71, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.29, i32 0, i32 0))
  %72 = load i8, i8* %var1uint8_1, align 1
  call void @_Z22test_hoisted_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %72, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.30, i32 0, i32 0))
  %73 = load i8, i8* %var1uint8_1, align 1
  %74 = load i8, i8* %var1uint8_2, align 1
  %75 = load i8, i8* %var1uint8_3, align 1
  %76 = load i8, i8* %var1uint8_4, align 1
  call void @_Z14test_variable4Ih28custom_add_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %73, i8 zeroext %74, i8 zeroext %75, i8 zeroext %76, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.31, i32 0, i32 0))
  %77 = load i8, i8* %var1uint8_1, align 1
  call void @_Z14test_variable1Ih19custom_sub_variableIhEEvPT_iS2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %77, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.32, i32 0, i32 0))
  %78 = load i8, i8* %var1uint8_1, align 1
  %79 = load i8, i8* %var1uint8_2, align 1
  %80 = load i8, i8* %var1uint8_3, align 1
  %81 = load i8, i8* %var1uint8_4, align 1
  call void @_Z14test_variable4Ih28custom_sub_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %78, i8 zeroext %79, i8 zeroext %80, i8 zeroext %81, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.33, i32 0, i32 0))
  %82 = load i8, i8* %var1uint8_1, align 1
  call void @_Z14test_variable1Ih24custom_multiply_variableIhEEvPT_iS2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %82, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.34, i32 0, i32 0))
  %83 = load i8, i8* %var1uint8_1, align 1
  %84 = load i8, i8* %var1uint8_2, align 1
  %85 = load i8, i8* %var1uint8_3, align 1
  %86 = load i8, i8* %var1uint8_4, align 1
  call void @_Z14test_variable4Ih33custom_multiply_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %83, i8 zeroext %84, i8 zeroext %85, i8 zeroext %86, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.35, i32 0, i32 0))
  %87 = load i8, i8* %var1uint8_1, align 1
  %88 = load i8, i8* %var1uint8_2, align 1
  %89 = load i8, i8* %var1uint8_3, align 1
  %90 = load i8, i8* %var1uint8_4, align 1
  call void @_Z14test_variable4Ih34custom_multiply_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %87, i8 zeroext %88, i8 zeroext %89, i8 zeroext %90, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.36, i32 0, i32 0))
  %91 = load i8, i8* %var1uint8_1, align 1
  call void @_Z14test_variable1Ih22custom_divide_variableIhEEvPT_iS2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %91, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.37, i32 0, i32 0))
  %92 = load i8, i8* %var1uint8_1, align 1
  %93 = load i8, i8* %var1uint8_2, align 1
  %94 = load i8, i8* %var1uint8_3, align 1
  %95 = load i8, i8* %var1uint8_4, align 1
  call void @_Z14test_variable4Ih31custom_divide_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %92, i8 zeroext %93, i8 zeroext %94, i8 zeroext %95, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.38, i32 0, i32 0))
  %96 = load i8, i8* %var1uint8_1, align 1
  %97 = load i8, i8* %var1uint8_2, align 1
  %98 = load i8, i8* %var1uint8_3, align 1
  %99 = load i8, i8* %var1uint8_4, align 1
  call void @_Z14test_variable4Ih32custom_divide_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %96, i8 zeroext %97, i8 zeroext %98, i8 zeroext %99, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.39, i32 0, i32 0))
  %100 = load i8, i8* %var1uint8_1, align 1
  %101 = load i8, i8* %var1uint8_2, align 1
  %102 = load i8, i8* %var1uint8_3, align 1
  %103 = load i8, i8* %var1uint8_4, align 1
  call void @_Z14test_variable4Ih30custom_mixed_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %100, i8 zeroext %101, i8 zeroext %102, i8 zeroext %103, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.40, i32 0, i32 0))
  %104 = load i8, i8* %var1uint8_1, align 1
  call void @_Z14test_variable1Ih19custom_variable_andIhEEvPT_iS2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %104, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.41, i32 0, i32 0))
  %105 = load i8, i8* %var1uint8_1, align 1
  %106 = load i8, i8* %var1uint8_2, align 1
  %107 = load i8, i8* %var1uint8_3, align 1
  %108 = load i8, i8* %var1uint8_4, align 1
  call void @_Z14test_variable4Ih28custom_multiple_variable_andIhEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %105, i8 zeroext %106, i8 zeroext %107, i8 zeroext %108, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.42, i32 0, i32 0))
  %109 = load i8, i8* %var1uint8_1, align 1
  call void @_Z14test_variable1Ih18custom_variable_orIhEEvPT_iS2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %109, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.43, i32 0, i32 0))
  %110 = load i8, i8* %var1uint8_1, align 1
  %111 = load i8, i8* %var1uint8_2, align 1
  %112 = load i8, i8* %var1uint8_3, align 1
  %113 = load i8, i8* %var1uint8_4, align 1
  call void @_Z14test_variable4Ih27custom_multiple_variable_orIhEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %110, i8 zeroext %111, i8 zeroext %112, i8 zeroext %113, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.44, i32 0, i32 0))
  %114 = load i8, i8* %var1uint8_1, align 1
  call void @_Z14test_variable1Ih19custom_variable_xorIhEEvPT_iS2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %114, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.45, i32 0, i32 0))
  %115 = load i8, i8* %var1uint8_1, align 1
  %116 = load i8, i8* %var1uint8_2, align 1
  %117 = load i8, i8* %var1uint8_3, align 1
  %118 = load i8, i8* %var1uint8_4, align 1
  call void @_Z14test_variable4Ih28custom_multiple_variable_xorIhEEvPT_iS2_S2_S2_S2_PKc(i8* getelementptr inbounds ([8000 x i8], [8000 x i8]* @data8unsigned, i32 0, i32 0), i32 8000, i8 zeroext %115, i8 zeroext %116, i8 zeroext %117, i8 zeroext %118, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.46, i32 0, i32 0))
  %119 = load double, double* @init_value, align 8
  %conv35 = fptosi double %119 to i16
  call void @_Z4fillIPssEvT_S1_T0_(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i16* getelementptr inbounds (i16, i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i64 8000), i16 signext %conv35)
  %120 = load double, double* %temp, align 8
  %conv36 = fptosi double %120 to i16
  store i16 %conv36, i16* %var1int16_1, align 2
  %121 = load i16, i16* %var1int16_1, align 2
  %conv37 = sext i16 %121 to i32
  %mul38 = mul nsw i32 %conv37, 2
  %conv39 = trunc i32 %mul38 to i16
  store i16 %conv39, i16* %var1int16_2, align 2
  %122 = load i16, i16* %var1int16_1, align 2
  %conv40 = sext i16 %122 to i32
  %add41 = add nsw i32 %conv40, 2
  %conv42 = trunc i32 %add41 to i16
  store i16 %conv42, i16* %var1int16_3, align 2
  %123 = load i16, i16* %var1int16_1, align 2
  %conv43 = sext i16 %123 to i32
  %124 = load i16, i16* %var1int16_2, align 2
  %conv44 = sext i16 %124 to i32
  %125 = load i16, i16* %var1int16_3, align 2
  %conv45 = sext i16 %125 to i32
  %div46 = sdiv i32 %conv44, %conv45
  %add47 = add nsw i32 %conv43, %div46
  %conv48 = trunc i32 %add47 to i16
  store i16 %conv48, i16* %var1int16_4, align 2
  %126 = load i16, i16* %var1int16_1, align 2
  call void @_Z14test_variable1Is19custom_add_variableIsEEvPT_iS2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %126, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.47, i32 0, i32 0))
  %127 = load i16, i16* %var1int16_1, align 2
  call void @_Z22test_hoisted_variable1Is19custom_add_variableIsEEvPT_iS2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %127, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.48, i32 0, i32 0))
  %128 = load i16, i16* %var1int16_1, align 2
  %129 = load i16, i16* %var1int16_2, align 2
  %130 = load i16, i16* %var1int16_3, align 2
  %131 = load i16, i16* %var1int16_4, align 2
  call void @_Z14test_variable4Is28custom_add_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %128, i16 signext %129, i16 signext %130, i16 signext %131, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.49, i32 0, i32 0))
  %132 = load i16, i16* %var1int16_1, align 2
  call void @_Z14test_variable1Is19custom_sub_variableIsEEvPT_iS2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %132, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.50, i32 0, i32 0))
  %133 = load i16, i16* %var1int16_1, align 2
  %134 = load i16, i16* %var1int16_2, align 2
  %135 = load i16, i16* %var1int16_3, align 2
  %136 = load i16, i16* %var1int16_4, align 2
  call void @_Z14test_variable4Is28custom_sub_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %133, i16 signext %134, i16 signext %135, i16 signext %136, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.51, i32 0, i32 0))
  %137 = load i16, i16* %var1int16_1, align 2
  call void @_Z14test_variable1Is24custom_multiply_variableIsEEvPT_iS2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %137, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.52, i32 0, i32 0))
  %138 = load i16, i16* %var1int16_1, align 2
  %139 = load i16, i16* %var1int16_2, align 2
  %140 = load i16, i16* %var1int16_3, align 2
  %141 = load i16, i16* %var1int16_4, align 2
  call void @_Z14test_variable4Is33custom_multiply_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %138, i16 signext %139, i16 signext %140, i16 signext %141, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.53, i32 0, i32 0))
  %142 = load i16, i16* %var1int16_1, align 2
  %143 = load i16, i16* %var1int16_2, align 2
  %144 = load i16, i16* %var1int16_3, align 2
  %145 = load i16, i16* %var1int16_4, align 2
  call void @_Z14test_variable4Is34custom_multiply_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %142, i16 signext %143, i16 signext %144, i16 signext %145, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.54, i32 0, i32 0))
  %146 = load i16, i16* %var1int16_1, align 2
  call void @_Z14test_variable1Is22custom_divide_variableIsEEvPT_iS2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %146, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.55, i32 0, i32 0))
  %147 = load i16, i16* %var1int16_1, align 2
  %148 = load i16, i16* %var1int16_2, align 2
  %149 = load i16, i16* %var1int16_3, align 2
  %150 = load i16, i16* %var1int16_4, align 2
  call void @_Z14test_variable4Is31custom_divide_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %147, i16 signext %148, i16 signext %149, i16 signext %150, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.56, i32 0, i32 0))
  %151 = load i16, i16* %var1int16_1, align 2
  %152 = load i16, i16* %var1int16_2, align 2
  %153 = load i16, i16* %var1int16_3, align 2
  %154 = load i16, i16* %var1int16_4, align 2
  call void @_Z14test_variable4Is32custom_divide_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %151, i16 signext %152, i16 signext %153, i16 signext %154, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.57, i32 0, i32 0))
  %155 = load i16, i16* %var1int16_1, align 2
  %156 = load i16, i16* %var1int16_2, align 2
  %157 = load i16, i16* %var1int16_3, align 2
  %158 = load i16, i16* %var1int16_4, align 2
  call void @_Z14test_variable4Is30custom_mixed_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %155, i16 signext %156, i16 signext %157, i16 signext %158, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.58, i32 0, i32 0))
  %159 = load i16, i16* %var1int16_1, align 2
  call void @_Z14test_variable1Is19custom_variable_andIsEEvPT_iS2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %159, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.59, i32 0, i32 0))
  %160 = load i16, i16* %var1int16_1, align 2
  %161 = load i16, i16* %var1int16_2, align 2
  %162 = load i16, i16* %var1int16_3, align 2
  %163 = load i16, i16* %var1int16_4, align 2
  call void @_Z14test_variable4Is28custom_multiple_variable_andIsEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %160, i16 signext %161, i16 signext %162, i16 signext %163, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.60, i32 0, i32 0))
  %164 = load i16, i16* %var1int16_1, align 2
  call void @_Z14test_variable1Is18custom_variable_orIsEEvPT_iS2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %164, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.61, i32 0, i32 0))
  %165 = load i16, i16* %var1int16_1, align 2
  %166 = load i16, i16* %var1int16_2, align 2
  %167 = load i16, i16* %var1int16_3, align 2
  %168 = load i16, i16* %var1int16_4, align 2
  call void @_Z14test_variable4Is27custom_multiple_variable_orIsEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %165, i16 signext %166, i16 signext %167, i16 signext %168, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.62, i32 0, i32 0))
  %169 = load i16, i16* %var1int16_1, align 2
  call void @_Z14test_variable1Is19custom_variable_xorIsEEvPT_iS2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %169, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.63, i32 0, i32 0))
  %170 = load i16, i16* %var1int16_1, align 2
  %171 = load i16, i16* %var1int16_2, align 2
  %172 = load i16, i16* %var1int16_3, align 2
  %173 = load i16, i16* %var1int16_4, align 2
  call void @_Z14test_variable4Is28custom_multiple_variable_xorIsEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16, i32 0, i32 0), i32 8000, i16 signext %170, i16 signext %171, i16 signext %172, i16 signext %173, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.64, i32 0, i32 0))
  %174 = load double, double* @init_value, align 8
  %conv49 = fptoui double %174 to i16
  call void @_Z4fillIPttEvT_S1_T0_(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i16* getelementptr inbounds (i16, i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i64 8000), i16 zeroext %conv49)
  %175 = load double, double* %temp, align 8
  %conv50 = fptoui double %175 to i16
  store i16 %conv50, i16* %var1uint16_1, align 2
  %176 = load i16, i16* %var1uint16_1, align 2
  %conv51 = zext i16 %176 to i32
  %mul52 = mul nsw i32 %conv51, 2
  %conv53 = trunc i32 %mul52 to i16
  store i16 %conv53, i16* %var1uint16_2, align 2
  %177 = load i16, i16* %var1uint16_1, align 2
  %conv54 = zext i16 %177 to i32
  %add55 = add nsw i32 %conv54, 2
  %conv56 = trunc i32 %add55 to i16
  store i16 %conv56, i16* %var1uint16_3, align 2
  %178 = load i16, i16* %var1uint16_1, align 2
  %conv57 = zext i16 %178 to i32
  %179 = load i16, i16* %var1uint16_2, align 2
  %conv58 = zext i16 %179 to i32
  %180 = load i16, i16* %var1uint16_3, align 2
  %conv59 = zext i16 %180 to i32
  %div60 = sdiv i32 %conv58, %conv59
  %add61 = add nsw i32 %conv57, %div60
  %conv62 = trunc i32 %add61 to i16
  store i16 %conv62, i16* %var1uint16_4, align 2
  %181 = load i16, i16* %var1uint16_1, align 2
  call void @_Z14test_variable1It19custom_add_variableItEEvPT_iS2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %181, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.65, i32 0, i32 0))
  %182 = load i16, i16* %var1uint16_1, align 2
  call void @_Z22test_hoisted_variable1It19custom_add_variableItEEvPT_iS2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %182, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.66, i32 0, i32 0))
  %183 = load i16, i16* %var1uint16_1, align 2
  %184 = load i16, i16* %var1uint16_2, align 2
  %185 = load i16, i16* %var1uint16_3, align 2
  %186 = load i16, i16* %var1uint16_4, align 2
  call void @_Z14test_variable4It28custom_add_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %183, i16 zeroext %184, i16 zeroext %185, i16 zeroext %186, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.67, i32 0, i32 0))
  %187 = load i16, i16* %var1uint16_1, align 2
  call void @_Z14test_variable1It19custom_sub_variableItEEvPT_iS2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %187, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.68, i32 0, i32 0))
  %188 = load i16, i16* %var1uint16_1, align 2
  %189 = load i16, i16* %var1uint16_2, align 2
  %190 = load i16, i16* %var1uint16_3, align 2
  %191 = load i16, i16* %var1uint16_4, align 2
  call void @_Z14test_variable4It28custom_sub_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %188, i16 zeroext %189, i16 zeroext %190, i16 zeroext %191, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.69, i32 0, i32 0))
  %192 = load i16, i16* %var1uint16_1, align 2
  call void @_Z14test_variable1It24custom_multiply_variableItEEvPT_iS2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %192, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.70, i32 0, i32 0))
  %193 = load i16, i16* %var1uint16_1, align 2
  %194 = load i16, i16* %var1uint16_2, align 2
  %195 = load i16, i16* %var1uint16_3, align 2
  %196 = load i16, i16* %var1uint16_4, align 2
  call void @_Z14test_variable4It33custom_multiply_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %193, i16 zeroext %194, i16 zeroext %195, i16 zeroext %196, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.71, i32 0, i32 0))
  %197 = load i16, i16* %var1uint16_1, align 2
  %198 = load i16, i16* %var1uint16_2, align 2
  %199 = load i16, i16* %var1uint16_3, align 2
  %200 = load i16, i16* %var1uint16_4, align 2
  call void @_Z14test_variable4It34custom_multiply_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %197, i16 zeroext %198, i16 zeroext %199, i16 zeroext %200, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.72, i32 0, i32 0))
  %201 = load i16, i16* %var1uint16_1, align 2
  call void @_Z14test_variable1It22custom_divide_variableItEEvPT_iS2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %201, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.73, i32 0, i32 0))
  %202 = load i16, i16* %var1uint16_1, align 2
  %203 = load i16, i16* %var1uint16_2, align 2
  %204 = load i16, i16* %var1uint16_3, align 2
  %205 = load i16, i16* %var1uint16_4, align 2
  call void @_Z14test_variable4It31custom_divide_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %202, i16 zeroext %203, i16 zeroext %204, i16 zeroext %205, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.74, i32 0, i32 0))
  %206 = load i16, i16* %var1uint16_1, align 2
  %207 = load i16, i16* %var1uint16_2, align 2
  %208 = load i16, i16* %var1uint16_3, align 2
  %209 = load i16, i16* %var1uint16_4, align 2
  call void @_Z14test_variable4It32custom_divide_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %206, i16 zeroext %207, i16 zeroext %208, i16 zeroext %209, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.75, i32 0, i32 0))
  %210 = load i16, i16* %var1uint16_1, align 2
  %211 = load i16, i16* %var1uint16_2, align 2
  %212 = load i16, i16* %var1uint16_3, align 2
  %213 = load i16, i16* %var1uint16_4, align 2
  call void @_Z14test_variable4It30custom_mixed_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %210, i16 zeroext %211, i16 zeroext %212, i16 zeroext %213, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.76, i32 0, i32 0))
  %214 = load i16, i16* %var1uint16_1, align 2
  call void @_Z14test_variable1It19custom_variable_andItEEvPT_iS2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %214, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.77, i32 0, i32 0))
  %215 = load i16, i16* %var1uint16_1, align 2
  %216 = load i16, i16* %var1uint16_2, align 2
  %217 = load i16, i16* %var1uint16_3, align 2
  %218 = load i16, i16* %var1uint16_4, align 2
  call void @_Z14test_variable4It28custom_multiple_variable_andItEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %215, i16 zeroext %216, i16 zeroext %217, i16 zeroext %218, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.78, i32 0, i32 0))
  %219 = load i16, i16* %var1uint16_1, align 2
  call void @_Z14test_variable1It18custom_variable_orItEEvPT_iS2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %219, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.79, i32 0, i32 0))
  %220 = load i16, i16* %var1uint16_1, align 2
  %221 = load i16, i16* %var1uint16_2, align 2
  %222 = load i16, i16* %var1uint16_3, align 2
  %223 = load i16, i16* %var1uint16_4, align 2
  call void @_Z14test_variable4It27custom_multiple_variable_orItEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %220, i16 zeroext %221, i16 zeroext %222, i16 zeroext %223, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.80, i32 0, i32 0))
  %224 = load i16, i16* %var1uint16_1, align 2
  call void @_Z14test_variable1It19custom_variable_xorItEEvPT_iS2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %224, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.81, i32 0, i32 0))
  %225 = load i16, i16* %var1uint16_1, align 2
  %226 = load i16, i16* %var1uint16_2, align 2
  %227 = load i16, i16* %var1uint16_3, align 2
  %228 = load i16, i16* %var1uint16_4, align 2
  call void @_Z14test_variable4It28custom_multiple_variable_xorItEEvPT_iS2_S2_S2_S2_PKc(i16* getelementptr inbounds ([8000 x i16], [8000 x i16]* @data16unsigned, i32 0, i32 0), i32 8000, i16 zeroext %225, i16 zeroext %226, i16 zeroext %227, i16 zeroext %228, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.82, i32 0, i32 0))
  %229 = load double, double* @init_value, align 8
  %conv63 = fptosi double %229 to i32
  call void @_Z4fillIPiiEvT_S1_T0_(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32* getelementptr inbounds (i32, i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i64 8000), i32 %conv63)
  %230 = load double, double* %temp, align 8
  %conv64 = fptosi double %230 to i32
  store i32 %conv64, i32* %var1int32_1, align 4
  %231 = load i32, i32* %var1int32_1, align 4
  %mul65 = mul nsw i32 %231, 2
  store i32 %mul65, i32* %var1int32_2, align 4
  %232 = load i32, i32* %var1int32_1, align 4
  %add66 = add nsw i32 %232, 2
  store i32 %add66, i32* %var1int32_3, align 4
  %233 = load i32, i32* %var1int32_1, align 4
  %234 = load i32, i32* %var1int32_2, align 4
  %235 = load i32, i32* %var1int32_3, align 4
  %div67 = sdiv i32 %234, %235
  %add68 = add nsw i32 %233, %div67
  store i32 %add68, i32* %var1int32_4, align 4
  %236 = load i32, i32* %var1int32_1, align 4
  call void @_Z14test_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %236, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.83, i32 0, i32 0))
  %237 = load i32, i32* %var1int32_1, align 4
  call void @_Z22test_hoisted_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %237, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.84, i32 0, i32 0))
  %238 = load i32, i32* %var1int32_1, align 4
  %239 = load i32, i32* %var1int32_2, align 4
  %240 = load i32, i32* %var1int32_3, align 4
  %241 = load i32, i32* %var1int32_4, align 4
  call void @_Z14test_variable4Ii28custom_add_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %238, i32 %239, i32 %240, i32 %241, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.85, i32 0, i32 0))
  %242 = load i32, i32* %var1int32_1, align 4
  call void @_Z14test_variable1Ii19custom_sub_variableIiEEvPT_iS2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %242, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.86, i32 0, i32 0))
  %243 = load i32, i32* %var1int32_1, align 4
  %244 = load i32, i32* %var1int32_2, align 4
  %245 = load i32, i32* %var1int32_3, align 4
  %246 = load i32, i32* %var1int32_4, align 4
  call void @_Z14test_variable4Ii28custom_sub_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %243, i32 %244, i32 %245, i32 %246, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.87, i32 0, i32 0))
  %247 = load i32, i32* %var1int32_1, align 4
  call void @_Z14test_variable1Ii24custom_multiply_variableIiEEvPT_iS2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %247, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.88, i32 0, i32 0))
  %248 = load i32, i32* %var1int32_1, align 4
  %249 = load i32, i32* %var1int32_2, align 4
  %250 = load i32, i32* %var1int32_3, align 4
  %251 = load i32, i32* %var1int32_4, align 4
  call void @_Z14test_variable4Ii33custom_multiply_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %248, i32 %249, i32 %250, i32 %251, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.89, i32 0, i32 0))
  %252 = load i32, i32* %var1int32_1, align 4
  %253 = load i32, i32* %var1int32_2, align 4
  %254 = load i32, i32* %var1int32_3, align 4
  %255 = load i32, i32* %var1int32_4, align 4
  call void @_Z14test_variable4Ii34custom_multiply_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %252, i32 %253, i32 %254, i32 %255, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.90, i32 0, i32 0))
  %256 = load i32, i32* %var1int32_1, align 4
  call void @_Z14test_variable1Ii22custom_divide_variableIiEEvPT_iS2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %256, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.91, i32 0, i32 0))
  %257 = load i32, i32* %var1int32_1, align 4
  %258 = load i32, i32* %var1int32_2, align 4
  %259 = load i32, i32* %var1int32_3, align 4
  %260 = load i32, i32* %var1int32_4, align 4
  call void @_Z14test_variable4Ii31custom_divide_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %257, i32 %258, i32 %259, i32 %260, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.92, i32 0, i32 0))
  %261 = load i32, i32* %var1int32_1, align 4
  %262 = load i32, i32* %var1int32_2, align 4
  %263 = load i32, i32* %var1int32_3, align 4
  %264 = load i32, i32* %var1int32_4, align 4
  call void @_Z14test_variable4Ii32custom_divide_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %261, i32 %262, i32 %263, i32 %264, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.93, i32 0, i32 0))
  %265 = load i32, i32* %var1int32_1, align 4
  %266 = load i32, i32* %var1int32_2, align 4
  %267 = load i32, i32* %var1int32_3, align 4
  %268 = load i32, i32* %var1int32_4, align 4
  call void @_Z14test_variable4Ii30custom_mixed_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %265, i32 %266, i32 %267, i32 %268, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.94, i32 0, i32 0))
  %269 = load i32, i32* %var1int32_1, align 4
  call void @_Z14test_variable1Ii19custom_variable_andIiEEvPT_iS2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %269, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.95, i32 0, i32 0))
  %270 = load i32, i32* %var1int32_1, align 4
  %271 = load i32, i32* %var1int32_2, align 4
  %272 = load i32, i32* %var1int32_3, align 4
  %273 = load i32, i32* %var1int32_4, align 4
  call void @_Z14test_variable4Ii28custom_multiple_variable_andIiEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %270, i32 %271, i32 %272, i32 %273, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.96, i32 0, i32 0))
  %274 = load i32, i32* %var1int32_1, align 4
  call void @_Z14test_variable1Ii18custom_variable_orIiEEvPT_iS2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %274, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.97, i32 0, i32 0))
  %275 = load i32, i32* %var1int32_1, align 4
  %276 = load i32, i32* %var1int32_2, align 4
  %277 = load i32, i32* %var1int32_3, align 4
  %278 = load i32, i32* %var1int32_4, align 4
  call void @_Z14test_variable4Ii27custom_multiple_variable_orIiEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %275, i32 %276, i32 %277, i32 %278, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.98, i32 0, i32 0))
  %279 = load i32, i32* %var1int32_1, align 4
  call void @_Z14test_variable1Ii19custom_variable_xorIiEEvPT_iS2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %279, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.99, i32 0, i32 0))
  %280 = load i32, i32* %var1int32_1, align 4
  %281 = load i32, i32* %var1int32_2, align 4
  %282 = load i32, i32* %var1int32_3, align 4
  %283 = load i32, i32* %var1int32_4, align 4
  call void @_Z14test_variable4Ii28custom_multiple_variable_xorIiEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32, i32 0, i32 0), i32 8000, i32 %280, i32 %281, i32 %282, i32 %283, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.100, i32 0, i32 0))
  %284 = load double, double* @init_value, align 8
  %conv69 = fptoui double %284 to i32
  call void @_Z4fillIPjjEvT_S1_T0_(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32* getelementptr inbounds (i32, i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i64 8000), i32 %conv69)
  %285 = load double, double* %temp, align 8
  %conv70 = fptoui double %285 to i32
  store i32 %conv70, i32* %var1uint32_1, align 4
  %286 = load i32, i32* %var1uint32_1, align 4
  %mul71 = mul i32 %286, 2
  store i32 %mul71, i32* %var1uint32_2, align 4
  %287 = load i32, i32* %var1uint32_1, align 4
  %add72 = add i32 %287, 2
  store i32 %add72, i32* %var1uint32_3, align 4
  %288 = load i32, i32* %var1uint32_1, align 4
  %289 = load i32, i32* %var1uint32_2, align 4
  %290 = load i32, i32* %var1uint32_3, align 4
  %div73 = udiv i32 %289, %290
  %add74 = add i32 %288, %div73
  store i32 %add74, i32* %var1uint32_4, align 4
  %291 = load i32, i32* %var1uint32_1, align 4
  call void @_Z14test_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %291, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.101, i32 0, i32 0))
  %292 = load i32, i32* %var1uint32_1, align 4
  call void @_Z22test_hoisted_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %292, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.102, i32 0, i32 0))
  %293 = load i32, i32* %var1uint32_1, align 4
  %294 = load i32, i32* %var1uint32_2, align 4
  %295 = load i32, i32* %var1uint32_3, align 4
  %296 = load i32, i32* %var1uint32_4, align 4
  call void @_Z14test_variable4Ij28custom_add_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %293, i32 %294, i32 %295, i32 %296, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.103, i32 0, i32 0))
  %297 = load i32, i32* %var1uint32_1, align 4
  call void @_Z14test_variable1Ij19custom_sub_variableIjEEvPT_iS2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %297, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.104, i32 0, i32 0))
  %298 = load i32, i32* %var1uint32_1, align 4
  %299 = load i32, i32* %var1uint32_2, align 4
  %300 = load i32, i32* %var1uint32_3, align 4
  %301 = load i32, i32* %var1uint32_4, align 4
  call void @_Z14test_variable4Ij28custom_sub_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %298, i32 %299, i32 %300, i32 %301, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.105, i32 0, i32 0))
  %302 = load i32, i32* %var1uint32_1, align 4
  call void @_Z14test_variable1Ij24custom_multiply_variableIjEEvPT_iS2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %302, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.106, i32 0, i32 0))
  %303 = load i32, i32* %var1uint32_1, align 4
  %304 = load i32, i32* %var1uint32_2, align 4
  %305 = load i32, i32* %var1uint32_3, align 4
  %306 = load i32, i32* %var1uint32_4, align 4
  call void @_Z14test_variable4Ij33custom_multiply_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %303, i32 %304, i32 %305, i32 %306, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.107, i32 0, i32 0))
  %307 = load i32, i32* %var1uint32_1, align 4
  %308 = load i32, i32* %var1uint32_2, align 4
  %309 = load i32, i32* %var1uint32_3, align 4
  %310 = load i32, i32* %var1uint32_4, align 4
  call void @_Z14test_variable4Ij34custom_multiply_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %307, i32 %308, i32 %309, i32 %310, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.108, i32 0, i32 0))
  %311 = load i32, i32* %var1uint32_1, align 4
  call void @_Z14test_variable1Ij22custom_divide_variableIjEEvPT_iS2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %311, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.109, i32 0, i32 0))
  %312 = load i32, i32* %var1uint32_1, align 4
  %313 = load i32, i32* %var1uint32_2, align 4
  %314 = load i32, i32* %var1uint32_3, align 4
  %315 = load i32, i32* %var1uint32_4, align 4
  call void @_Z14test_variable4Ij31custom_divide_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %312, i32 %313, i32 %314, i32 %315, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.110, i32 0, i32 0))
  %316 = load i32, i32* %var1uint32_1, align 4
  %317 = load i32, i32* %var1uint32_2, align 4
  %318 = load i32, i32* %var1uint32_3, align 4
  %319 = load i32, i32* %var1uint32_4, align 4
  call void @_Z14test_variable4Ij32custom_divide_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %316, i32 %317, i32 %318, i32 %319, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.111, i32 0, i32 0))
  %320 = load i32, i32* %var1uint32_1, align 4
  %321 = load i32, i32* %var1uint32_2, align 4
  %322 = load i32, i32* %var1uint32_3, align 4
  %323 = load i32, i32* %var1uint32_4, align 4
  call void @_Z14test_variable4Ij30custom_mixed_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %320, i32 %321, i32 %322, i32 %323, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.112, i32 0, i32 0))
  %324 = load i32, i32* %var1uint32_1, align 4
  call void @_Z14test_variable1Ij19custom_variable_andIjEEvPT_iS2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %324, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.113, i32 0, i32 0))
  %325 = load i32, i32* %var1uint32_1, align 4
  %326 = load i32, i32* %var1uint32_2, align 4
  %327 = load i32, i32* %var1uint32_3, align 4
  %328 = load i32, i32* %var1uint32_4, align 4
  call void @_Z14test_variable4Ij28custom_multiple_variable_andIjEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %325, i32 %326, i32 %327, i32 %328, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.114, i32 0, i32 0))
  %329 = load i32, i32* %var1uint32_1, align 4
  call void @_Z14test_variable1Ij18custom_variable_orIjEEvPT_iS2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %329, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.115, i32 0, i32 0))
  %330 = load i32, i32* %var1uint32_1, align 4
  %331 = load i32, i32* %var1uint32_2, align 4
  %332 = load i32, i32* %var1uint32_3, align 4
  %333 = load i32, i32* %var1uint32_4, align 4
  call void @_Z14test_variable4Ij27custom_multiple_variable_orIjEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %330, i32 %331, i32 %332, i32 %333, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.116, i32 0, i32 0))
  %334 = load i32, i32* %var1uint32_1, align 4
  call void @_Z14test_variable1Ij19custom_variable_xorIjEEvPT_iS2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %334, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.117, i32 0, i32 0))
  %335 = load i32, i32* %var1uint32_1, align 4
  %336 = load i32, i32* %var1uint32_2, align 4
  %337 = load i32, i32* %var1uint32_3, align 4
  %338 = load i32, i32* %var1uint32_4, align 4
  call void @_Z14test_variable4Ij28custom_multiple_variable_xorIjEEvPT_iS2_S2_S2_S2_PKc(i32* getelementptr inbounds ([8000 x i32], [8000 x i32]* @data32unsigned, i32 0, i32 0), i32 8000, i32 %335, i32 %336, i32 %337, i32 %338, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.118, i32 0, i32 0))
  %339 = load double, double* @init_value, align 8
  %conv75 = fptosi double %339 to i64
  call void @_Z4fillIPllEvT_S1_T0_(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i64* getelementptr inbounds (i64, i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i64 8000), i64 %conv75)
  %340 = load double, double* %temp, align 8
  %conv76 = fptosi double %340 to i64
  store i64 %conv76, i64* %var1int64_1, align 8
  %341 = load i64, i64* %var1int64_1, align 8
  %mul77 = mul nsw i64 %341, 2
  store i64 %mul77, i64* %var1int64_2, align 8
  %342 = load i64, i64* %var1int64_1, align 8
  %add78 = add nsw i64 %342, 2
  store i64 %add78, i64* %var1int64_3, align 8
  %343 = load i64, i64* %var1int64_1, align 8
  %344 = load i64, i64* %var1int64_2, align 8
  %345 = load i64, i64* %var1int64_3, align 8
  %div79 = sdiv i64 %344, %345
  %add80 = add nsw i64 %343, %div79
  store i64 %add80, i64* %var1int64_4, align 8
  %346 = load i64, i64* %var1int64_1, align 8
  call void @_Z14test_variable1Il19custom_add_variableIlEEvPT_iS2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %346, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.119, i32 0, i32 0))
  %347 = load i64, i64* %var1int64_1, align 8
  call void @_Z22test_hoisted_variable1Il19custom_add_variableIlEEvPT_iS2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %347, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.120, i32 0, i32 0))
  %348 = load i64, i64* %var1int64_1, align 8
  %349 = load i64, i64* %var1int64_2, align 8
  %350 = load i64, i64* %var1int64_3, align 8
  %351 = load i64, i64* %var1int64_4, align 8
  call void @_Z14test_variable4Il28custom_add_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %348, i64 %349, i64 %350, i64 %351, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.121, i32 0, i32 0))
  %352 = load i64, i64* %var1int64_1, align 8
  call void @_Z14test_variable1Il19custom_sub_variableIlEEvPT_iS2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %352, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.122, i32 0, i32 0))
  %353 = load i64, i64* %var1int64_1, align 8
  %354 = load i64, i64* %var1int64_2, align 8
  %355 = load i64, i64* %var1int64_3, align 8
  %356 = load i64, i64* %var1int64_4, align 8
  call void @_Z14test_variable4Il28custom_sub_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %353, i64 %354, i64 %355, i64 %356, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.123, i32 0, i32 0))
  %357 = load i64, i64* %var1int64_1, align 8
  call void @_Z14test_variable1Il24custom_multiply_variableIlEEvPT_iS2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %357, i8* getelementptr inbounds ([26 x i8], [26 x i8]* @.str.124, i32 0, i32 0))
  %358 = load i64, i64* %var1int64_1, align 8
  %359 = load i64, i64* %var1int64_2, align 8
  %360 = load i64, i64* %var1int64_3, align 8
  %361 = load i64, i64* %var1int64_4, align 8
  call void @_Z14test_variable4Il33custom_multiply_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %358, i64 %359, i64 %360, i64 %361, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.125, i32 0, i32 0))
  %362 = load i64, i64* %var1int64_1, align 8
  %363 = load i64, i64* %var1int64_2, align 8
  %364 = load i64, i64* %var1int64_3, align 8
  %365 = load i64, i64* %var1int64_4, align 8
  call void @_Z14test_variable4Il34custom_multiply_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %362, i64 %363, i64 %364, i64 %365, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.126, i32 0, i32 0))
  %366 = load i64, i64* %var1int64_1, align 8
  call void @_Z14test_variable1Il22custom_divide_variableIlEEvPT_iS2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %366, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.127, i32 0, i32 0))
  %367 = load i64, i64* %var1int64_1, align 8
  %368 = load i64, i64* %var1int64_2, align 8
  %369 = load i64, i64* %var1int64_3, align 8
  %370 = load i64, i64* %var1int64_4, align 8
  call void @_Z14test_variable4Il31custom_divide_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %367, i64 %368, i64 %369, i64 %370, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.128, i32 0, i32 0))
  %371 = load i64, i64* %var1int64_1, align 8
  %372 = load i64, i64* %var1int64_2, align 8
  %373 = load i64, i64* %var1int64_3, align 8
  %374 = load i64, i64* %var1int64_4, align 8
  call void @_Z14test_variable4Il32custom_divide_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %371, i64 %372, i64 %373, i64 %374, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.129, i32 0, i32 0))
  %375 = load i64, i64* %var1int64_1, align 8
  %376 = load i64, i64* %var1int64_2, align 8
  %377 = load i64, i64* %var1int64_3, align 8
  %378 = load i64, i64* %var1int64_4, align 8
  call void @_Z14test_variable4Il30custom_mixed_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %375, i64 %376, i64 %377, i64 %378, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.130, i32 0, i32 0))
  %379 = load i64, i64* %var1int64_1, align 8
  call void @_Z14test_variable1Il19custom_variable_andIlEEvPT_iS2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %379, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.131, i32 0, i32 0))
  %380 = load i64, i64* %var1int64_1, align 8
  %381 = load i64, i64* %var1int64_2, align 8
  %382 = load i64, i64* %var1int64_3, align 8
  %383 = load i64, i64* %var1int64_4, align 8
  call void @_Z14test_variable4Il28custom_multiple_variable_andIlEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %380, i64 %381, i64 %382, i64 %383, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.132, i32 0, i32 0))
  %384 = load i64, i64* %var1int64_1, align 8
  call void @_Z14test_variable1Il18custom_variable_orIlEEvPT_iS2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %384, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.133, i32 0, i32 0))
  %385 = load i64, i64* %var1int64_1, align 8
  %386 = load i64, i64* %var1int64_2, align 8
  %387 = load i64, i64* %var1int64_3, align 8
  %388 = load i64, i64* %var1int64_4, align 8
  call void @_Z14test_variable4Il27custom_multiple_variable_orIlEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %385, i64 %386, i64 %387, i64 %388, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.134, i32 0, i32 0))
  %389 = load i64, i64* %var1int64_1, align 8
  call void @_Z14test_variable1Il19custom_variable_xorIlEEvPT_iS2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %389, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.135, i32 0, i32 0))
  %390 = load i64, i64* %var1int64_1, align 8
  %391 = load i64, i64* %var1int64_2, align 8
  %392 = load i64, i64* %var1int64_3, align 8
  %393 = load i64, i64* %var1int64_4, align 8
  call void @_Z14test_variable4Il28custom_multiple_variable_xorIlEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64, i32 0, i32 0), i32 8000, i64 %390, i64 %391, i64 %392, i64 %393, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.136, i32 0, i32 0))
  %394 = load double, double* @init_value, align 8
  %conv81 = fptoui double %394 to i64
  call void @_Z4fillIPmmEvT_S1_T0_(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i64* getelementptr inbounds (i64, i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i64 8000), i64 %conv81)
  %395 = load double, double* %temp, align 8
  %conv82 = fptoui double %395 to i64
  store i64 %conv82, i64* %var1uint64_1, align 8
  %396 = load i64, i64* %var1uint64_1, align 8
  %mul83 = mul i64 %396, 2
  store i64 %mul83, i64* %var1uint64_2, align 8
  %397 = load i64, i64* %var1uint64_1, align 8
  %add84 = add i64 %397, 2
  store i64 %add84, i64* %var1uint64_3, align 8
  %398 = load i64, i64* %var1uint64_1, align 8
  %399 = load i64, i64* %var1uint64_2, align 8
  %400 = load i64, i64* %var1uint64_3, align 8
  %div85 = udiv i64 %399, %400
  %add86 = add i64 %398, %div85
  store i64 %add86, i64* %var1uint64_4, align 8
  %401 = load i64, i64* %var1uint64_1, align 8
  call void @_Z14test_variable1Im19custom_add_variableImEEvPT_iS2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %401, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.137, i32 0, i32 0))
  %402 = load i64, i64* %var1uint64_1, align 8
  call void @_Z22test_hoisted_variable1Im19custom_add_variableImEEvPT_iS2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %402, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.138, i32 0, i32 0))
  %403 = load i64, i64* %var1uint64_1, align 8
  %404 = load i64, i64* %var1uint64_2, align 8
  %405 = load i64, i64* %var1uint64_3, align 8
  %406 = load i64, i64* %var1uint64_4, align 8
  call void @_Z14test_variable4Im28custom_add_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %403, i64 %404, i64 %405, i64 %406, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.139, i32 0, i32 0))
  %407 = load i64, i64* %var1uint64_1, align 8
  call void @_Z14test_variable1Im19custom_sub_variableImEEvPT_iS2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %407, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.140, i32 0, i32 0))
  %408 = load i64, i64* %var1uint64_1, align 8
  %409 = load i64, i64* %var1uint64_2, align 8
  %410 = load i64, i64* %var1uint64_3, align 8
  %411 = load i64, i64* %var1uint64_4, align 8
  call void @_Z14test_variable4Im28custom_sub_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %408, i64 %409, i64 %410, i64 %411, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.141, i32 0, i32 0))
  %412 = load i64, i64* %var1uint64_1, align 8
  call void @_Z14test_variable1Im24custom_multiply_variableImEEvPT_iS2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %412, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.142, i32 0, i32 0))
  %413 = load i64, i64* %var1uint64_1, align 8
  %414 = load i64, i64* %var1uint64_2, align 8
  %415 = load i64, i64* %var1uint64_3, align 8
  %416 = load i64, i64* %var1uint64_4, align 8
  call void @_Z14test_variable4Im33custom_multiply_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %413, i64 %414, i64 %415, i64 %416, i8* getelementptr inbounds ([38 x i8], [38 x i8]* @.str.143, i32 0, i32 0))
  %417 = load i64, i64* %var1uint64_1, align 8
  %418 = load i64, i64* %var1uint64_2, align 8
  %419 = load i64, i64* %var1uint64_3, align 8
  %420 = load i64, i64* %var1uint64_4, align 8
  call void @_Z14test_variable4Im34custom_multiply_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %417, i64 %418, i64 %419, i64 %420, i8* getelementptr inbounds ([39 x i8], [39 x i8]* @.str.144, i32 0, i32 0))
  %421 = load i64, i64* %var1uint64_1, align 8
  call void @_Z14test_variable1Im22custom_divide_variableImEEvPT_iS2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %421, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.145, i32 0, i32 0))
  %422 = load i64, i64* %var1uint64_1, align 8
  %423 = load i64, i64* %var1uint64_2, align 8
  %424 = load i64, i64* %var1uint64_3, align 8
  %425 = load i64, i64* %var1uint64_4, align 8
  call void @_Z14test_variable4Im31custom_divide_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %422, i64 %423, i64 %424, i64 %425, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.146, i32 0, i32 0))
  %426 = load i64, i64* %var1uint64_1, align 8
  %427 = load i64, i64* %var1uint64_2, align 8
  %428 = load i64, i64* %var1uint64_3, align 8
  %429 = load i64, i64* %var1uint64_4, align 8
  call void @_Z14test_variable4Im32custom_divide_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %426, i64 %427, i64 %428, i64 %429, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.147, i32 0, i32 0))
  %430 = load i64, i64* %var1uint64_1, align 8
  %431 = load i64, i64* %var1uint64_2, align 8
  %432 = load i64, i64* %var1uint64_3, align 8
  %433 = load i64, i64* %var1uint64_4, align 8
  call void @_Z14test_variable4Im30custom_mixed_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %430, i64 %431, i64 %432, i64 %433, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.148, i32 0, i32 0))
  %434 = load i64, i64* %var1uint64_1, align 8
  call void @_Z14test_variable1Im19custom_variable_andImEEvPT_iS2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %434, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.149, i32 0, i32 0))
  %435 = load i64, i64* %var1uint64_1, align 8
  %436 = load i64, i64* %var1uint64_2, align 8
  %437 = load i64, i64* %var1uint64_3, align 8
  %438 = load i64, i64* %var1uint64_4, align 8
  call void @_Z14test_variable4Im28custom_multiple_variable_andImEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %435, i64 %436, i64 %437, i64 %438, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.150, i32 0, i32 0))
  %439 = load i64, i64* %var1uint64_1, align 8
  call void @_Z14test_variable1Im18custom_variable_orImEEvPT_iS2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %439, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @.str.151, i32 0, i32 0))
  %440 = load i64, i64* %var1uint64_1, align 8
  %441 = load i64, i64* %var1uint64_2, align 8
  %442 = load i64, i64* %var1uint64_3, align 8
  %443 = load i64, i64* %var1uint64_4, align 8
  call void @_Z14test_variable4Im27custom_multiple_variable_orImEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %440, i64 %441, i64 %442, i64 %443, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.152, i32 0, i32 0))
  %444 = load i64, i64* %var1uint64_1, align 8
  call void @_Z14test_variable1Im19custom_variable_xorImEEvPT_iS2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %444, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.153, i32 0, i32 0))
  %445 = load i64, i64* %var1uint64_1, align 8
  %446 = load i64, i64* %var1uint64_2, align 8
  %447 = load i64, i64* %var1uint64_3, align 8
  %448 = load i64, i64* %var1uint64_4, align 8
  call void @_Z14test_variable4Im28custom_multiple_variable_xorImEEvPT_iS2_S2_S2_S2_PKc(i64* getelementptr inbounds ([8000 x i64], [8000 x i64]* @data64unsigned, i32 0, i32 0), i32 8000, i64 %445, i64 %446, i64 %447, i64 %448, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.154, i32 0, i32 0))
  %449 = load double, double* @init_value, align 8
  %conv87 = fptrunc double %449 to float
  call void @_Z4fillIPffEvT_S1_T0_(float* getelementptr inbounds ([8000 x float], [8000 x float]* @dataFloat, i32 0, i32 0), float* getelementptr inbounds (float, float* getelementptr inbounds ([8000 x float], [8000 x float]* @dataFloat, i32 0, i32 0), i64 8000), float %conv87)
  %450 = load double, double* %temp, align 8
  %conv88 = fptrunc double %450 to float
  store float %conv88, float* %var1Float_1, align 4
  %451 = load float, float* %var1Float_1, align 4
  %mul89 = fmul float %451, 2.000000e+00
  store float %mul89, float* %var1Float_2, align 4
  %452 = load float, float* %var1Float_1, align 4
  %add90 = fadd float %452, 2.000000e+00
  store float %add90, float* %var1Float_3, align 4
  %453 = load float, float* %var1Float_1, align 4
  %454 = load float, float* %var1Float_2, align 4
  %455 = load float, float* %var1Float_3, align 4
  %div91 = fdiv float %454, %455
  %add92 = fadd float %453, %div91
  store float %add92, float* %var1Float_4, align 4
  %456 = load float, float* %var1Float_1, align 4
  call void @_Z14test_variable1If19custom_add_variableIfEEvPT_iS2_PKc(float* getelementptr inbounds ([8000 x float], [8000 x float]* @dataFloat, i32 0, i32 0), i32 8000, float %456, i8* getelementptr inbounds ([19 x i8], [19 x i8]* @.str.155, i32 0, i32 0))
  %457 = load float, float* %var1Float_1, align 4
  call void @_Z22test_hoisted_variable1If19custom_add_variableIfEEvPT_iS2_PKc(float* getelementptr inbounds ([8000 x float], [8000 x float]* @dataFloat, i32 0, i32 0), i32 8000, float %457, i8* getelementptr inbounds ([27 x i8], [27 x i8]* @.str.156, i32 0, i32 0))
  %458 = load float, float* %var1Float_1, align 4
  %459 = load float, float* %var1Float_2, align 4
  %460 = load float, float* %var1Float_3, align 4
  %461 = load float, float* %var1Float_4, align 4
  call void @_Z14test_variable4If28custom_add_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(float* getelementptr inbounds ([8000 x float], [8000 x float]* @dataFloat, i32 0, i32 0), i32 8000, float %458, float %459, float %460, float %461, i8* getelementptr inbounds ([29 x i8], [29 x i8]* @.str.157, i32 0, i32 0))
  %462 = load float, float* %var1Float_1, align 4
  call void @_Z14test_variable1If19custom_sub_variableIfEEvPT_iS2_PKc(float* getelementptr inbounds ([8000 x float], [8000 x float]* @dataFloat, i32 0, i32 0), i32 8000, float %462, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.158, i32 0, i32 0))
  %463 = load float, float* %var1Float_1, align 4
  %464 = load float, float* %var1Float_2, align 4
  %465 = load float, float* %var1Float_3, align 4
  %466 = load float, float* %var1Float_4, align 4
  call void @_Z14test_variable4If28custom_sub_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(float* getelementptr inbounds ([8000 x float], [8000 x float]* @dataFloat, i32 0, i32 0), i32 8000, float %463, float %464, float %465, float %466, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.159, i32 0, i32 0))
  %467 = load float, float* %var1Float_1, align 4
  call void @_Z14test_variable1If24custom_multiply_variableIfEEvPT_iS2_PKc(float* getelementptr inbounds ([8000 x float], [8000 x float]* @dataFloat, i32 0, i32 0), i32 8000, float %467, i8* getelementptr inbounds ([24 x i8], [24 x i8]* @.str.160, i32 0, i32 0))
  %468 = load float, float* %var1Float_1, align 4
  %469 = load float, float* %var1Float_2, align 4
  %470 = load float, float* %var1Float_3, align 4
  %471 = load float, float* %var1Float_4, align 4
  call void @_Z14test_variable4If33custom_multiply_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(float* getelementptr inbounds ([8000 x float], [8000 x float]* @dataFloat, i32 0, i32 0), i32 8000, float %468, float %469, float %470, float %471, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.161, i32 0, i32 0))
  %472 = load float, float* %var1Float_1, align 4
  %473 = load float, float* %var1Float_2, align 4
  %474 = load float, float* %var1Float_3, align 4
  %475 = load float, float* %var1Float_4, align 4
  call void @_Z14test_variable4If34custom_multiply_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc(float* getelementptr inbounds ([8000 x float], [8000 x float]* @dataFloat, i32 0, i32 0), i32 8000, float %472, float %473, float %474, float %475, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.162, i32 0, i32 0))
  %476 = load float, float* %var1Float_1, align 4
  call void @_Z14test_variable1If22custom_divide_variableIfEEvPT_iS2_PKc(float* getelementptr inbounds ([8000 x float], [8000 x float]* @dataFloat, i32 0, i32 0), i32 8000, float %476, i8* getelementptr inbounds ([22 x i8], [22 x i8]* @.str.163, i32 0, i32 0))
  %477 = load float, float* %var1Float_1, align 4
  %478 = load float, float* %var1Float_2, align 4
  %479 = load float, float* %var1Float_3, align 4
  %480 = load float, float* %var1Float_4, align 4
  call void @_Z14test_variable4If31custom_divide_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(float* getelementptr inbounds ([8000 x float], [8000 x float]* @dataFloat, i32 0, i32 0), i32 8000, float %477, float %478, float %479, float %480, i8* getelementptr inbounds ([32 x i8], [32 x i8]* @.str.164, i32 0, i32 0))
  %481 = load float, float* %var1Float_1, align 4
  %482 = load float, float* %var1Float_2, align 4
  %483 = load float, float* %var1Float_3, align 4
  %484 = load float, float* %var1Float_4, align 4
  call void @_Z14test_variable4If32custom_divide_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc(float* getelementptr inbounds ([8000 x float], [8000 x float]* @dataFloat, i32 0, i32 0), i32 8000, float %481, float %482, float %483, float %484, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.165, i32 0, i32 0))
  %485 = load float, float* %var1Float_1, align 4
  %486 = load float, float* %var1Float_2, align 4
  %487 = load float, float* %var1Float_3, align 4
  %488 = load float, float* %var1Float_4, align 4
  call void @_Z14test_variable4If30custom_mixed_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(float* getelementptr inbounds ([8000 x float], [8000 x float]* @dataFloat, i32 0, i32 0), i32 8000, float %485, float %486, float %487, float %488, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.166, i32 0, i32 0))
  %489 = load double, double* @init_value, align 8
  call void @_Z4fillIPddEvT_S1_T0_(double* getelementptr inbounds ([8000 x double], [8000 x double]* @dataDouble, i32 0, i32 0), double* getelementptr inbounds (double, double* getelementptr inbounds ([8000 x double], [8000 x double]* @dataDouble, i32 0, i32 0), i64 8000), double %489)
  %490 = load double, double* %temp, align 8
  store double %490, double* %var1Double_1, align 8
  %491 = load double, double* %var1Double_1, align 8
  %mul93 = fmul double %491, 2.000000e+00
  store double %mul93, double* %var1Double_2, align 8
  %492 = load double, double* %var1Double_1, align 8
  %add94 = fadd double %492, 2.000000e+00
  store double %add94, double* %var1Double_3, align 8
  %493 = load double, double* %var1Double_1, align 8
  %494 = load double, double* %var1Double_2, align 8
  %495 = load double, double* %var1Double_3, align 8
  %div95 = fdiv double %494, %495
  %add96 = fadd double %493, %div95
  store double %add96, double* %var1Double_4, align 8
  %496 = load double, double* %var1Double_1, align 8
  call void @_Z14test_variable1Id19custom_add_variableIdEEvPT_iS2_PKc(double* getelementptr inbounds ([8000 x double], [8000 x double]* @dataDouble, i32 0, i32 0), i32 8000, double %496, i8* getelementptr inbounds ([20 x i8], [20 x i8]* @.str.167, i32 0, i32 0))
  %497 = load double, double* %var1Double_1, align 8
  call void @_Z22test_hoisted_variable1Id19custom_add_variableIdEEvPT_iS2_PKc(double* getelementptr inbounds ([8000 x double], [8000 x double]* @dataDouble, i32 0, i32 0), i32 8000, double %497, i8* getelementptr inbounds ([28 x i8], [28 x i8]* @.str.168, i32 0, i32 0))
  %498 = load double, double* %var1Double_1, align 8
  %499 = load double, double* %var1Double_2, align 8
  %500 = load double, double* %var1Double_3, align 8
  %501 = load double, double* %var1Double_4, align 8
  call void @_Z14test_variable4Id28custom_add_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(double* getelementptr inbounds ([8000 x double], [8000 x double]* @dataDouble, i32 0, i32 0), i32 8000, double %498, double %499, double %500, double %501, i8* getelementptr inbounds ([30 x i8], [30 x i8]* @.str.169, i32 0, i32 0))
  %502 = load double, double* %var1Double_1, align 8
  call void @_Z14test_variable1Id19custom_sub_variableIdEEvPT_iS2_PKc(double* getelementptr inbounds ([8000 x double], [8000 x double]* @dataDouble, i32 0, i32 0), i32 8000, double %502, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.170, i32 0, i32 0))
  %503 = load double, double* %var1Double_1, align 8
  %504 = load double, double* %var1Double_2, align 8
  %505 = load double, double* %var1Double_3, align 8
  %506 = load double, double* %var1Double_4, align 8
  call void @_Z14test_variable4Id28custom_sub_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(double* getelementptr inbounds ([8000 x double], [8000 x double]* @dataDouble, i32 0, i32 0), i32 8000, double %503, double %504, double %505, double %506, i8* getelementptr inbounds ([35 x i8], [35 x i8]* @.str.171, i32 0, i32 0))
  %507 = load double, double* %var1Double_1, align 8
  call void @_Z14test_variable1Id24custom_multiply_variableIdEEvPT_iS2_PKc(double* getelementptr inbounds ([8000 x double], [8000 x double]* @dataDouble, i32 0, i32 0), i32 8000, double %507, i8* getelementptr inbounds ([25 x i8], [25 x i8]* @.str.172, i32 0, i32 0))
  %508 = load double, double* %var1Double_1, align 8
  %509 = load double, double* %var1Double_2, align 8
  %510 = load double, double* %var1Double_3, align 8
  %511 = load double, double* %var1Double_4, align 8
  call void @_Z14test_variable4Id33custom_multiply_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(double* getelementptr inbounds ([8000 x double], [8000 x double]* @dataDouble, i32 0, i32 0), i32 8000, double %508, double %509, double %510, double %511, i8* getelementptr inbounds ([36 x i8], [36 x i8]* @.str.173, i32 0, i32 0))
  %512 = load double, double* %var1Double_1, align 8
  %513 = load double, double* %var1Double_2, align 8
  %514 = load double, double* %var1Double_3, align 8
  %515 = load double, double* %var1Double_4, align 8
  call void @_Z14test_variable4Id34custom_multiply_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc(double* getelementptr inbounds ([8000 x double], [8000 x double]* @dataDouble, i32 0, i32 0), i32 8000, double %512, double %513, double %514, double %515, i8* getelementptr inbounds ([37 x i8], [37 x i8]* @.str.174, i32 0, i32 0))
  %516 = load double, double* %var1Double_1, align 8
  call void @_Z14test_variable1Id22custom_divide_variableIdEEvPT_iS2_PKc(double* getelementptr inbounds ([8000 x double], [8000 x double]* @dataDouble, i32 0, i32 0), i32 8000, double %516, i8* getelementptr inbounds ([23 x i8], [23 x i8]* @.str.175, i32 0, i32 0))
  %517 = load double, double* %var1Double_1, align 8
  %518 = load double, double* %var1Double_2, align 8
  %519 = load double, double* %var1Double_3, align 8
  %520 = load double, double* %var1Double_4, align 8
  call void @_Z14test_variable4Id31custom_divide_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(double* getelementptr inbounds ([8000 x double], [8000 x double]* @dataDouble, i32 0, i32 0), i32 8000, double %517, double %518, double %519, double %520, i8* getelementptr inbounds ([33 x i8], [33 x i8]* @.str.176, i32 0, i32 0))
  %521 = load double, double* %var1Double_1, align 8
  %522 = load double, double* %var1Double_2, align 8
  %523 = load double, double* %var1Double_3, align 8
  %524 = load double, double* %var1Double_4, align 8
  call void @_Z14test_variable4Id32custom_divide_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc(double* getelementptr inbounds ([8000 x double], [8000 x double]* @dataDouble, i32 0, i32 0), i32 8000, double %521, double %522, double %523, double %524, i8* getelementptr inbounds ([34 x i8], [34 x i8]* @.str.177, i32 0, i32 0))
  %525 = load double, double* %var1Double_1, align 8
  %526 = load double, double* %var1Double_2, align 8
  %527 = load double, double* %var1Double_3, align 8
  %528 = load double, double* %var1Double_4, align 8
  call void @_Z14test_variable4Id30custom_mixed_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(double* getelementptr inbounds ([8000 x double], [8000 x double]* @dataDouble, i32 0, i32 0), i32 8000, double %525, double %526, double %527, double %528, i8* getelementptr inbounds ([31 x i8], [31 x i8]* @.str.178, i32 0, i32 0))
  ret i32 0
}

; Function Attrs: nounwind readonly
declare i32 @atoi(i8*) #4

; Function Attrs: nounwind readonly
declare double @atof(i8*) #4

; Function Attrs: noinline nounwind uwtable
define linkonce_odr void @_Z4fillIPaaEvT_S1_T0_(i8* %first, i8* %last, i8 signext %value) #5 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %last.addr = alloca i8*, align 8
  %value.addr = alloca i8, align 1
  store i8* %first, i8** %first.addr, align 8
  store i8* %last, i8** %last.addr, align 8
  store i8 %value, i8* %value.addr, align 1
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i8*, i8** %first.addr, align 8
  %1 = load i8*, i8** %last.addr, align 8
  %cmp = icmp ne i8* %0, %1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load i8, i8* %value.addr, align 1
  %3 = load i8*, i8** %first.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %3, i32 1
  store i8* %incdec.ptr, i8** %first.addr, align 8
  store i8 %2, i8* %3, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc(i8* %first, i32 %count, i8 signext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %call = call signext i8 @_ZN19custom_add_variableIaE8do_shiftEaa(i8 signext %6, i8 signext %7)
  %conv = sext i8 %call to i32
  %8 = load i8, i8* %result, align 1
  %conv4 = sext i8 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i8, i8* %result, align 1
  %11 = load i8, i8* %v1.addr, align 1
  call void @_Z26check_shifted_variable_sumIa19custom_add_variableIaEEvT_S2_(i8 signext %10, i8 signext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z22test_hoisted_variable1Ia19custom_add_variableIaEEvPT_iS2_PKc(i8* %first, i32 %count, i8 signext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc10, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end12

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %conv = sext i8 %6 to i32
  %7 = load i8, i8* %result, align 1
  %conv4 = sext i8 %7 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %8 = load i32, i32* %n, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %9 = load i32, i32* %count.addr, align 4
  %10 = load i8, i8* %v1.addr, align 1
  %conv6 = sext i8 %10 to i32
  %mul = mul nsw i32 %9, %conv6
  %11 = load i8, i8* %result, align 1
  %conv7 = sext i8 %11 to i32
  %add8 = add nsw i32 %conv7, %mul
  %conv9 = trunc i32 %add8 to i8
  store i8 %conv9, i8* %result, align 1
  %12 = load i8, i8* %result, align 1
  %13 = load i8, i8* %v1.addr, align 1
  call void @_Z26check_shifted_variable_sumIa19custom_add_variableIaEEvT_S2_(i8 signext %12, i8 signext %13)
  br label %for.inc10

for.inc10:                                        ; preds = %for.end
  %14 = load i32, i32* %i, align 4
  %inc11 = add nsw i32 %14, 1
  store i32 %inc11, i32* %i, align 4
  br label %for.cond

for.end12:                                        ; preds = %for.cond
  %call = call double @_Z5timerv()
  %15 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call, i8* %15)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ia28custom_add_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call signext i8 @_ZN28custom_add_multiple_variableIaE8do_shiftEaaaaa(i8 signext %6, i8 signext %7, i8 signext %8, i8 signext %9, i8 signext %10)
  %conv = sext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = sext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIa28custom_add_multiple_variableIaEEvT_S2_S2_S2_S2_(i8 signext %13, i8 signext %14, i8 signext %15, i8 signext %16, i8 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ia19custom_sub_variableIaEEvPT_iS2_PKc(i8* %first, i32 %count, i8 signext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %call = call signext i8 @_ZN19custom_sub_variableIaE8do_shiftEaa(i8 signext %6, i8 signext %7)
  %conv = sext i8 %call to i32
  %8 = load i8, i8* %result, align 1
  %conv4 = sext i8 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i8, i8* %result, align 1
  %11 = load i8, i8* %v1.addr, align 1
  call void @_Z26check_shifted_variable_sumIa19custom_sub_variableIaEEvT_S2_(i8 signext %10, i8 signext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ia28custom_sub_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call signext i8 @_ZN28custom_sub_multiple_variableIaE8do_shiftEaaaaa(i8 signext %6, i8 signext %7, i8 signext %8, i8 signext %9, i8 signext %10)
  %conv = sext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = sext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIa28custom_sub_multiple_variableIaEEvT_S2_S2_S2_S2_(i8 signext %13, i8 signext %14, i8 signext %15, i8 signext %16, i8 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ia24custom_multiply_variableIaEEvPT_iS2_PKc(i8* %first, i32 %count, i8 signext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %call = call signext i8 @_ZN24custom_multiply_variableIaE8do_shiftEaa(i8 signext %6, i8 signext %7)
  %conv = sext i8 %call to i32
  %8 = load i8, i8* %result, align 1
  %conv4 = sext i8 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i8, i8* %result, align 1
  %11 = load i8, i8* %v1.addr, align 1
  call void @_Z26check_shifted_variable_sumIa24custom_multiply_variableIaEEvT_S2_(i8 signext %10, i8 signext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ia33custom_multiply_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call signext i8 @_ZN33custom_multiply_multiple_variableIaE8do_shiftEaaaaa(i8 signext %6, i8 signext %7, i8 signext %8, i8 signext %9, i8 signext %10)
  %conv = sext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = sext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIa33custom_multiply_multiple_variableIaEEvT_S2_S2_S2_S2_(i8 signext %13, i8 signext %14, i8 signext %15, i8 signext %16, i8 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ia34custom_multiply_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call signext i8 @_ZN34custom_multiply_multiple_variable2IaE8do_shiftEaaaaa(i8 signext %6, i8 signext %7, i8 signext %8, i8 signext %9, i8 signext %10)
  %conv = sext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = sext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIa34custom_multiply_multiple_variable2IaEEvT_S2_S2_S2_S2_(i8 signext %13, i8 signext %14, i8 signext %15, i8 signext %16, i8 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ia22custom_divide_variableIaEEvPT_iS2_PKc(i8* %first, i32 %count, i8 signext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %call = call signext i8 @_ZN22custom_divide_variableIaE8do_shiftEaa(i8 signext %6, i8 signext %7)
  %conv = sext i8 %call to i32
  %8 = load i8, i8* %result, align 1
  %conv4 = sext i8 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i8, i8* %result, align 1
  %11 = load i8, i8* %v1.addr, align 1
  call void @_Z26check_shifted_variable_sumIa22custom_divide_variableIaEEvT_S2_(i8 signext %10, i8 signext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ia31custom_divide_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call signext i8 @_ZN31custom_divide_multiple_variableIaE8do_shiftEaaaaa(i8 signext %6, i8 signext %7, i8 signext %8, i8 signext %9, i8 signext %10)
  %conv = sext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = sext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIa31custom_divide_multiple_variableIaEEvT_S2_S2_S2_S2_(i8 signext %13, i8 signext %14, i8 signext %15, i8 signext %16, i8 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ia32custom_divide_multiple_variable2IaEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call signext i8 @_ZN32custom_divide_multiple_variable2IaE8do_shiftEaaaaa(i8 signext %6, i8 signext %7, i8 signext %8, i8 signext %9, i8 signext %10)
  %conv = sext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = sext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIa32custom_divide_multiple_variable2IaEEvT_S2_S2_S2_S2_(i8 signext %13, i8 signext %14, i8 signext %15, i8 signext %16, i8 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ia30custom_mixed_multiple_variableIaEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call signext i8 @_ZN30custom_mixed_multiple_variableIaE8do_shiftEaaaaa(i8 signext %6, i8 signext %7, i8 signext %8, i8 signext %9, i8 signext %10)
  %conv = sext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = sext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIa30custom_mixed_multiple_variableIaEEvT_S2_S2_S2_S2_(i8 signext %13, i8 signext %14, i8 signext %15, i8 signext %16, i8 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ia19custom_variable_andIaEEvPT_iS2_PKc(i8* %first, i32 %count, i8 signext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %call = call signext i8 @_ZN19custom_variable_andIaE8do_shiftEaa(i8 signext %6, i8 signext %7)
  %conv = sext i8 %call to i32
  %8 = load i8, i8* %result, align 1
  %conv4 = sext i8 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i8, i8* %result, align 1
  %11 = load i8, i8* %v1.addr, align 1
  call void @_Z26check_shifted_variable_sumIa19custom_variable_andIaEEvT_S2_(i8 signext %10, i8 signext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ia28custom_multiple_variable_andIaEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call signext i8 @_ZN28custom_multiple_variable_andIaE8do_shiftEaaaaa(i8 signext %6, i8 signext %7, i8 signext %8, i8 signext %9, i8 signext %10)
  %conv = sext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = sext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIa28custom_multiple_variable_andIaEEvT_S2_S2_S2_S2_(i8 signext %13, i8 signext %14, i8 signext %15, i8 signext %16, i8 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ia18custom_variable_orIaEEvPT_iS2_PKc(i8* %first, i32 %count, i8 signext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %call = call signext i8 @_ZN18custom_variable_orIaE8do_shiftEaa(i8 signext %6, i8 signext %7)
  %conv = sext i8 %call to i32
  %8 = load i8, i8* %result, align 1
  %conv4 = sext i8 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i8, i8* %result, align 1
  %11 = load i8, i8* %v1.addr, align 1
  call void @_Z26check_shifted_variable_sumIa18custom_variable_orIaEEvT_S2_(i8 signext %10, i8 signext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ia27custom_multiple_variable_orIaEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call signext i8 @_ZN27custom_multiple_variable_orIaE8do_shiftEaaaaa(i8 signext %6, i8 signext %7, i8 signext %8, i8 signext %9, i8 signext %10)
  %conv = sext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = sext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIa27custom_multiple_variable_orIaEEvT_S2_S2_S2_S2_(i8 signext %13, i8 signext %14, i8 signext %15, i8 signext %16, i8 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ia19custom_variable_xorIaEEvPT_iS2_PKc(i8* %first, i32 %count, i8 signext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %call = call signext i8 @_ZN19custom_variable_xorIaE8do_shiftEaa(i8 signext %6, i8 signext %7)
  %conv = sext i8 %call to i32
  %8 = load i8, i8* %result, align 1
  %conv4 = sext i8 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i8, i8* %result, align 1
  %11 = load i8, i8* %v1.addr, align 1
  call void @_Z26check_shifted_variable_sumIa19custom_variable_xorIaEEvT_S2_(i8 signext %10, i8 signext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ia28custom_multiple_variable_xorIaEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call signext i8 @_ZN28custom_multiple_variable_xorIaE8do_shiftEaaaaa(i8 signext %6, i8 signext %7, i8 signext %8, i8 signext %9, i8 signext %10)
  %conv = sext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = sext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIa28custom_multiple_variable_xorIaEEvT_S2_S2_S2_S2_(i8 signext %13, i8 signext %14, i8 signext %15, i8 signext %16, i8 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr void @_Z4fillIPhhEvT_S1_T0_(i8* %first, i8* %last, i8 zeroext %value) #5 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %last.addr = alloca i8*, align 8
  %value.addr = alloca i8, align 1
  store i8* %first, i8** %first.addr, align 8
  store i8* %last, i8** %last.addr, align 8
  store i8 %value, i8* %value.addr, align 1
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i8*, i8** %first.addr, align 8
  %1 = load i8*, i8** %last.addr, align 8
  %cmp = icmp ne i8* %0, %1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load i8, i8* %value.addr, align 1
  %3 = load i8*, i8** %first.addr, align 8
  %incdec.ptr = getelementptr inbounds i8, i8* %3, i32 1
  store i8* %incdec.ptr, i8** %first.addr, align 8
  store i8 %2, i8* %3, align 1
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %call = call zeroext i8 @_ZN19custom_add_variableIhE8do_shiftEhh(i8 zeroext %6, i8 zeroext %7)
  %conv = zext i8 %call to i32
  %8 = load i8, i8* %result, align 1
  %conv4 = zext i8 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i8, i8* %result, align 1
  %11 = load i8, i8* %v1.addr, align 1
  call void @_Z26check_shifted_variable_sumIh19custom_add_variableIhEEvT_S2_(i8 zeroext %10, i8 zeroext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z22test_hoisted_variable1Ih19custom_add_variableIhEEvPT_iS2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc10, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end12

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %conv = zext i8 %6 to i32
  %7 = load i8, i8* %result, align 1
  %conv4 = zext i8 %7 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %8 = load i32, i32* %n, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %9 = load i32, i32* %count.addr, align 4
  %10 = load i8, i8* %v1.addr, align 1
  %conv6 = zext i8 %10 to i32
  %mul = mul nsw i32 %9, %conv6
  %11 = load i8, i8* %result, align 1
  %conv7 = zext i8 %11 to i32
  %add8 = add nsw i32 %conv7, %mul
  %conv9 = trunc i32 %add8 to i8
  store i8 %conv9, i8* %result, align 1
  %12 = load i8, i8* %result, align 1
  %13 = load i8, i8* %v1.addr, align 1
  call void @_Z26check_shifted_variable_sumIh19custom_add_variableIhEEvT_S2_(i8 zeroext %12, i8 zeroext %13)
  br label %for.inc10

for.inc10:                                        ; preds = %for.end
  %14 = load i32, i32* %i, align 4
  %inc11 = add nsw i32 %14, 1
  store i32 %inc11, i32* %i, align 4
  br label %for.cond

for.end12:                                        ; preds = %for.cond
  %call = call double @_Z5timerv()
  %15 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call, i8* %15)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ih28custom_add_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call zeroext i8 @_ZN28custom_add_multiple_variableIhE8do_shiftEhhhhh(i8 zeroext %6, i8 zeroext %7, i8 zeroext %8, i8 zeroext %9, i8 zeroext %10)
  %conv = zext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = zext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIh28custom_add_multiple_variableIhEEvT_S2_S2_S2_S2_(i8 zeroext %13, i8 zeroext %14, i8 zeroext %15, i8 zeroext %16, i8 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ih19custom_sub_variableIhEEvPT_iS2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %call = call zeroext i8 @_ZN19custom_sub_variableIhE8do_shiftEhh(i8 zeroext %6, i8 zeroext %7)
  %conv = zext i8 %call to i32
  %8 = load i8, i8* %result, align 1
  %conv4 = zext i8 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i8, i8* %result, align 1
  %11 = load i8, i8* %v1.addr, align 1
  call void @_Z26check_shifted_variable_sumIh19custom_sub_variableIhEEvT_S2_(i8 zeroext %10, i8 zeroext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ih28custom_sub_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call zeroext i8 @_ZN28custom_sub_multiple_variableIhE8do_shiftEhhhhh(i8 zeroext %6, i8 zeroext %7, i8 zeroext %8, i8 zeroext %9, i8 zeroext %10)
  %conv = zext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = zext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIh28custom_sub_multiple_variableIhEEvT_S2_S2_S2_S2_(i8 zeroext %13, i8 zeroext %14, i8 zeroext %15, i8 zeroext %16, i8 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ih24custom_multiply_variableIhEEvPT_iS2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %call = call zeroext i8 @_ZN24custom_multiply_variableIhE8do_shiftEhh(i8 zeroext %6, i8 zeroext %7)
  %conv = zext i8 %call to i32
  %8 = load i8, i8* %result, align 1
  %conv4 = zext i8 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i8, i8* %result, align 1
  %11 = load i8, i8* %v1.addr, align 1
  call void @_Z26check_shifted_variable_sumIh24custom_multiply_variableIhEEvT_S2_(i8 zeroext %10, i8 zeroext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ih33custom_multiply_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call zeroext i8 @_ZN33custom_multiply_multiple_variableIhE8do_shiftEhhhhh(i8 zeroext %6, i8 zeroext %7, i8 zeroext %8, i8 zeroext %9, i8 zeroext %10)
  %conv = zext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = zext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIh33custom_multiply_multiple_variableIhEEvT_S2_S2_S2_S2_(i8 zeroext %13, i8 zeroext %14, i8 zeroext %15, i8 zeroext %16, i8 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ih34custom_multiply_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call zeroext i8 @_ZN34custom_multiply_multiple_variable2IhE8do_shiftEhhhhh(i8 zeroext %6, i8 zeroext %7, i8 zeroext %8, i8 zeroext %9, i8 zeroext %10)
  %conv = zext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = zext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIh34custom_multiply_multiple_variable2IhEEvT_S2_S2_S2_S2_(i8 zeroext %13, i8 zeroext %14, i8 zeroext %15, i8 zeroext %16, i8 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ih22custom_divide_variableIhEEvPT_iS2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %call = call zeroext i8 @_ZN22custom_divide_variableIhE8do_shiftEhh(i8 zeroext %6, i8 zeroext %7)
  %conv = zext i8 %call to i32
  %8 = load i8, i8* %result, align 1
  %conv4 = zext i8 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i8, i8* %result, align 1
  %11 = load i8, i8* %v1.addr, align 1
  call void @_Z26check_shifted_variable_sumIh22custom_divide_variableIhEEvT_S2_(i8 zeroext %10, i8 zeroext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ih31custom_divide_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call zeroext i8 @_ZN31custom_divide_multiple_variableIhE8do_shiftEhhhhh(i8 zeroext %6, i8 zeroext %7, i8 zeroext %8, i8 zeroext %9, i8 zeroext %10)
  %conv = zext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = zext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIh31custom_divide_multiple_variableIhEEvT_S2_S2_S2_S2_(i8 zeroext %13, i8 zeroext %14, i8 zeroext %15, i8 zeroext %16, i8 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ih32custom_divide_multiple_variable2IhEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call zeroext i8 @_ZN32custom_divide_multiple_variable2IhE8do_shiftEhhhhh(i8 zeroext %6, i8 zeroext %7, i8 zeroext %8, i8 zeroext %9, i8 zeroext %10)
  %conv = zext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = zext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIh32custom_divide_multiple_variable2IhEEvT_S2_S2_S2_S2_(i8 zeroext %13, i8 zeroext %14, i8 zeroext %15, i8 zeroext %16, i8 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ih30custom_mixed_multiple_variableIhEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call zeroext i8 @_ZN30custom_mixed_multiple_variableIhE8do_shiftEhhhhh(i8 zeroext %6, i8 zeroext %7, i8 zeroext %8, i8 zeroext %9, i8 zeroext %10)
  %conv = zext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = zext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIh30custom_mixed_multiple_variableIhEEvT_S2_S2_S2_S2_(i8 zeroext %13, i8 zeroext %14, i8 zeroext %15, i8 zeroext %16, i8 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ih19custom_variable_andIhEEvPT_iS2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %call = call zeroext i8 @_ZN19custom_variable_andIhE8do_shiftEhh(i8 zeroext %6, i8 zeroext %7)
  %conv = zext i8 %call to i32
  %8 = load i8, i8* %result, align 1
  %conv4 = zext i8 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i8, i8* %result, align 1
  %11 = load i8, i8* %v1.addr, align 1
  call void @_Z26check_shifted_variable_sumIh19custom_variable_andIhEEvT_S2_(i8 zeroext %10, i8 zeroext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ih28custom_multiple_variable_andIhEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call zeroext i8 @_ZN28custom_multiple_variable_andIhE8do_shiftEhhhhh(i8 zeroext %6, i8 zeroext %7, i8 zeroext %8, i8 zeroext %9, i8 zeroext %10)
  %conv = zext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = zext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIh28custom_multiple_variable_andIhEEvT_S2_S2_S2_S2_(i8 zeroext %13, i8 zeroext %14, i8 zeroext %15, i8 zeroext %16, i8 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ih18custom_variable_orIhEEvPT_iS2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %call = call zeroext i8 @_ZN18custom_variable_orIhE8do_shiftEhh(i8 zeroext %6, i8 zeroext %7)
  %conv = zext i8 %call to i32
  %8 = load i8, i8* %result, align 1
  %conv4 = zext i8 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i8, i8* %result, align 1
  %11 = load i8, i8* %v1.addr, align 1
  call void @_Z26check_shifted_variable_sumIh18custom_variable_orIhEEvT_S2_(i8 zeroext %10, i8 zeroext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ih27custom_multiple_variable_orIhEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call zeroext i8 @_ZN27custom_multiple_variable_orIhE8do_shiftEhhhhh(i8 zeroext %6, i8 zeroext %7, i8 zeroext %8, i8 zeroext %9, i8 zeroext %10)
  %conv = zext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = zext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIh27custom_multiple_variable_orIhEEvT_S2_S2_S2_S2_(i8 zeroext %13, i8 zeroext %14, i8 zeroext %15, i8 zeroext %16, i8 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ih19custom_variable_xorIhEEvPT_iS2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %call = call zeroext i8 @_ZN19custom_variable_xorIhE8do_shiftEhh(i8 zeroext %6, i8 zeroext %7)
  %conv = zext i8 %call to i32
  %8 = load i8, i8* %result, align 1
  %conv4 = zext i8 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i8, i8* %result, align 1
  %11 = load i8, i8* %v1.addr, align 1
  call void @_Z26check_shifted_variable_sumIh19custom_variable_xorIhEEvT_S2_(i8 zeroext %10, i8 zeroext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ih28custom_multiple_variable_xorIhEEvPT_iS2_S2_S2_S2_PKc(i8* %first, i32 %count, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i8*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i8, align 1
  %n = alloca i32, align 4
  store i8* %first, i8** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i8 0, i8* %result, align 1
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i8*, i8** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i8, i8* %4, i64 %idxprom
  %6 = load i8, i8* %arrayidx, align 1
  %7 = load i8, i8* %v1.addr, align 1
  %8 = load i8, i8* %v2.addr, align 1
  %9 = load i8, i8* %v3.addr, align 1
  %10 = load i8, i8* %v4.addr, align 1
  %call = call zeroext i8 @_ZN28custom_multiple_variable_xorIhE8do_shiftEhhhhh(i8 zeroext %6, i8 zeroext %7, i8 zeroext %8, i8 zeroext %9, i8 zeroext %10)
  %conv = zext i8 %call to i32
  %11 = load i8, i8* %result, align 1
  %conv4 = zext i8 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i8
  store i8 %conv5, i8* %result, align 1
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i8, i8* %result, align 1
  %14 = load i8, i8* %v1.addr, align 1
  %15 = load i8, i8* %v2.addr, align 1
  %16 = load i8, i8* %v3.addr, align 1
  %17 = load i8, i8* %v4.addr, align 1
  call void @_Z26check_shifted_variable_sumIh28custom_multiple_variable_xorIhEEvT_S2_S2_S2_S2_(i8 zeroext %13, i8 zeroext %14, i8 zeroext %15, i8 zeroext %16, i8 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr void @_Z4fillIPssEvT_S1_T0_(i16* %first, i16* %last, i16 signext %value) #5 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %last.addr = alloca i16*, align 8
  %value.addr = alloca i16, align 2
  store i16* %first, i16** %first.addr, align 8
  store i16* %last, i16** %last.addr, align 8
  store i16 %value, i16* %value.addr, align 2
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i16*, i16** %first.addr, align 8
  %1 = load i16*, i16** %last.addr, align 8
  %cmp = icmp ne i16* %0, %1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load i16, i16* %value.addr, align 2
  %3 = load i16*, i16** %first.addr, align 8
  %incdec.ptr = getelementptr inbounds i16, i16* %3, i32 1
  store i16* %incdec.ptr, i16** %first.addr, align 8
  store i16 %2, i16* %3, align 2
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Is19custom_add_variableIsEEvPT_iS2_PKc(i16* %first, i32 %count, i16 signext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %call = call signext i16 @_ZN19custom_add_variableIsE8do_shiftEss(i16 signext %6, i16 signext %7)
  %conv = sext i16 %call to i32
  %8 = load i16, i16* %result, align 2
  %conv4 = sext i16 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i16, i16* %result, align 2
  %11 = load i16, i16* %v1.addr, align 2
  call void @_Z26check_shifted_variable_sumIs19custom_add_variableIsEEvT_S2_(i16 signext %10, i16 signext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z22test_hoisted_variable1Is19custom_add_variableIsEEvPT_iS2_PKc(i16* %first, i32 %count, i16 signext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc10, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end12

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %conv = sext i16 %6 to i32
  %7 = load i16, i16* %result, align 2
  %conv4 = sext i16 %7 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %8 = load i32, i32* %n, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %9 = load i32, i32* %count.addr, align 4
  %10 = load i16, i16* %v1.addr, align 2
  %conv6 = sext i16 %10 to i32
  %mul = mul nsw i32 %9, %conv6
  %11 = load i16, i16* %result, align 2
  %conv7 = sext i16 %11 to i32
  %add8 = add nsw i32 %conv7, %mul
  %conv9 = trunc i32 %add8 to i16
  store i16 %conv9, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  %13 = load i16, i16* %v1.addr, align 2
  call void @_Z26check_shifted_variable_sumIs19custom_add_variableIsEEvT_S2_(i16 signext %12, i16 signext %13)
  br label %for.inc10

for.inc10:                                        ; preds = %for.end
  %14 = load i32, i32* %i, align 4
  %inc11 = add nsw i32 %14, 1
  store i32 %inc11, i32* %i, align 4
  br label %for.cond

for.end12:                                        ; preds = %for.cond
  %call = call double @_Z5timerv()
  %15 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call, i8* %15)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Is28custom_add_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call signext i16 @_ZN28custom_add_multiple_variableIsE8do_shiftEsssss(i16 signext %6, i16 signext %7, i16 signext %8, i16 signext %9, i16 signext %10)
  %conv = sext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = sext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIs28custom_add_multiple_variableIsEEvT_S2_S2_S2_S2_(i16 signext %13, i16 signext %14, i16 signext %15, i16 signext %16, i16 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Is19custom_sub_variableIsEEvPT_iS2_PKc(i16* %first, i32 %count, i16 signext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %call = call signext i16 @_ZN19custom_sub_variableIsE8do_shiftEss(i16 signext %6, i16 signext %7)
  %conv = sext i16 %call to i32
  %8 = load i16, i16* %result, align 2
  %conv4 = sext i16 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i16, i16* %result, align 2
  %11 = load i16, i16* %v1.addr, align 2
  call void @_Z26check_shifted_variable_sumIs19custom_sub_variableIsEEvT_S2_(i16 signext %10, i16 signext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Is28custom_sub_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call signext i16 @_ZN28custom_sub_multiple_variableIsE8do_shiftEsssss(i16 signext %6, i16 signext %7, i16 signext %8, i16 signext %9, i16 signext %10)
  %conv = sext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = sext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIs28custom_sub_multiple_variableIsEEvT_S2_S2_S2_S2_(i16 signext %13, i16 signext %14, i16 signext %15, i16 signext %16, i16 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Is24custom_multiply_variableIsEEvPT_iS2_PKc(i16* %first, i32 %count, i16 signext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %call = call signext i16 @_ZN24custom_multiply_variableIsE8do_shiftEss(i16 signext %6, i16 signext %7)
  %conv = sext i16 %call to i32
  %8 = load i16, i16* %result, align 2
  %conv4 = sext i16 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i16, i16* %result, align 2
  %11 = load i16, i16* %v1.addr, align 2
  call void @_Z26check_shifted_variable_sumIs24custom_multiply_variableIsEEvT_S2_(i16 signext %10, i16 signext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Is33custom_multiply_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call signext i16 @_ZN33custom_multiply_multiple_variableIsE8do_shiftEsssss(i16 signext %6, i16 signext %7, i16 signext %8, i16 signext %9, i16 signext %10)
  %conv = sext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = sext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIs33custom_multiply_multiple_variableIsEEvT_S2_S2_S2_S2_(i16 signext %13, i16 signext %14, i16 signext %15, i16 signext %16, i16 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Is34custom_multiply_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call signext i16 @_ZN34custom_multiply_multiple_variable2IsE8do_shiftEsssss(i16 signext %6, i16 signext %7, i16 signext %8, i16 signext %9, i16 signext %10)
  %conv = sext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = sext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIs34custom_multiply_multiple_variable2IsEEvT_S2_S2_S2_S2_(i16 signext %13, i16 signext %14, i16 signext %15, i16 signext %16, i16 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Is22custom_divide_variableIsEEvPT_iS2_PKc(i16* %first, i32 %count, i16 signext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %call = call signext i16 @_ZN22custom_divide_variableIsE8do_shiftEss(i16 signext %6, i16 signext %7)
  %conv = sext i16 %call to i32
  %8 = load i16, i16* %result, align 2
  %conv4 = sext i16 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i16, i16* %result, align 2
  %11 = load i16, i16* %v1.addr, align 2
  call void @_Z26check_shifted_variable_sumIs22custom_divide_variableIsEEvT_S2_(i16 signext %10, i16 signext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Is31custom_divide_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call signext i16 @_ZN31custom_divide_multiple_variableIsE8do_shiftEsssss(i16 signext %6, i16 signext %7, i16 signext %8, i16 signext %9, i16 signext %10)
  %conv = sext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = sext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIs31custom_divide_multiple_variableIsEEvT_S2_S2_S2_S2_(i16 signext %13, i16 signext %14, i16 signext %15, i16 signext %16, i16 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Is32custom_divide_multiple_variable2IsEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call signext i16 @_ZN32custom_divide_multiple_variable2IsE8do_shiftEsssss(i16 signext %6, i16 signext %7, i16 signext %8, i16 signext %9, i16 signext %10)
  %conv = sext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = sext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIs32custom_divide_multiple_variable2IsEEvT_S2_S2_S2_S2_(i16 signext %13, i16 signext %14, i16 signext %15, i16 signext %16, i16 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Is30custom_mixed_multiple_variableIsEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call signext i16 @_ZN30custom_mixed_multiple_variableIsE8do_shiftEsssss(i16 signext %6, i16 signext %7, i16 signext %8, i16 signext %9, i16 signext %10)
  %conv = sext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = sext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIs30custom_mixed_multiple_variableIsEEvT_S2_S2_S2_S2_(i16 signext %13, i16 signext %14, i16 signext %15, i16 signext %16, i16 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Is19custom_variable_andIsEEvPT_iS2_PKc(i16* %first, i32 %count, i16 signext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %call = call signext i16 @_ZN19custom_variable_andIsE8do_shiftEss(i16 signext %6, i16 signext %7)
  %conv = sext i16 %call to i32
  %8 = load i16, i16* %result, align 2
  %conv4 = sext i16 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i16, i16* %result, align 2
  %11 = load i16, i16* %v1.addr, align 2
  call void @_Z26check_shifted_variable_sumIs19custom_variable_andIsEEvT_S2_(i16 signext %10, i16 signext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Is28custom_multiple_variable_andIsEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call signext i16 @_ZN28custom_multiple_variable_andIsE8do_shiftEsssss(i16 signext %6, i16 signext %7, i16 signext %8, i16 signext %9, i16 signext %10)
  %conv = sext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = sext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIs28custom_multiple_variable_andIsEEvT_S2_S2_S2_S2_(i16 signext %13, i16 signext %14, i16 signext %15, i16 signext %16, i16 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Is18custom_variable_orIsEEvPT_iS2_PKc(i16* %first, i32 %count, i16 signext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %call = call signext i16 @_ZN18custom_variable_orIsE8do_shiftEss(i16 signext %6, i16 signext %7)
  %conv = sext i16 %call to i32
  %8 = load i16, i16* %result, align 2
  %conv4 = sext i16 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i16, i16* %result, align 2
  %11 = load i16, i16* %v1.addr, align 2
  call void @_Z26check_shifted_variable_sumIs18custom_variable_orIsEEvT_S2_(i16 signext %10, i16 signext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Is27custom_multiple_variable_orIsEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call signext i16 @_ZN27custom_multiple_variable_orIsE8do_shiftEsssss(i16 signext %6, i16 signext %7, i16 signext %8, i16 signext %9, i16 signext %10)
  %conv = sext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = sext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIs27custom_multiple_variable_orIsEEvT_S2_S2_S2_S2_(i16 signext %13, i16 signext %14, i16 signext %15, i16 signext %16, i16 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Is19custom_variable_xorIsEEvPT_iS2_PKc(i16* %first, i32 %count, i16 signext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %call = call signext i16 @_ZN19custom_variable_xorIsE8do_shiftEss(i16 signext %6, i16 signext %7)
  %conv = sext i16 %call to i32
  %8 = load i16, i16* %result, align 2
  %conv4 = sext i16 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i16, i16* %result, align 2
  %11 = load i16, i16* %v1.addr, align 2
  call void @_Z26check_shifted_variable_sumIs19custom_variable_xorIsEEvT_S2_(i16 signext %10, i16 signext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Is28custom_multiple_variable_xorIsEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call signext i16 @_ZN28custom_multiple_variable_xorIsE8do_shiftEsssss(i16 signext %6, i16 signext %7, i16 signext %8, i16 signext %9, i16 signext %10)
  %conv = sext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = sext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIs28custom_multiple_variable_xorIsEEvT_S2_S2_S2_S2_(i16 signext %13, i16 signext %14, i16 signext %15, i16 signext %16, i16 signext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr void @_Z4fillIPttEvT_S1_T0_(i16* %first, i16* %last, i16 zeroext %value) #5 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %last.addr = alloca i16*, align 8
  %value.addr = alloca i16, align 2
  store i16* %first, i16** %first.addr, align 8
  store i16* %last, i16** %last.addr, align 8
  store i16 %value, i16* %value.addr, align 2
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i16*, i16** %first.addr, align 8
  %1 = load i16*, i16** %last.addr, align 8
  %cmp = icmp ne i16* %0, %1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load i16, i16* %value.addr, align 2
  %3 = load i16*, i16** %first.addr, align 8
  %incdec.ptr = getelementptr inbounds i16, i16* %3, i32 1
  store i16* %incdec.ptr, i16** %first.addr, align 8
  store i16 %2, i16* %3, align 2
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1It19custom_add_variableItEEvPT_iS2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %call = call zeroext i16 @_ZN19custom_add_variableItE8do_shiftEtt(i16 zeroext %6, i16 zeroext %7)
  %conv = zext i16 %call to i32
  %8 = load i16, i16* %result, align 2
  %conv4 = zext i16 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i16, i16* %result, align 2
  %11 = load i16, i16* %v1.addr, align 2
  call void @_Z26check_shifted_variable_sumIt19custom_add_variableItEEvT_S2_(i16 zeroext %10, i16 zeroext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z22test_hoisted_variable1It19custom_add_variableItEEvPT_iS2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc10, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end12

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %conv = zext i16 %6 to i32
  %7 = load i16, i16* %result, align 2
  %conv4 = zext i16 %7 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %8 = load i32, i32* %n, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %9 = load i32, i32* %count.addr, align 4
  %10 = load i16, i16* %v1.addr, align 2
  %conv6 = zext i16 %10 to i32
  %mul = mul nsw i32 %9, %conv6
  %11 = load i16, i16* %result, align 2
  %conv7 = zext i16 %11 to i32
  %add8 = add nsw i32 %conv7, %mul
  %conv9 = trunc i32 %add8 to i16
  store i16 %conv9, i16* %result, align 2
  %12 = load i16, i16* %result, align 2
  %13 = load i16, i16* %v1.addr, align 2
  call void @_Z26check_shifted_variable_sumIt19custom_add_variableItEEvT_S2_(i16 zeroext %12, i16 zeroext %13)
  br label %for.inc10

for.inc10:                                        ; preds = %for.end
  %14 = load i32, i32* %i, align 4
  %inc11 = add nsw i32 %14, 1
  store i32 %inc11, i32* %i, align 4
  br label %for.cond

for.end12:                                        ; preds = %for.cond
  %call = call double @_Z5timerv()
  %15 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call, i8* %15)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4It28custom_add_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call zeroext i16 @_ZN28custom_add_multiple_variableItE8do_shiftEttttt(i16 zeroext %6, i16 zeroext %7, i16 zeroext %8, i16 zeroext %9, i16 zeroext %10)
  %conv = zext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = zext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIt28custom_add_multiple_variableItEEvT_S2_S2_S2_S2_(i16 zeroext %13, i16 zeroext %14, i16 zeroext %15, i16 zeroext %16, i16 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1It19custom_sub_variableItEEvPT_iS2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %call = call zeroext i16 @_ZN19custom_sub_variableItE8do_shiftEtt(i16 zeroext %6, i16 zeroext %7)
  %conv = zext i16 %call to i32
  %8 = load i16, i16* %result, align 2
  %conv4 = zext i16 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i16, i16* %result, align 2
  %11 = load i16, i16* %v1.addr, align 2
  call void @_Z26check_shifted_variable_sumIt19custom_sub_variableItEEvT_S2_(i16 zeroext %10, i16 zeroext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4It28custom_sub_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call zeroext i16 @_ZN28custom_sub_multiple_variableItE8do_shiftEttttt(i16 zeroext %6, i16 zeroext %7, i16 zeroext %8, i16 zeroext %9, i16 zeroext %10)
  %conv = zext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = zext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIt28custom_sub_multiple_variableItEEvT_S2_S2_S2_S2_(i16 zeroext %13, i16 zeroext %14, i16 zeroext %15, i16 zeroext %16, i16 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1It24custom_multiply_variableItEEvPT_iS2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %call = call zeroext i16 @_ZN24custom_multiply_variableItE8do_shiftEtt(i16 zeroext %6, i16 zeroext %7)
  %conv = zext i16 %call to i32
  %8 = load i16, i16* %result, align 2
  %conv4 = zext i16 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i16, i16* %result, align 2
  %11 = load i16, i16* %v1.addr, align 2
  call void @_Z26check_shifted_variable_sumIt24custom_multiply_variableItEEvT_S2_(i16 zeroext %10, i16 zeroext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4It33custom_multiply_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call zeroext i16 @_ZN33custom_multiply_multiple_variableItE8do_shiftEttttt(i16 zeroext %6, i16 zeroext %7, i16 zeroext %8, i16 zeroext %9, i16 zeroext %10)
  %conv = zext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = zext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIt33custom_multiply_multiple_variableItEEvT_S2_S2_S2_S2_(i16 zeroext %13, i16 zeroext %14, i16 zeroext %15, i16 zeroext %16, i16 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4It34custom_multiply_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call zeroext i16 @_ZN34custom_multiply_multiple_variable2ItE8do_shiftEttttt(i16 zeroext %6, i16 zeroext %7, i16 zeroext %8, i16 zeroext %9, i16 zeroext %10)
  %conv = zext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = zext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIt34custom_multiply_multiple_variable2ItEEvT_S2_S2_S2_S2_(i16 zeroext %13, i16 zeroext %14, i16 zeroext %15, i16 zeroext %16, i16 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1It22custom_divide_variableItEEvPT_iS2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %call = call zeroext i16 @_ZN22custom_divide_variableItE8do_shiftEtt(i16 zeroext %6, i16 zeroext %7)
  %conv = zext i16 %call to i32
  %8 = load i16, i16* %result, align 2
  %conv4 = zext i16 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i16, i16* %result, align 2
  %11 = load i16, i16* %v1.addr, align 2
  call void @_Z26check_shifted_variable_sumIt22custom_divide_variableItEEvT_S2_(i16 zeroext %10, i16 zeroext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4It31custom_divide_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call zeroext i16 @_ZN31custom_divide_multiple_variableItE8do_shiftEttttt(i16 zeroext %6, i16 zeroext %7, i16 zeroext %8, i16 zeroext %9, i16 zeroext %10)
  %conv = zext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = zext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIt31custom_divide_multiple_variableItEEvT_S2_S2_S2_S2_(i16 zeroext %13, i16 zeroext %14, i16 zeroext %15, i16 zeroext %16, i16 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4It32custom_divide_multiple_variable2ItEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call zeroext i16 @_ZN32custom_divide_multiple_variable2ItE8do_shiftEttttt(i16 zeroext %6, i16 zeroext %7, i16 zeroext %8, i16 zeroext %9, i16 zeroext %10)
  %conv = zext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = zext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIt32custom_divide_multiple_variable2ItEEvT_S2_S2_S2_S2_(i16 zeroext %13, i16 zeroext %14, i16 zeroext %15, i16 zeroext %16, i16 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4It30custom_mixed_multiple_variableItEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call zeroext i16 @_ZN30custom_mixed_multiple_variableItE8do_shiftEttttt(i16 zeroext %6, i16 zeroext %7, i16 zeroext %8, i16 zeroext %9, i16 zeroext %10)
  %conv = zext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = zext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIt30custom_mixed_multiple_variableItEEvT_S2_S2_S2_S2_(i16 zeroext %13, i16 zeroext %14, i16 zeroext %15, i16 zeroext %16, i16 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1It19custom_variable_andItEEvPT_iS2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %call = call zeroext i16 @_ZN19custom_variable_andItE8do_shiftEtt(i16 zeroext %6, i16 zeroext %7)
  %conv = zext i16 %call to i32
  %8 = load i16, i16* %result, align 2
  %conv4 = zext i16 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i16, i16* %result, align 2
  %11 = load i16, i16* %v1.addr, align 2
  call void @_Z26check_shifted_variable_sumIt19custom_variable_andItEEvT_S2_(i16 zeroext %10, i16 zeroext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4It28custom_multiple_variable_andItEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call zeroext i16 @_ZN28custom_multiple_variable_andItE8do_shiftEttttt(i16 zeroext %6, i16 zeroext %7, i16 zeroext %8, i16 zeroext %9, i16 zeroext %10)
  %conv = zext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = zext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIt28custom_multiple_variable_andItEEvT_S2_S2_S2_S2_(i16 zeroext %13, i16 zeroext %14, i16 zeroext %15, i16 zeroext %16, i16 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1It18custom_variable_orItEEvPT_iS2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %call = call zeroext i16 @_ZN18custom_variable_orItE8do_shiftEtt(i16 zeroext %6, i16 zeroext %7)
  %conv = zext i16 %call to i32
  %8 = load i16, i16* %result, align 2
  %conv4 = zext i16 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i16, i16* %result, align 2
  %11 = load i16, i16* %v1.addr, align 2
  call void @_Z26check_shifted_variable_sumIt18custom_variable_orItEEvT_S2_(i16 zeroext %10, i16 zeroext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4It27custom_multiple_variable_orItEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call zeroext i16 @_ZN27custom_multiple_variable_orItE8do_shiftEttttt(i16 zeroext %6, i16 zeroext %7, i16 zeroext %8, i16 zeroext %9, i16 zeroext %10)
  %conv = zext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = zext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIt27custom_multiple_variable_orItEEvT_S2_S2_S2_S2_(i16 zeroext %13, i16 zeroext %14, i16 zeroext %15, i16 zeroext %16, i16 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1It19custom_variable_xorItEEvPT_iS2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %call = call zeroext i16 @_ZN19custom_variable_xorItE8do_shiftEtt(i16 zeroext %6, i16 zeroext %7)
  %conv = zext i16 %call to i32
  %8 = load i16, i16* %result, align 2
  %conv4 = zext i16 %8 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i16, i16* %result, align 2
  %11 = load i16, i16* %v1.addr, align 2
  call void @_Z26check_shifted_variable_sumIt19custom_variable_xorItEEvT_S2_(i16 zeroext %10, i16 zeroext %11)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %12, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4It28custom_multiple_variable_xorItEEvPT_iS2_S2_S2_S2_PKc(i16* %first, i32 %count, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i16*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i16, align 2
  %n = alloca i32, align 4
  store i16* %first, i16** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc6, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end8

for.body:                                         ; preds = %for.cond
  store i16 0, i16* %result, align 2
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i16*, i16** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i16, i16* %4, i64 %idxprom
  %6 = load i16, i16* %arrayidx, align 2
  %7 = load i16, i16* %v1.addr, align 2
  %8 = load i16, i16* %v2.addr, align 2
  %9 = load i16, i16* %v3.addr, align 2
  %10 = load i16, i16* %v4.addr, align 2
  %call = call zeroext i16 @_ZN28custom_multiple_variable_xorItE8do_shiftEttttt(i16 zeroext %6, i16 zeroext %7, i16 zeroext %8, i16 zeroext %9, i16 zeroext %10)
  %conv = zext i16 %call to i32
  %11 = load i16, i16* %result, align 2
  %conv4 = zext i16 %11 to i32
  %add = add nsw i32 %conv4, %conv
  %conv5 = trunc i32 %add to i16
  store i16 %conv5, i16* %result, align 2
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i16, i16* %result, align 2
  %14 = load i16, i16* %v1.addr, align 2
  %15 = load i16, i16* %v2.addr, align 2
  %16 = load i16, i16* %v3.addr, align 2
  %17 = load i16, i16* %v4.addr, align 2
  call void @_Z26check_shifted_variable_sumIt28custom_multiple_variable_xorItEEvT_S2_S2_S2_S2_(i16 zeroext %13, i16 zeroext %14, i16 zeroext %15, i16 zeroext %16, i16 zeroext %17)
  br label %for.inc6

for.inc6:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc7 = add nsw i32 %18, 1
  store i32 %inc7, i32* %i, align 4
  br label %for.cond

for.end8:                                         ; preds = %for.cond
  %call9 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call9, i8* %19)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr void @_Z4fillIPiiEvT_S1_T0_(i32* %first, i32* %last, i32 %value) #5 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %last.addr = alloca i32*, align 8
  %value.addr = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32* %last, i32** %last.addr, align 8
  store i32 %value, i32* %value.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32*, i32** %first.addr, align 8
  %1 = load i32*, i32** %last.addr, align 8
  %cmp = icmp ne i32* %0, %1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load i32, i32* %value.addr, align 4
  %3 = load i32*, i32** %first.addr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %3, i32 1
  store i32* %incdec.ptr, i32** %first.addr, align 8
  store i32 %2, i32* %3, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc(i32* %first, i32 %count, i32 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %call = call i32 @_ZN19custom_add_variableIiE8do_shiftEii(i32 %6, i32 %7)
  %8 = load i32, i32* %result, align 4
  %add = add nsw i32 %8, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i32, i32* %result, align 4
  %11 = load i32, i32* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIi19custom_add_variableIiEEvT_S2_(i32 %10, i32 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z22test_hoisted_variable1Ii19custom_add_variableIiEEvPT_iS2_PKc(i32* %first, i32 %count, i32 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc5, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end7

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %result, align 4
  %add = add nsw i32 %7, %6
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %8 = load i32, i32* %n, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %9 = load i32, i32* %count.addr, align 4
  %10 = load i32, i32* %v1.addr, align 4
  %mul = mul nsw i32 %9, %10
  %11 = load i32, i32* %result, align 4
  %add4 = add nsw i32 %11, %mul
  store i32 %add4, i32* %result, align 4
  %12 = load i32, i32* %result, align 4
  %13 = load i32, i32* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIi19custom_add_variableIiEEvT_S2_(i32 %12, i32 %13)
  br label %for.inc5

for.inc5:                                         ; preds = %for.end
  %14 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %14, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond

for.end7:                                         ; preds = %for.cond
  %call = call double @_Z5timerv()
  %15 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call, i8* %15)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ii28custom_add_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN28custom_add_multiple_variableIiE8do_shiftEiiiii(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add nsw i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIi28custom_add_multiple_variableIiEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ii19custom_sub_variableIiEEvPT_iS2_PKc(i32* %first, i32 %count, i32 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %call = call i32 @_ZN19custom_sub_variableIiE8do_shiftEii(i32 %6, i32 %7)
  %8 = load i32, i32* %result, align 4
  %add = add nsw i32 %8, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i32, i32* %result, align 4
  %11 = load i32, i32* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIi19custom_sub_variableIiEEvT_S2_(i32 %10, i32 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ii28custom_sub_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN28custom_sub_multiple_variableIiE8do_shiftEiiiii(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add nsw i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIi28custom_sub_multiple_variableIiEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ii24custom_multiply_variableIiEEvPT_iS2_PKc(i32* %first, i32 %count, i32 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %call = call i32 @_ZN24custom_multiply_variableIiE8do_shiftEii(i32 %6, i32 %7)
  %8 = load i32, i32* %result, align 4
  %add = add nsw i32 %8, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i32, i32* %result, align 4
  %11 = load i32, i32* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIi24custom_multiply_variableIiEEvT_S2_(i32 %10, i32 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ii33custom_multiply_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN33custom_multiply_multiple_variableIiE8do_shiftEiiiii(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add nsw i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIi33custom_multiply_multiple_variableIiEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ii34custom_multiply_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN34custom_multiply_multiple_variable2IiE8do_shiftEiiiii(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add nsw i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIi34custom_multiply_multiple_variable2IiEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ii22custom_divide_variableIiEEvPT_iS2_PKc(i32* %first, i32 %count, i32 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %call = call i32 @_ZN22custom_divide_variableIiE8do_shiftEii(i32 %6, i32 %7)
  %8 = load i32, i32* %result, align 4
  %add = add nsw i32 %8, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i32, i32* %result, align 4
  %11 = load i32, i32* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIi22custom_divide_variableIiEEvT_S2_(i32 %10, i32 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ii31custom_divide_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN31custom_divide_multiple_variableIiE8do_shiftEiiiii(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add nsw i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIi31custom_divide_multiple_variableIiEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ii32custom_divide_multiple_variable2IiEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN32custom_divide_multiple_variable2IiE8do_shiftEiiiii(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add nsw i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIi32custom_divide_multiple_variable2IiEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ii30custom_mixed_multiple_variableIiEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN30custom_mixed_multiple_variableIiE8do_shiftEiiiii(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add nsw i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIi30custom_mixed_multiple_variableIiEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ii19custom_variable_andIiEEvPT_iS2_PKc(i32* %first, i32 %count, i32 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %call = call i32 @_ZN19custom_variable_andIiE8do_shiftEii(i32 %6, i32 %7)
  %8 = load i32, i32* %result, align 4
  %add = add nsw i32 %8, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i32, i32* %result, align 4
  %11 = load i32, i32* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIi19custom_variable_andIiEEvT_S2_(i32 %10, i32 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ii28custom_multiple_variable_andIiEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN28custom_multiple_variable_andIiE8do_shiftEiiiii(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add nsw i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIi28custom_multiple_variable_andIiEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ii18custom_variable_orIiEEvPT_iS2_PKc(i32* %first, i32 %count, i32 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %call = call i32 @_ZN18custom_variable_orIiE8do_shiftEii(i32 %6, i32 %7)
  %8 = load i32, i32* %result, align 4
  %add = add nsw i32 %8, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i32, i32* %result, align 4
  %11 = load i32, i32* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIi18custom_variable_orIiEEvT_S2_(i32 %10, i32 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ii27custom_multiple_variable_orIiEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN27custom_multiple_variable_orIiE8do_shiftEiiiii(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add nsw i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIi27custom_multiple_variable_orIiEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ii19custom_variable_xorIiEEvPT_iS2_PKc(i32* %first, i32 %count, i32 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %call = call i32 @_ZN19custom_variable_xorIiE8do_shiftEii(i32 %6, i32 %7)
  %8 = load i32, i32* %result, align 4
  %add = add nsw i32 %8, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i32, i32* %result, align 4
  %11 = load i32, i32* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIi19custom_variable_xorIiEEvT_S2_(i32 %10, i32 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ii28custom_multiple_variable_xorIiEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN28custom_multiple_variable_xorIiE8do_shiftEiiiii(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add nsw i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIi28custom_multiple_variable_xorIiEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr void @_Z4fillIPjjEvT_S1_T0_(i32* %first, i32* %last, i32 %value) #5 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %last.addr = alloca i32*, align 8
  %value.addr = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32* %last, i32** %last.addr, align 8
  store i32 %value, i32* %value.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i32*, i32** %first.addr, align 8
  %1 = load i32*, i32** %last.addr, align 8
  %cmp = icmp ne i32* %0, %1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load i32, i32* %value.addr, align 4
  %3 = load i32*, i32** %first.addr, align 8
  %incdec.ptr = getelementptr inbounds i32, i32* %3, i32 1
  store i32* %incdec.ptr, i32** %first.addr, align 8
  store i32 %2, i32* %3, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc(i32* %first, i32 %count, i32 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %call = call i32 @_ZN19custom_add_variableIjE8do_shiftEjj(i32 %6, i32 %7)
  %8 = load i32, i32* %result, align 4
  %add = add i32 %8, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i32, i32* %result, align 4
  %11 = load i32, i32* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIj19custom_add_variableIjEEvT_S2_(i32 %10, i32 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z22test_hoisted_variable1Ij19custom_add_variableIjEEvPT_iS2_PKc(i32* %first, i32 %count, i32 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc5, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end7

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %result, align 4
  %add = add i32 %7, %6
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %8 = load i32, i32* %n, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %9 = load i32, i32* %count.addr, align 4
  %10 = load i32, i32* %v1.addr, align 4
  %mul = mul i32 %9, %10
  %11 = load i32, i32* %result, align 4
  %add4 = add i32 %11, %mul
  store i32 %add4, i32* %result, align 4
  %12 = load i32, i32* %result, align 4
  %13 = load i32, i32* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIj19custom_add_variableIjEEvT_S2_(i32 %12, i32 %13)
  br label %for.inc5

for.inc5:                                         ; preds = %for.end
  %14 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %14, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond

for.end7:                                         ; preds = %for.cond
  %call = call double @_Z5timerv()
  %15 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call, i8* %15)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ij28custom_add_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN28custom_add_multiple_variableIjE8do_shiftEjjjjj(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIj28custom_add_multiple_variableIjEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ij19custom_sub_variableIjEEvPT_iS2_PKc(i32* %first, i32 %count, i32 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %call = call i32 @_ZN19custom_sub_variableIjE8do_shiftEjj(i32 %6, i32 %7)
  %8 = load i32, i32* %result, align 4
  %add = add i32 %8, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i32, i32* %result, align 4
  %11 = load i32, i32* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIj19custom_sub_variableIjEEvT_S2_(i32 %10, i32 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ij28custom_sub_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN28custom_sub_multiple_variableIjE8do_shiftEjjjjj(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIj28custom_sub_multiple_variableIjEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ij24custom_multiply_variableIjEEvPT_iS2_PKc(i32* %first, i32 %count, i32 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %call = call i32 @_ZN24custom_multiply_variableIjE8do_shiftEjj(i32 %6, i32 %7)
  %8 = load i32, i32* %result, align 4
  %add = add i32 %8, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i32, i32* %result, align 4
  %11 = load i32, i32* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIj24custom_multiply_variableIjEEvT_S2_(i32 %10, i32 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ij33custom_multiply_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN33custom_multiply_multiple_variableIjE8do_shiftEjjjjj(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIj33custom_multiply_multiple_variableIjEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ij34custom_multiply_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN34custom_multiply_multiple_variable2IjE8do_shiftEjjjjj(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIj34custom_multiply_multiple_variable2IjEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ij22custom_divide_variableIjEEvPT_iS2_PKc(i32* %first, i32 %count, i32 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %call = call i32 @_ZN22custom_divide_variableIjE8do_shiftEjj(i32 %6, i32 %7)
  %8 = load i32, i32* %result, align 4
  %add = add i32 %8, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i32, i32* %result, align 4
  %11 = load i32, i32* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIj22custom_divide_variableIjEEvT_S2_(i32 %10, i32 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ij31custom_divide_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN31custom_divide_multiple_variableIjE8do_shiftEjjjjj(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIj31custom_divide_multiple_variableIjEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ij32custom_divide_multiple_variable2IjEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN32custom_divide_multiple_variable2IjE8do_shiftEjjjjj(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIj32custom_divide_multiple_variable2IjEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ij30custom_mixed_multiple_variableIjEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN30custom_mixed_multiple_variableIjE8do_shiftEjjjjj(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIj30custom_mixed_multiple_variableIjEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ij19custom_variable_andIjEEvPT_iS2_PKc(i32* %first, i32 %count, i32 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %call = call i32 @_ZN19custom_variable_andIjE8do_shiftEjj(i32 %6, i32 %7)
  %8 = load i32, i32* %result, align 4
  %add = add i32 %8, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i32, i32* %result, align 4
  %11 = load i32, i32* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIj19custom_variable_andIjEEvT_S2_(i32 %10, i32 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ij28custom_multiple_variable_andIjEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN28custom_multiple_variable_andIjE8do_shiftEjjjjj(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIj28custom_multiple_variable_andIjEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ij18custom_variable_orIjEEvPT_iS2_PKc(i32* %first, i32 %count, i32 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %call = call i32 @_ZN18custom_variable_orIjE8do_shiftEjj(i32 %6, i32 %7)
  %8 = load i32, i32* %result, align 4
  %add = add i32 %8, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i32, i32* %result, align 4
  %11 = load i32, i32* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIj18custom_variable_orIjEEvT_S2_(i32 %10, i32 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ij27custom_multiple_variable_orIjEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN27custom_multiple_variable_orIjE8do_shiftEjjjjj(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIj27custom_multiple_variable_orIjEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Ij19custom_variable_xorIjEEvPT_iS2_PKc(i32* %first, i32 %count, i32 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %call = call i32 @_ZN19custom_variable_xorIjE8do_shiftEjj(i32 %6, i32 %7)
  %8 = load i32, i32* %result, align 4
  %add = add i32 %8, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i32, i32* %result, align 4
  %11 = load i32, i32* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIj19custom_variable_xorIjEEvT_S2_(i32 %10, i32 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Ij28custom_multiple_variable_xorIjEEvPT_iS2_S2_S2_S2_PKc(i32* %first, i32 %count, i32 %v1, i32 %v2, i32 %v3, i32 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i32*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i32, align 4
  %n = alloca i32, align 4
  store i32* %first, i32** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i32 0, i32* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i32*, i32** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i32, i32* %4, i64 %idxprom
  %6 = load i32, i32* %arrayidx, align 4
  %7 = load i32, i32* %v1.addr, align 4
  %8 = load i32, i32* %v2.addr, align 4
  %9 = load i32, i32* %v3.addr, align 4
  %10 = load i32, i32* %v4.addr, align 4
  %call = call i32 @_ZN28custom_multiple_variable_xorIjE8do_shiftEjjjjj(i32 %6, i32 %7, i32 %8, i32 %9, i32 %10)
  %11 = load i32, i32* %result, align 4
  %add = add i32 %11, %call
  store i32 %add, i32* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i32, i32* %result, align 4
  %14 = load i32, i32* %v1.addr, align 4
  %15 = load i32, i32* %v2.addr, align 4
  %16 = load i32, i32* %v3.addr, align 4
  %17 = load i32, i32* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIj28custom_multiple_variable_xorIjEEvT_S2_S2_S2_S2_(i32 %13, i32 %14, i32 %15, i32 %16, i32 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr void @_Z4fillIPllEvT_S1_T0_(i64* %first, i64* %last, i64 %value) #5 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %last.addr = alloca i64*, align 8
  %value.addr = alloca i64, align 8
  store i64* %first, i64** %first.addr, align 8
  store i64* %last, i64** %last.addr, align 8
  store i64 %value, i64* %value.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i64*, i64** %first.addr, align 8
  %1 = load i64*, i64** %last.addr, align 8
  %cmp = icmp ne i64* %0, %1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load i64, i64* %value.addr, align 8
  %3 = load i64*, i64** %first.addr, align 8
  %incdec.ptr = getelementptr inbounds i64, i64* %3, i32 1
  store i64* %incdec.ptr, i64** %first.addr, align 8
  store i64 %2, i64* %3, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Il19custom_add_variableIlEEvPT_iS2_PKc(i64* %first, i32 %count, i64 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %call = call i64 @_ZN19custom_add_variableIlE8do_shiftEll(i64 %6, i64 %7)
  %8 = load i64, i64* %result, align 8
  %add = add nsw i64 %8, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i64, i64* %result, align 8
  %11 = load i64, i64* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumIl19custom_add_variableIlEEvT_S2_(i64 %10, i64 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z22test_hoisted_variable1Il19custom_add_variableIlEEvPT_iS2_PKc(i64* %first, i32 %count, i64 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc5, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end7

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %result, align 8
  %add = add nsw i64 %7, %6
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %8 = load i32, i32* %n, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %9 = load i32, i32* %count.addr, align 4
  %conv = sext i32 %9 to i64
  %10 = load i64, i64* %v1.addr, align 8
  %mul = mul nsw i64 %conv, %10
  %11 = load i64, i64* %result, align 8
  %add4 = add nsw i64 %11, %mul
  store i64 %add4, i64* %result, align 8
  %12 = load i64, i64* %result, align 8
  %13 = load i64, i64* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumIl19custom_add_variableIlEEvT_S2_(i64 %12, i64 %13)
  br label %for.inc5

for.inc5:                                         ; preds = %for.end
  %14 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %14, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond

for.end7:                                         ; preds = %for.cond
  %call = call double @_Z5timerv()
  %15 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call, i8* %15)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Il28custom_add_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN28custom_add_multiple_variableIlE8do_shiftElllll(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add nsw i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIl28custom_add_multiple_variableIlEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Il19custom_sub_variableIlEEvPT_iS2_PKc(i64* %first, i32 %count, i64 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %call = call i64 @_ZN19custom_sub_variableIlE8do_shiftEll(i64 %6, i64 %7)
  %8 = load i64, i64* %result, align 8
  %add = add nsw i64 %8, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i64, i64* %result, align 8
  %11 = load i64, i64* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumIl19custom_sub_variableIlEEvT_S2_(i64 %10, i64 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Il28custom_sub_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN28custom_sub_multiple_variableIlE8do_shiftElllll(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add nsw i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIl28custom_sub_multiple_variableIlEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Il24custom_multiply_variableIlEEvPT_iS2_PKc(i64* %first, i32 %count, i64 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %call = call i64 @_ZN24custom_multiply_variableIlE8do_shiftEll(i64 %6, i64 %7)
  %8 = load i64, i64* %result, align 8
  %add = add nsw i64 %8, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i64, i64* %result, align 8
  %11 = load i64, i64* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumIl24custom_multiply_variableIlEEvT_S2_(i64 %10, i64 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Il33custom_multiply_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN33custom_multiply_multiple_variableIlE8do_shiftElllll(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add nsw i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIl33custom_multiply_multiple_variableIlEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Il34custom_multiply_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN34custom_multiply_multiple_variable2IlE8do_shiftElllll(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add nsw i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIl34custom_multiply_multiple_variable2IlEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Il22custom_divide_variableIlEEvPT_iS2_PKc(i64* %first, i32 %count, i64 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %call = call i64 @_ZN22custom_divide_variableIlE8do_shiftEll(i64 %6, i64 %7)
  %8 = load i64, i64* %result, align 8
  %add = add nsw i64 %8, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i64, i64* %result, align 8
  %11 = load i64, i64* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumIl22custom_divide_variableIlEEvT_S2_(i64 %10, i64 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Il31custom_divide_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN31custom_divide_multiple_variableIlE8do_shiftElllll(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add nsw i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIl31custom_divide_multiple_variableIlEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Il32custom_divide_multiple_variable2IlEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN32custom_divide_multiple_variable2IlE8do_shiftElllll(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add nsw i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIl32custom_divide_multiple_variable2IlEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Il30custom_mixed_multiple_variableIlEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN30custom_mixed_multiple_variableIlE8do_shiftElllll(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add nsw i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIl30custom_mixed_multiple_variableIlEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Il19custom_variable_andIlEEvPT_iS2_PKc(i64* %first, i32 %count, i64 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %call = call i64 @_ZN19custom_variable_andIlE8do_shiftEll(i64 %6, i64 %7)
  %8 = load i64, i64* %result, align 8
  %add = add nsw i64 %8, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i64, i64* %result, align 8
  %11 = load i64, i64* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumIl19custom_variable_andIlEEvT_S2_(i64 %10, i64 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Il28custom_multiple_variable_andIlEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN28custom_multiple_variable_andIlE8do_shiftElllll(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add nsw i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIl28custom_multiple_variable_andIlEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Il18custom_variable_orIlEEvPT_iS2_PKc(i64* %first, i32 %count, i64 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %call = call i64 @_ZN18custom_variable_orIlE8do_shiftEll(i64 %6, i64 %7)
  %8 = load i64, i64* %result, align 8
  %add = add nsw i64 %8, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i64, i64* %result, align 8
  %11 = load i64, i64* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumIl18custom_variable_orIlEEvT_S2_(i64 %10, i64 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Il27custom_multiple_variable_orIlEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN27custom_multiple_variable_orIlE8do_shiftElllll(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add nsw i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIl27custom_multiple_variable_orIlEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Il19custom_variable_xorIlEEvPT_iS2_PKc(i64* %first, i32 %count, i64 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %call = call i64 @_ZN19custom_variable_xorIlE8do_shiftEll(i64 %6, i64 %7)
  %8 = load i64, i64* %result, align 8
  %add = add nsw i64 %8, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i64, i64* %result, align 8
  %11 = load i64, i64* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumIl19custom_variable_xorIlEEvT_S2_(i64 %10, i64 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Il28custom_multiple_variable_xorIlEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN28custom_multiple_variable_xorIlE8do_shiftElllll(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add nsw i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIl28custom_multiple_variable_xorIlEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr void @_Z4fillIPmmEvT_S1_T0_(i64* %first, i64* %last, i64 %value) #5 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %last.addr = alloca i64*, align 8
  %value.addr = alloca i64, align 8
  store i64* %first, i64** %first.addr, align 8
  store i64* %last, i64** %last.addr, align 8
  store i64 %value, i64* %value.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load i64*, i64** %first.addr, align 8
  %1 = load i64*, i64** %last.addr, align 8
  %cmp = icmp ne i64* %0, %1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load i64, i64* %value.addr, align 8
  %3 = load i64*, i64** %first.addr, align 8
  %incdec.ptr = getelementptr inbounds i64, i64* %3, i32 1
  store i64* %incdec.ptr, i64** %first.addr, align 8
  store i64 %2, i64* %3, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Im19custom_add_variableImEEvPT_iS2_PKc(i64* %first, i32 %count, i64 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %call = call i64 @_ZN19custom_add_variableImE8do_shiftEmm(i64 %6, i64 %7)
  %8 = load i64, i64* %result, align 8
  %add = add i64 %8, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i64, i64* %result, align 8
  %11 = load i64, i64* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumIm19custom_add_variableImEEvT_S2_(i64 %10, i64 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z22test_hoisted_variable1Im19custom_add_variableImEEvPT_iS2_PKc(i64* %first, i32 %count, i64 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc5, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end7

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %result, align 8
  %add = add i64 %7, %6
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %8 = load i32, i32* %n, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %9 = load i32, i32* %count.addr, align 4
  %conv = sext i32 %9 to i64
  %10 = load i64, i64* %v1.addr, align 8
  %mul = mul i64 %conv, %10
  %11 = load i64, i64* %result, align 8
  %add4 = add i64 %11, %mul
  store i64 %add4, i64* %result, align 8
  %12 = load i64, i64* %result, align 8
  %13 = load i64, i64* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumIm19custom_add_variableImEEvT_S2_(i64 %12, i64 %13)
  br label %for.inc5

for.inc5:                                         ; preds = %for.end
  %14 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %14, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond

for.end7:                                         ; preds = %for.cond
  %call = call double @_Z5timerv()
  %15 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call, i8* %15)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Im28custom_add_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN28custom_add_multiple_variableImE8do_shiftEmmmmm(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIm28custom_add_multiple_variableImEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Im19custom_sub_variableImEEvPT_iS2_PKc(i64* %first, i32 %count, i64 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %call = call i64 @_ZN19custom_sub_variableImE8do_shiftEmm(i64 %6, i64 %7)
  %8 = load i64, i64* %result, align 8
  %add = add i64 %8, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i64, i64* %result, align 8
  %11 = load i64, i64* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumIm19custom_sub_variableImEEvT_S2_(i64 %10, i64 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Im28custom_sub_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN28custom_sub_multiple_variableImE8do_shiftEmmmmm(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIm28custom_sub_multiple_variableImEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Im24custom_multiply_variableImEEvPT_iS2_PKc(i64* %first, i32 %count, i64 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %call = call i64 @_ZN24custom_multiply_variableImE8do_shiftEmm(i64 %6, i64 %7)
  %8 = load i64, i64* %result, align 8
  %add = add i64 %8, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i64, i64* %result, align 8
  %11 = load i64, i64* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumIm24custom_multiply_variableImEEvT_S2_(i64 %10, i64 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Im33custom_multiply_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN33custom_multiply_multiple_variableImE8do_shiftEmmmmm(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIm33custom_multiply_multiple_variableImEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Im34custom_multiply_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN34custom_multiply_multiple_variable2ImE8do_shiftEmmmmm(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIm34custom_multiply_multiple_variable2ImEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Im22custom_divide_variableImEEvPT_iS2_PKc(i64* %first, i32 %count, i64 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %call = call i64 @_ZN22custom_divide_variableImE8do_shiftEmm(i64 %6, i64 %7)
  %8 = load i64, i64* %result, align 8
  %add = add i64 %8, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i64, i64* %result, align 8
  %11 = load i64, i64* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumIm22custom_divide_variableImEEvT_S2_(i64 %10, i64 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Im31custom_divide_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN31custom_divide_multiple_variableImE8do_shiftEmmmmm(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIm31custom_divide_multiple_variableImEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Im32custom_divide_multiple_variable2ImEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN32custom_divide_multiple_variable2ImE8do_shiftEmmmmm(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIm32custom_divide_multiple_variable2ImEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Im30custom_mixed_multiple_variableImEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN30custom_mixed_multiple_variableImE8do_shiftEmmmmm(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIm30custom_mixed_multiple_variableImEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Im19custom_variable_andImEEvPT_iS2_PKc(i64* %first, i32 %count, i64 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %call = call i64 @_ZN19custom_variable_andImE8do_shiftEmm(i64 %6, i64 %7)
  %8 = load i64, i64* %result, align 8
  %add = add i64 %8, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i64, i64* %result, align 8
  %11 = load i64, i64* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumIm19custom_variable_andImEEvT_S2_(i64 %10, i64 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Im28custom_multiple_variable_andImEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN28custom_multiple_variable_andImE8do_shiftEmmmmm(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIm28custom_multiple_variable_andImEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Im18custom_variable_orImEEvPT_iS2_PKc(i64* %first, i32 %count, i64 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %call = call i64 @_ZN18custom_variable_orImE8do_shiftEmm(i64 %6, i64 %7)
  %8 = load i64, i64* %result, align 8
  %add = add i64 %8, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i64, i64* %result, align 8
  %11 = load i64, i64* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumIm18custom_variable_orImEEvT_S2_(i64 %10, i64 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Im27custom_multiple_variable_orImEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN27custom_multiple_variable_orImE8do_shiftEmmmmm(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIm27custom_multiple_variable_orImEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Im19custom_variable_xorImEEvPT_iS2_PKc(i64* %first, i32 %count, i64 %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %call = call i64 @_ZN19custom_variable_xorImE8do_shiftEmm(i64 %6, i64 %7)
  %8 = load i64, i64* %result, align 8
  %add = add i64 %8, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load i64, i64* %result, align 8
  %11 = load i64, i64* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumIm19custom_variable_xorImEEvT_S2_(i64 %10, i64 %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Im28custom_multiple_variable_xorImEEvPT_iS2_S2_S2_S2_PKc(i64* %first, i32 %count, i64 %v1, i64 %v2, i64 %v3, i64 %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca i64*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca i64, align 8
  %n = alloca i32, align 4
  store i64* %first, i64** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store i64 0, i64* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load i64*, i64** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds i64, i64* %4, i64 %idxprom
  %6 = load i64, i64* %arrayidx, align 8
  %7 = load i64, i64* %v1.addr, align 8
  %8 = load i64, i64* %v2.addr, align 8
  %9 = load i64, i64* %v3.addr, align 8
  %10 = load i64, i64* %v4.addr, align 8
  %call = call i64 @_ZN28custom_multiple_variable_xorImE8do_shiftEmmmmm(i64 %6, i64 %7, i64 %8, i64 %9, i64 %10)
  %11 = load i64, i64* %result, align 8
  %add = add i64 %11, %call
  store i64 %add, i64* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load i64, i64* %result, align 8
  %14 = load i64, i64* %v1.addr, align 8
  %15 = load i64, i64* %v2.addr, align 8
  %16 = load i64, i64* %v3.addr, align 8
  %17 = load i64, i64* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumIm28custom_multiple_variable_xorImEEvT_S2_S2_S2_S2_(i64 %13, i64 %14, i64 %15, i64 %16, i64 %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr void @_Z4fillIPffEvT_S1_T0_(float* %first, float* %last, float %value) #5 comdat {
entry:
  %first.addr = alloca float*, align 8
  %last.addr = alloca float*, align 8
  %value.addr = alloca float, align 4
  store float* %first, float** %first.addr, align 8
  store float* %last, float** %last.addr, align 8
  store float %value, float* %value.addr, align 4
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load float*, float** %first.addr, align 8
  %1 = load float*, float** %last.addr, align 8
  %cmp = icmp ne float* %0, %1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load float, float* %value.addr, align 4
  %3 = load float*, float** %first.addr, align 8
  %incdec.ptr = getelementptr inbounds float, float* %3, i32 1
  store float* %incdec.ptr, float** %first.addr, align 8
  store float %2, float* %3, align 4
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1If19custom_add_variableIfEEvPT_iS2_PKc(float* %first, i32 %count, float %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca float*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca float, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca float, align 4
  %n = alloca i32, align 4
  store float* %first, float** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store float 0.000000e+00, float* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load float*, float** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds float, float* %4, i64 %idxprom
  %6 = load float, float* %arrayidx, align 4
  %7 = load float, float* %v1.addr, align 4
  %call = call float @_ZN19custom_add_variableIfE8do_shiftEff(float %6, float %7)
  %8 = load float, float* %result, align 4
  %add = fadd float %8, %call
  store float %add, float* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load float, float* %result, align 4
  %11 = load float, float* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIf19custom_add_variableIfEEvT_S2_(float %10, float %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z22test_hoisted_variable1If19custom_add_variableIfEEvPT_iS2_PKc(float* %first, i32 %count, float %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca float*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca float, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca float, align 4
  %n = alloca i32, align 4
  store float* %first, float** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc5, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end7

for.body:                                         ; preds = %for.cond
  store float 0.000000e+00, float* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load float*, float** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds float, float* %4, i64 %idxprom
  %6 = load float, float* %arrayidx, align 4
  %7 = load float, float* %result, align 4
  %add = fadd float %7, %6
  store float %add, float* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %8 = load i32, i32* %n, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %9 = load i32, i32* %count.addr, align 4
  %conv = sitofp i32 %9 to float
  %10 = load float, float* %v1.addr, align 4
  %mul = fmul float %conv, %10
  %11 = load float, float* %result, align 4
  %add4 = fadd float %11, %mul
  store float %add4, float* %result, align 4
  %12 = load float, float* %result, align 4
  %13 = load float, float* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIf19custom_add_variableIfEEvT_S2_(float %12, float %13)
  br label %for.inc5

for.inc5:                                         ; preds = %for.end
  %14 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %14, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond

for.end7:                                         ; preds = %for.cond
  %call = call double @_Z5timerv()
  %15 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call, i8* %15)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4If28custom_add_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(float* %first, i32 %count, float %v1, float %v2, float %v3, float %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca float*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca float, align 4
  %v2.addr = alloca float, align 4
  %v3.addr = alloca float, align 4
  %v4.addr = alloca float, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca float, align 4
  %n = alloca i32, align 4
  store float* %first, float** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store float %v2, float* %v2.addr, align 4
  store float %v3, float* %v3.addr, align 4
  store float %v4, float* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store float 0.000000e+00, float* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load float*, float** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds float, float* %4, i64 %idxprom
  %6 = load float, float* %arrayidx, align 4
  %7 = load float, float* %v1.addr, align 4
  %8 = load float, float* %v2.addr, align 4
  %9 = load float, float* %v3.addr, align 4
  %10 = load float, float* %v4.addr, align 4
  %call = call float @_ZN28custom_add_multiple_variableIfE8do_shiftEfffff(float %6, float %7, float %8, float %9, float %10)
  %11 = load float, float* %result, align 4
  %add = fadd float %11, %call
  store float %add, float* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load float, float* %result, align 4
  %14 = load float, float* %v1.addr, align 4
  %15 = load float, float* %v2.addr, align 4
  %16 = load float, float* %v3.addr, align 4
  %17 = load float, float* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIf28custom_add_multiple_variableIfEEvT_S2_S2_S2_S2_(float %13, float %14, float %15, float %16, float %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1If19custom_sub_variableIfEEvPT_iS2_PKc(float* %first, i32 %count, float %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca float*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca float, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca float, align 4
  %n = alloca i32, align 4
  store float* %first, float** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store float 0.000000e+00, float* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load float*, float** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds float, float* %4, i64 %idxprom
  %6 = load float, float* %arrayidx, align 4
  %7 = load float, float* %v1.addr, align 4
  %call = call float @_ZN19custom_sub_variableIfE8do_shiftEff(float %6, float %7)
  %8 = load float, float* %result, align 4
  %add = fadd float %8, %call
  store float %add, float* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load float, float* %result, align 4
  %11 = load float, float* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIf19custom_sub_variableIfEEvT_S2_(float %10, float %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4If28custom_sub_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(float* %first, i32 %count, float %v1, float %v2, float %v3, float %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca float*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca float, align 4
  %v2.addr = alloca float, align 4
  %v3.addr = alloca float, align 4
  %v4.addr = alloca float, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca float, align 4
  %n = alloca i32, align 4
  store float* %first, float** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store float %v2, float* %v2.addr, align 4
  store float %v3, float* %v3.addr, align 4
  store float %v4, float* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store float 0.000000e+00, float* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load float*, float** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds float, float* %4, i64 %idxprom
  %6 = load float, float* %arrayidx, align 4
  %7 = load float, float* %v1.addr, align 4
  %8 = load float, float* %v2.addr, align 4
  %9 = load float, float* %v3.addr, align 4
  %10 = load float, float* %v4.addr, align 4
  %call = call float @_ZN28custom_sub_multiple_variableIfE8do_shiftEfffff(float %6, float %7, float %8, float %9, float %10)
  %11 = load float, float* %result, align 4
  %add = fadd float %11, %call
  store float %add, float* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load float, float* %result, align 4
  %14 = load float, float* %v1.addr, align 4
  %15 = load float, float* %v2.addr, align 4
  %16 = load float, float* %v3.addr, align 4
  %17 = load float, float* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIf28custom_sub_multiple_variableIfEEvT_S2_S2_S2_S2_(float %13, float %14, float %15, float %16, float %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1If24custom_multiply_variableIfEEvPT_iS2_PKc(float* %first, i32 %count, float %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca float*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca float, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca float, align 4
  %n = alloca i32, align 4
  store float* %first, float** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store float 0.000000e+00, float* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load float*, float** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds float, float* %4, i64 %idxprom
  %6 = load float, float* %arrayidx, align 4
  %7 = load float, float* %v1.addr, align 4
  %call = call float @_ZN24custom_multiply_variableIfE8do_shiftEff(float %6, float %7)
  %8 = load float, float* %result, align 4
  %add = fadd float %8, %call
  store float %add, float* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load float, float* %result, align 4
  %11 = load float, float* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIf24custom_multiply_variableIfEEvT_S2_(float %10, float %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4If33custom_multiply_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(float* %first, i32 %count, float %v1, float %v2, float %v3, float %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca float*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca float, align 4
  %v2.addr = alloca float, align 4
  %v3.addr = alloca float, align 4
  %v4.addr = alloca float, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca float, align 4
  %n = alloca i32, align 4
  store float* %first, float** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store float %v2, float* %v2.addr, align 4
  store float %v3, float* %v3.addr, align 4
  store float %v4, float* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store float 0.000000e+00, float* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load float*, float** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds float, float* %4, i64 %idxprom
  %6 = load float, float* %arrayidx, align 4
  %7 = load float, float* %v1.addr, align 4
  %8 = load float, float* %v2.addr, align 4
  %9 = load float, float* %v3.addr, align 4
  %10 = load float, float* %v4.addr, align 4
  %call = call float @_ZN33custom_multiply_multiple_variableIfE8do_shiftEfffff(float %6, float %7, float %8, float %9, float %10)
  %11 = load float, float* %result, align 4
  %add = fadd float %11, %call
  store float %add, float* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load float, float* %result, align 4
  %14 = load float, float* %v1.addr, align 4
  %15 = load float, float* %v2.addr, align 4
  %16 = load float, float* %v3.addr, align 4
  %17 = load float, float* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIf33custom_multiply_multiple_variableIfEEvT_S2_S2_S2_S2_(float %13, float %14, float %15, float %16, float %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4If34custom_multiply_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc(float* %first, i32 %count, float %v1, float %v2, float %v3, float %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca float*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca float, align 4
  %v2.addr = alloca float, align 4
  %v3.addr = alloca float, align 4
  %v4.addr = alloca float, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca float, align 4
  %n = alloca i32, align 4
  store float* %first, float** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store float %v2, float* %v2.addr, align 4
  store float %v3, float* %v3.addr, align 4
  store float %v4, float* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store float 0.000000e+00, float* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load float*, float** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds float, float* %4, i64 %idxprom
  %6 = load float, float* %arrayidx, align 4
  %7 = load float, float* %v1.addr, align 4
  %8 = load float, float* %v2.addr, align 4
  %9 = load float, float* %v3.addr, align 4
  %10 = load float, float* %v4.addr, align 4
  %call = call float @_ZN34custom_multiply_multiple_variable2IfE8do_shiftEfffff(float %6, float %7, float %8, float %9, float %10)
  %11 = load float, float* %result, align 4
  %add = fadd float %11, %call
  store float %add, float* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load float, float* %result, align 4
  %14 = load float, float* %v1.addr, align 4
  %15 = load float, float* %v2.addr, align 4
  %16 = load float, float* %v3.addr, align 4
  %17 = load float, float* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIf34custom_multiply_multiple_variable2IfEEvT_S2_S2_S2_S2_(float %13, float %14, float %15, float %16, float %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1If22custom_divide_variableIfEEvPT_iS2_PKc(float* %first, i32 %count, float %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca float*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca float, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca float, align 4
  %n = alloca i32, align 4
  store float* %first, float** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store float 0.000000e+00, float* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load float*, float** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds float, float* %4, i64 %idxprom
  %6 = load float, float* %arrayidx, align 4
  %7 = load float, float* %v1.addr, align 4
  %call = call float @_ZN22custom_divide_variableIfE8do_shiftEff(float %6, float %7)
  %8 = load float, float* %result, align 4
  %add = fadd float %8, %call
  store float %add, float* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load float, float* %result, align 4
  %11 = load float, float* %v1.addr, align 4
  call void @_Z26check_shifted_variable_sumIf22custom_divide_variableIfEEvT_S2_(float %10, float %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4If31custom_divide_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(float* %first, i32 %count, float %v1, float %v2, float %v3, float %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca float*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca float, align 4
  %v2.addr = alloca float, align 4
  %v3.addr = alloca float, align 4
  %v4.addr = alloca float, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca float, align 4
  %n = alloca i32, align 4
  store float* %first, float** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store float %v2, float* %v2.addr, align 4
  store float %v3, float* %v3.addr, align 4
  store float %v4, float* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store float 0.000000e+00, float* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load float*, float** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds float, float* %4, i64 %idxprom
  %6 = load float, float* %arrayidx, align 4
  %7 = load float, float* %v1.addr, align 4
  %8 = load float, float* %v2.addr, align 4
  %9 = load float, float* %v3.addr, align 4
  %10 = load float, float* %v4.addr, align 4
  %call = call float @_ZN31custom_divide_multiple_variableIfE8do_shiftEfffff(float %6, float %7, float %8, float %9, float %10)
  %11 = load float, float* %result, align 4
  %add = fadd float %11, %call
  store float %add, float* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load float, float* %result, align 4
  %14 = load float, float* %v1.addr, align 4
  %15 = load float, float* %v2.addr, align 4
  %16 = load float, float* %v3.addr, align 4
  %17 = load float, float* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIf31custom_divide_multiple_variableIfEEvT_S2_S2_S2_S2_(float %13, float %14, float %15, float %16, float %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4If32custom_divide_multiple_variable2IfEEvPT_iS2_S2_S2_S2_PKc(float* %first, i32 %count, float %v1, float %v2, float %v3, float %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca float*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca float, align 4
  %v2.addr = alloca float, align 4
  %v3.addr = alloca float, align 4
  %v4.addr = alloca float, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca float, align 4
  %n = alloca i32, align 4
  store float* %first, float** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store float %v2, float* %v2.addr, align 4
  store float %v3, float* %v3.addr, align 4
  store float %v4, float* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store float 0.000000e+00, float* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load float*, float** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds float, float* %4, i64 %idxprom
  %6 = load float, float* %arrayidx, align 4
  %7 = load float, float* %v1.addr, align 4
  %8 = load float, float* %v2.addr, align 4
  %9 = load float, float* %v3.addr, align 4
  %10 = load float, float* %v4.addr, align 4
  %call = call float @_ZN32custom_divide_multiple_variable2IfE8do_shiftEfffff(float %6, float %7, float %8, float %9, float %10)
  %11 = load float, float* %result, align 4
  %add = fadd float %11, %call
  store float %add, float* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load float, float* %result, align 4
  %14 = load float, float* %v1.addr, align 4
  %15 = load float, float* %v2.addr, align 4
  %16 = load float, float* %v3.addr, align 4
  %17 = load float, float* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIf32custom_divide_multiple_variable2IfEEvT_S2_S2_S2_S2_(float %13, float %14, float %15, float %16, float %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4If30custom_mixed_multiple_variableIfEEvPT_iS2_S2_S2_S2_PKc(float* %first, i32 %count, float %v1, float %v2, float %v3, float %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca float*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca float, align 4
  %v2.addr = alloca float, align 4
  %v3.addr = alloca float, align 4
  %v4.addr = alloca float, align 4
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca float, align 4
  %n = alloca i32, align 4
  store float* %first, float** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store float %v2, float* %v2.addr, align 4
  store float %v3, float* %v3.addr, align 4
  store float %v4, float* %v4.addr, align 4
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store float 0.000000e+00, float* %result, align 4
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load float*, float** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds float, float* %4, i64 %idxprom
  %6 = load float, float* %arrayidx, align 4
  %7 = load float, float* %v1.addr, align 4
  %8 = load float, float* %v2.addr, align 4
  %9 = load float, float* %v3.addr, align 4
  %10 = load float, float* %v4.addr, align 4
  %call = call float @_ZN30custom_mixed_multiple_variableIfE8do_shiftEfffff(float %6, float %7, float %8, float %9, float %10)
  %11 = load float, float* %result, align 4
  %add = fadd float %11, %call
  store float %add, float* %result, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load float, float* %result, align 4
  %14 = load float, float* %v1.addr, align 4
  %15 = load float, float* %v2.addr, align 4
  %16 = load float, float* %v3.addr, align 4
  %17 = load float, float* %v4.addr, align 4
  call void @_Z26check_shifted_variable_sumIf30custom_mixed_multiple_variableIfEEvT_S2_S2_S2_S2_(float %13, float %14, float %15, float %16, float %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr void @_Z4fillIPddEvT_S1_T0_(double* %first, double* %last, double %value) #5 comdat {
entry:
  %first.addr = alloca double*, align 8
  %last.addr = alloca double*, align 8
  %value.addr = alloca double, align 8
  store double* %first, double** %first.addr, align 8
  store double* %last, double** %last.addr, align 8
  store double %value, double* %value.addr, align 8
  br label %while.cond

while.cond:                                       ; preds = %while.body, %entry
  %0 = load double*, double** %first.addr, align 8
  %1 = load double*, double** %last.addr, align 8
  %cmp = icmp ne double* %0, %1
  br i1 %cmp, label %while.body, label %while.end

while.body:                                       ; preds = %while.cond
  %2 = load double, double* %value.addr, align 8
  %3 = load double*, double** %first.addr, align 8
  %incdec.ptr = getelementptr inbounds double, double* %3, i32 1
  store double* %incdec.ptr, double** %first.addr, align 8
  store double %2, double* %3, align 8
  br label %while.cond

while.end:                                        ; preds = %while.cond
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Id19custom_add_variableIdEEvPT_iS2_PKc(double* %first, i32 %count, double %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca double*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca double, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca double, align 8
  %n = alloca i32, align 4
  store double* %first, double** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store double %v1, double* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store double 0.000000e+00, double* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load double*, double** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds double, double* %4, i64 %idxprom
  %6 = load double, double* %arrayidx, align 8
  %7 = load double, double* %v1.addr, align 8
  %call = call double @_ZN19custom_add_variableIdE8do_shiftEdd(double %6, double %7)
  %8 = load double, double* %result, align 8
  %add = fadd double %8, %call
  store double %add, double* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load double, double* %result, align 8
  %11 = load double, double* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumId19custom_add_variableIdEEvT_S2_(double %10, double %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z22test_hoisted_variable1Id19custom_add_variableIdEEvPT_iS2_PKc(double* %first, i32 %count, double %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca double*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca double, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca double, align 8
  %n = alloca i32, align 4
  store double* %first, double** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store double %v1, double* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc5, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end7

for.body:                                         ; preds = %for.cond
  store double 0.000000e+00, double* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load double*, double** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds double, double* %4, i64 %idxprom
  %6 = load double, double* %arrayidx, align 8
  %7 = load double, double* %result, align 8
  %add = fadd double %7, %6
  store double %add, double* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %8 = load i32, i32* %n, align 4
  %inc = add nsw i32 %8, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %9 = load i32, i32* %count.addr, align 4
  %conv = sitofp i32 %9 to double
  %10 = load double, double* %v1.addr, align 8
  %mul = fmul double %conv, %10
  %11 = load double, double* %result, align 8
  %add4 = fadd double %11, %mul
  store double %add4, double* %result, align 8
  %12 = load double, double* %result, align 8
  %13 = load double, double* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumId19custom_add_variableIdEEvT_S2_(double %12, double %13)
  br label %for.inc5

for.inc5:                                         ; preds = %for.end
  %14 = load i32, i32* %i, align 4
  %inc6 = add nsw i32 %14, 1
  store i32 %inc6, i32* %i, align 4
  br label %for.cond

for.end7:                                         ; preds = %for.cond
  %call = call double @_Z5timerv()
  %15 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call, i8* %15)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Id28custom_add_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(double* %first, i32 %count, double %v1, double %v2, double %v3, double %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca double*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca double, align 8
  %v2.addr = alloca double, align 8
  %v3.addr = alloca double, align 8
  %v4.addr = alloca double, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca double, align 8
  %n = alloca i32, align 4
  store double* %first, double** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store double %v1, double* %v1.addr, align 8
  store double %v2, double* %v2.addr, align 8
  store double %v3, double* %v3.addr, align 8
  store double %v4, double* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store double 0.000000e+00, double* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load double*, double** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds double, double* %4, i64 %idxprom
  %6 = load double, double* %arrayidx, align 8
  %7 = load double, double* %v1.addr, align 8
  %8 = load double, double* %v2.addr, align 8
  %9 = load double, double* %v3.addr, align 8
  %10 = load double, double* %v4.addr, align 8
  %call = call double @_ZN28custom_add_multiple_variableIdE8do_shiftEddddd(double %6, double %7, double %8, double %9, double %10)
  %11 = load double, double* %result, align 8
  %add = fadd double %11, %call
  store double %add, double* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load double, double* %result, align 8
  %14 = load double, double* %v1.addr, align 8
  %15 = load double, double* %v2.addr, align 8
  %16 = load double, double* %v3.addr, align 8
  %17 = load double, double* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumId28custom_add_multiple_variableIdEEvT_S2_S2_S2_S2_(double %13, double %14, double %15, double %16, double %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Id19custom_sub_variableIdEEvPT_iS2_PKc(double* %first, i32 %count, double %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca double*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca double, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca double, align 8
  %n = alloca i32, align 4
  store double* %first, double** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store double %v1, double* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store double 0.000000e+00, double* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load double*, double** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds double, double* %4, i64 %idxprom
  %6 = load double, double* %arrayidx, align 8
  %7 = load double, double* %v1.addr, align 8
  %call = call double @_ZN19custom_sub_variableIdE8do_shiftEdd(double %6, double %7)
  %8 = load double, double* %result, align 8
  %add = fadd double %8, %call
  store double %add, double* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load double, double* %result, align 8
  %11 = load double, double* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumId19custom_sub_variableIdEEvT_S2_(double %10, double %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Id28custom_sub_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(double* %first, i32 %count, double %v1, double %v2, double %v3, double %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca double*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca double, align 8
  %v2.addr = alloca double, align 8
  %v3.addr = alloca double, align 8
  %v4.addr = alloca double, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca double, align 8
  %n = alloca i32, align 4
  store double* %first, double** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store double %v1, double* %v1.addr, align 8
  store double %v2, double* %v2.addr, align 8
  store double %v3, double* %v3.addr, align 8
  store double %v4, double* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store double 0.000000e+00, double* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load double*, double** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds double, double* %4, i64 %idxprom
  %6 = load double, double* %arrayidx, align 8
  %7 = load double, double* %v1.addr, align 8
  %8 = load double, double* %v2.addr, align 8
  %9 = load double, double* %v3.addr, align 8
  %10 = load double, double* %v4.addr, align 8
  %call = call double @_ZN28custom_sub_multiple_variableIdE8do_shiftEddddd(double %6, double %7, double %8, double %9, double %10)
  %11 = load double, double* %result, align 8
  %add = fadd double %11, %call
  store double %add, double* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load double, double* %result, align 8
  %14 = load double, double* %v1.addr, align 8
  %15 = load double, double* %v2.addr, align 8
  %16 = load double, double* %v3.addr, align 8
  %17 = load double, double* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumId28custom_sub_multiple_variableIdEEvT_S2_S2_S2_S2_(double %13, double %14, double %15, double %16, double %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Id24custom_multiply_variableIdEEvPT_iS2_PKc(double* %first, i32 %count, double %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca double*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca double, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca double, align 8
  %n = alloca i32, align 4
  store double* %first, double** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store double %v1, double* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store double 0.000000e+00, double* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load double*, double** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds double, double* %4, i64 %idxprom
  %6 = load double, double* %arrayidx, align 8
  %7 = load double, double* %v1.addr, align 8
  %call = call double @_ZN24custom_multiply_variableIdE8do_shiftEdd(double %6, double %7)
  %8 = load double, double* %result, align 8
  %add = fadd double %8, %call
  store double %add, double* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load double, double* %result, align 8
  %11 = load double, double* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumId24custom_multiply_variableIdEEvT_S2_(double %10, double %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Id33custom_multiply_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(double* %first, i32 %count, double %v1, double %v2, double %v3, double %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca double*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca double, align 8
  %v2.addr = alloca double, align 8
  %v3.addr = alloca double, align 8
  %v4.addr = alloca double, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca double, align 8
  %n = alloca i32, align 4
  store double* %first, double** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store double %v1, double* %v1.addr, align 8
  store double %v2, double* %v2.addr, align 8
  store double %v3, double* %v3.addr, align 8
  store double %v4, double* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store double 0.000000e+00, double* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load double*, double** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds double, double* %4, i64 %idxprom
  %6 = load double, double* %arrayidx, align 8
  %7 = load double, double* %v1.addr, align 8
  %8 = load double, double* %v2.addr, align 8
  %9 = load double, double* %v3.addr, align 8
  %10 = load double, double* %v4.addr, align 8
  %call = call double @_ZN33custom_multiply_multiple_variableIdE8do_shiftEddddd(double %6, double %7, double %8, double %9, double %10)
  %11 = load double, double* %result, align 8
  %add = fadd double %11, %call
  store double %add, double* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load double, double* %result, align 8
  %14 = load double, double* %v1.addr, align 8
  %15 = load double, double* %v2.addr, align 8
  %16 = load double, double* %v3.addr, align 8
  %17 = load double, double* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumId33custom_multiply_multiple_variableIdEEvT_S2_S2_S2_S2_(double %13, double %14, double %15, double %16, double %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Id34custom_multiply_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc(double* %first, i32 %count, double %v1, double %v2, double %v3, double %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca double*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca double, align 8
  %v2.addr = alloca double, align 8
  %v3.addr = alloca double, align 8
  %v4.addr = alloca double, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca double, align 8
  %n = alloca i32, align 4
  store double* %first, double** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store double %v1, double* %v1.addr, align 8
  store double %v2, double* %v2.addr, align 8
  store double %v3, double* %v3.addr, align 8
  store double %v4, double* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store double 0.000000e+00, double* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load double*, double** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds double, double* %4, i64 %idxprom
  %6 = load double, double* %arrayidx, align 8
  %7 = load double, double* %v1.addr, align 8
  %8 = load double, double* %v2.addr, align 8
  %9 = load double, double* %v3.addr, align 8
  %10 = load double, double* %v4.addr, align 8
  %call = call double @_ZN34custom_multiply_multiple_variable2IdE8do_shiftEddddd(double %6, double %7, double %8, double %9, double %10)
  %11 = load double, double* %result, align 8
  %add = fadd double %11, %call
  store double %add, double* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load double, double* %result, align 8
  %14 = load double, double* %v1.addr, align 8
  %15 = load double, double* %v2.addr, align 8
  %16 = load double, double* %v3.addr, align 8
  %17 = load double, double* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumId34custom_multiply_multiple_variable2IdEEvT_S2_S2_S2_S2_(double %13, double %14, double %15, double %16, double %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable1Id22custom_divide_variableIdEEvPT_iS2_PKc(double* %first, i32 %count, double %v1, i8* %label) #0 comdat {
entry:
  %first.addr = alloca double*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca double, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca double, align 8
  %n = alloca i32, align 4
  store double* %first, double** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store double %v1, double* %v1.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store double 0.000000e+00, double* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load double*, double** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds double, double* %4, i64 %idxprom
  %6 = load double, double* %arrayidx, align 8
  %7 = load double, double* %v1.addr, align 8
  %call = call double @_ZN22custom_divide_variableIdE8do_shiftEdd(double %6, double %7)
  %8 = load double, double* %result, align 8
  %add = fadd double %8, %call
  store double %add, double* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %9 = load i32, i32* %n, align 4
  %inc = add nsw i32 %9, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %10 = load double, double* %result, align 8
  %11 = load double, double* %v1.addr, align 8
  call void @_Z26check_shifted_variable_sumId22custom_divide_variableIdEEvT_S2_(double %10, double %11)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %12 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %12, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %13 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %13)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Id31custom_divide_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(double* %first, i32 %count, double %v1, double %v2, double %v3, double %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca double*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca double, align 8
  %v2.addr = alloca double, align 8
  %v3.addr = alloca double, align 8
  %v4.addr = alloca double, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca double, align 8
  %n = alloca i32, align 4
  store double* %first, double** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store double %v1, double* %v1.addr, align 8
  store double %v2, double* %v2.addr, align 8
  store double %v3, double* %v3.addr, align 8
  store double %v4, double* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store double 0.000000e+00, double* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load double*, double** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds double, double* %4, i64 %idxprom
  %6 = load double, double* %arrayidx, align 8
  %7 = load double, double* %v1.addr, align 8
  %8 = load double, double* %v2.addr, align 8
  %9 = load double, double* %v3.addr, align 8
  %10 = load double, double* %v4.addr, align 8
  %call = call double @_ZN31custom_divide_multiple_variableIdE8do_shiftEddddd(double %6, double %7, double %8, double %9, double %10)
  %11 = load double, double* %result, align 8
  %add = fadd double %11, %call
  store double %add, double* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load double, double* %result, align 8
  %14 = load double, double* %v1.addr, align 8
  %15 = load double, double* %v2.addr, align 8
  %16 = load double, double* %v3.addr, align 8
  %17 = load double, double* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumId31custom_divide_multiple_variableIdEEvT_S2_S2_S2_S2_(double %13, double %14, double %15, double %16, double %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Id32custom_divide_multiple_variable2IdEEvPT_iS2_S2_S2_S2_PKc(double* %first, i32 %count, double %v1, double %v2, double %v3, double %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca double*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca double, align 8
  %v2.addr = alloca double, align 8
  %v3.addr = alloca double, align 8
  %v4.addr = alloca double, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca double, align 8
  %n = alloca i32, align 4
  store double* %first, double** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store double %v1, double* %v1.addr, align 8
  store double %v2, double* %v2.addr, align 8
  store double %v3, double* %v3.addr, align 8
  store double %v4, double* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store double 0.000000e+00, double* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load double*, double** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds double, double* %4, i64 %idxprom
  %6 = load double, double* %arrayidx, align 8
  %7 = load double, double* %v1.addr, align 8
  %8 = load double, double* %v2.addr, align 8
  %9 = load double, double* %v3.addr, align 8
  %10 = load double, double* %v4.addr, align 8
  %call = call double @_ZN32custom_divide_multiple_variable2IdE8do_shiftEddddd(double %6, double %7, double %8, double %9, double %10)
  %11 = load double, double* %result, align 8
  %add = fadd double %11, %call
  store double %add, double* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load double, double* %result, align 8
  %14 = load double, double* %v1.addr, align 8
  %15 = load double, double* %v2.addr, align 8
  %16 = load double, double* %v3.addr, align 8
  %17 = load double, double* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumId32custom_divide_multiple_variable2IdEEvT_S2_S2_S2_S2_(double %13, double %14, double %15, double %16, double %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z14test_variable4Id30custom_mixed_multiple_variableIdEEvPT_iS2_S2_S2_S2_PKc(double* %first, i32 %count, double %v1, double %v2, double %v3, double %v4, i8* %label) #0 comdat {
entry:
  %first.addr = alloca double*, align 8
  %count.addr = alloca i32, align 4
  %v1.addr = alloca double, align 8
  %v2.addr = alloca double, align 8
  %v3.addr = alloca double, align 8
  %v4.addr = alloca double, align 8
  %label.addr = alloca i8*, align 8
  %i = alloca i32, align 4
  %result = alloca double, align 8
  %n = alloca i32, align 4
  store double* %first, double** %first.addr, align 8
  store i32 %count, i32* %count.addr, align 4
  store double %v1, double* %v1.addr, align 8
  store double %v2, double* %v2.addr, align 8
  store double %v3, double* %v3.addr, align 8
  store double %v4, double* %v4.addr, align 8
  store i8* %label, i8** %label.addr, align 8
  call void @_Z11start_timerv()
  store i32 0, i32* %i, align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc4, %entry
  %0 = load i32, i32* %i, align 4
  %1 = load i32, i32* @iterations, align 4
  %cmp = icmp slt i32 %0, %1
  br i1 %cmp, label %for.body, label %for.end6

for.body:                                         ; preds = %for.cond
  store double 0.000000e+00, double* %result, align 8
  store i32 0, i32* %n, align 4
  br label %for.cond1

for.cond1:                                        ; preds = %for.inc, %for.body
  %2 = load i32, i32* %n, align 4
  %3 = load i32, i32* %count.addr, align 4
  %cmp2 = icmp slt i32 %2, %3
  br i1 %cmp2, label %for.body3, label %for.end

for.body3:                                        ; preds = %for.cond1
  %4 = load double*, double** %first.addr, align 8
  %5 = load i32, i32* %n, align 4
  %idxprom = sext i32 %5 to i64
  %arrayidx = getelementptr inbounds double, double* %4, i64 %idxprom
  %6 = load double, double* %arrayidx, align 8
  %7 = load double, double* %v1.addr, align 8
  %8 = load double, double* %v2.addr, align 8
  %9 = load double, double* %v3.addr, align 8
  %10 = load double, double* %v4.addr, align 8
  %call = call double @_ZN30custom_mixed_multiple_variableIdE8do_shiftEddddd(double %6, double %7, double %8, double %9, double %10)
  %11 = load double, double* %result, align 8
  %add = fadd double %11, %call
  store double %add, double* %result, align 8
  br label %for.inc

for.inc:                                          ; preds = %for.body3
  %12 = load i32, i32* %n, align 4
  %inc = add nsw i32 %12, 1
  store i32 %inc, i32* %n, align 4
  br label %for.cond1

for.end:                                          ; preds = %for.cond1
  %13 = load double, double* %result, align 8
  %14 = load double, double* %v1.addr, align 8
  %15 = load double, double* %v2.addr, align 8
  %16 = load double, double* %v3.addr, align 8
  %17 = load double, double* %v4.addr, align 8
  call void @_Z26check_shifted_variable_sumId30custom_mixed_multiple_variableIdEEvT_S2_S2_S2_S2_(double %13, double %14, double %15, double %16, double %17)
  br label %for.inc4

for.inc4:                                         ; preds = %for.end
  %18 = load i32, i32* %i, align 4
  %inc5 = add nsw i32 %18, 1
  store i32 %inc5, i32* %i, align 4
  br label %for.cond

for.end6:                                         ; preds = %for.cond
  %call7 = call double @_Z5timerv()
  %19 = load i8*, i8** %label.addr, align 8
  call void @_Z13record_resultdPKc(double %call7, i8* %19)
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr double @_ZN30custom_mixed_multiple_variableIdE8do_shiftEddddd(double %input, double %v1, double %v2, double %v3, double %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca double, align 8
  %v1.addr = alloca double, align 8
  %v2.addr = alloca double, align 8
  %v3.addr = alloca double, align 8
  %v4.addr = alloca double, align 8
  store double %input, double* %input.addr, align 8
  store double %v1, double* %v1.addr, align 8
  store double %v2, double* %v2.addr, align 8
  store double %v3, double* %v3.addr, align 8
  store double %v4, double* %v4.addr, align 8
  %0 = load double, double* %input.addr, align 8
  %1 = load double, double* %v1.addr, align 8
  %add = fadd double %0, %1
  %2 = load double, double* %v2.addr, align 8
  %3 = load double, double* %v3.addr, align 8
  %mul = fmul double %2, %3
  %4 = load double, double* %v4.addr, align 8
  %div = fdiv double %mul, %4
  %sub = fsub double %add, %div
  ret double %sub
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumId30custom_mixed_multiple_variableIdEEvT_S2_S2_S2_S2_(double %result, double %var1, double %var2, double %var3, double %var4) #0 comdat {
entry:
  %result.addr = alloca double, align 8
  %var1.addr = alloca double, align 8
  %var2.addr = alloca double, align 8
  %var3.addr = alloca double, align 8
  %var4.addr = alloca double, align 8
  %temp = alloca double, align 8
  store double %result, double* %result.addr, align 8
  store double %var1, double* %var1.addr, align 8
  store double %var2, double* %var2.addr, align 8
  store double %var3, double* %var3.addr, align 8
  store double %var4, double* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %1 = load double, double* %var1.addr, align 8
  %2 = load double, double* %var2.addr, align 8
  %3 = load double, double* %var3.addr, align 8
  %4 = load double, double* %var4.addr, align 8
  %call = call double @_ZN30custom_mixed_multiple_variableIdE8do_shiftEddddd(double %0, double %1, double %2, double %3, double %4)
  %mul = fmul double 8.000000e+03, %call
  store double %mul, double* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIdEbRT_S1_(double* dereferenceable(8) %result.addr, double* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i1 @_Z15tolerance_equalIdEbRT_S1_(double* dereferenceable(8) %a, double* dereferenceable(8) %b) #5 comdat {
entry:
  %a.addr = alloca double*, align 8
  %b.addr = alloca double*, align 8
  %diff = alloca double, align 8
  %reldiff = alloca double, align 8
  store double* %a, double** %a.addr, align 8
  store double* %b, double** %b.addr, align 8
  %0 = load double*, double** %a.addr, align 8
  %1 = load double, double* %0, align 8
  %2 = load double*, double** %b.addr, align 8
  %3 = load double, double* %2, align 8
  %sub = fsub double %1, %3
  store double %sub, double* %diff, align 8
  %4 = load double, double* %diff, align 8
  store double %4, double* %reldiff, align 8
  %5 = load double*, double** %a.addr, align 8
  %6 = load double, double* %5, align 8
  %call = call double @fabs(double %6) #8
  %cmp = fcmp ogt double %call, 1.000000e-08
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load double, double* %diff, align 8
  %8 = load double*, double** %a.addr, align 8
  %9 = load double, double* %8, align 8
  %div = fdiv double %7, %9
  store double %div, double* %reldiff, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %10 = load double, double* %reldiff, align 8
  %call1 = call double @fabs(double %10) #8
  %cmp2 = fcmp olt double %call1, 1.000000e-06
  ret i1 %cmp2
}

; Function Attrs: nounwind readnone
declare double @fabs(double) #7

; Function Attrs: noinline nounwind uwtable
define linkonce_odr double @_ZN32custom_divide_multiple_variable2IdE8do_shiftEddddd(double %input, double %v1, double %v2, double %v3, double %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca double, align 8
  %v1.addr = alloca double, align 8
  %v2.addr = alloca double, align 8
  %v3.addr = alloca double, align 8
  %v4.addr = alloca double, align 8
  store double %input, double* %input.addr, align 8
  store double %v1, double* %v1.addr, align 8
  store double %v2, double* %v2.addr, align 8
  store double %v3, double* %v3.addr, align 8
  store double %v4, double* %v4.addr, align 8
  %0 = load double, double* %input.addr, align 8
  %1 = load double, double* %v1.addr, align 8
  %2 = load double, double* %v2.addr, align 8
  %div = fdiv double %1, %2
  %3 = load double, double* %v3.addr, align 8
  %div1 = fdiv double %div, %3
  %4 = load double, double* %v4.addr, align 8
  %div2 = fdiv double %div1, %4
  %add = fadd double %0, %div2
  ret double %add
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumId32custom_divide_multiple_variable2IdEEvT_S2_S2_S2_S2_(double %result, double %var1, double %var2, double %var3, double %var4) #0 comdat {
entry:
  %result.addr = alloca double, align 8
  %var1.addr = alloca double, align 8
  %var2.addr = alloca double, align 8
  %var3.addr = alloca double, align 8
  %var4.addr = alloca double, align 8
  %temp = alloca double, align 8
  store double %result, double* %result.addr, align 8
  store double %var1, double* %var1.addr, align 8
  store double %var2, double* %var2.addr, align 8
  store double %var3, double* %var3.addr, align 8
  store double %var4, double* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %1 = load double, double* %var1.addr, align 8
  %2 = load double, double* %var2.addr, align 8
  %3 = load double, double* %var3.addr, align 8
  %4 = load double, double* %var4.addr, align 8
  %call = call double @_ZN32custom_divide_multiple_variable2IdE8do_shiftEddddd(double %0, double %1, double %2, double %3, double %4)
  %mul = fmul double 8.000000e+03, %call
  store double %mul, double* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIdEbRT_S1_(double* dereferenceable(8) %result.addr, double* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr double @_ZN31custom_divide_multiple_variableIdE8do_shiftEddddd(double %input, double %v1, double %v2, double %v3, double %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca double, align 8
  %v1.addr = alloca double, align 8
  %v2.addr = alloca double, align 8
  %v3.addr = alloca double, align 8
  %v4.addr = alloca double, align 8
  store double %input, double* %input.addr, align 8
  store double %v1, double* %v1.addr, align 8
  store double %v2, double* %v2.addr, align 8
  store double %v3, double* %v3.addr, align 8
  store double %v4, double* %v4.addr, align 8
  %0 = load double, double* %input.addr, align 8
  %1 = load double, double* %v1.addr, align 8
  %div = fdiv double %0, %1
  %2 = load double, double* %v2.addr, align 8
  %div1 = fdiv double %div, %2
  %3 = load double, double* %v3.addr, align 8
  %div2 = fdiv double %div1, %3
  %4 = load double, double* %v4.addr, align 8
  %div3 = fdiv double %div2, %4
  ret double %div3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumId31custom_divide_multiple_variableIdEEvT_S2_S2_S2_S2_(double %result, double %var1, double %var2, double %var3, double %var4) #0 comdat {
entry:
  %result.addr = alloca double, align 8
  %var1.addr = alloca double, align 8
  %var2.addr = alloca double, align 8
  %var3.addr = alloca double, align 8
  %var4.addr = alloca double, align 8
  %temp = alloca double, align 8
  store double %result, double* %result.addr, align 8
  store double %var1, double* %var1.addr, align 8
  store double %var2, double* %var2.addr, align 8
  store double %var3, double* %var3.addr, align 8
  store double %var4, double* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %1 = load double, double* %var1.addr, align 8
  %2 = load double, double* %var2.addr, align 8
  %3 = load double, double* %var3.addr, align 8
  %4 = load double, double* %var4.addr, align 8
  %call = call double @_ZN31custom_divide_multiple_variableIdE8do_shiftEddddd(double %0, double %1, double %2, double %3, double %4)
  %mul = fmul double 8.000000e+03, %call
  store double %mul, double* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIdEbRT_S1_(double* dereferenceable(8) %result.addr, double* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr double @_ZN22custom_divide_variableIdE8do_shiftEdd(double %input, double %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca double, align 8
  %v1.addr = alloca double, align 8
  store double %input, double* %input.addr, align 8
  store double %v1, double* %v1.addr, align 8
  %0 = load double, double* %input.addr, align 8
  %1 = load double, double* %v1.addr, align 8
  %div = fdiv double %0, %1
  ret double %div
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumId22custom_divide_variableIdEEvT_S2_(double %result, double %var) #0 comdat {
entry:
  %result.addr = alloca double, align 8
  %var.addr = alloca double, align 8
  %temp = alloca double, align 8
  store double %result, double* %result.addr, align 8
  store double %var, double* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %1 = load double, double* %var.addr, align 8
  %call = call double @_ZN22custom_divide_variableIdE8do_shiftEdd(double %0, double %1)
  %mul = fmul double 8.000000e+03, %call
  store double %mul, double* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIdEbRT_S1_(double* dereferenceable(8) %result.addr, double* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr double @_ZN34custom_multiply_multiple_variable2IdE8do_shiftEddddd(double %input, double %v1, double %v2, double %v3, double %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca double, align 8
  %v1.addr = alloca double, align 8
  %v2.addr = alloca double, align 8
  %v3.addr = alloca double, align 8
  %v4.addr = alloca double, align 8
  store double %input, double* %input.addr, align 8
  store double %v1, double* %v1.addr, align 8
  store double %v2, double* %v2.addr, align 8
  store double %v3, double* %v3.addr, align 8
  store double %v4, double* %v4.addr, align 8
  %0 = load double, double* %input.addr, align 8
  %1 = load double, double* %v1.addr, align 8
  %2 = load double, double* %v2.addr, align 8
  %mul = fmul double %1, %2
  %3 = load double, double* %v3.addr, align 8
  %mul1 = fmul double %mul, %3
  %4 = load double, double* %v4.addr, align 8
  %mul2 = fmul double %mul1, %4
  %add = fadd double %0, %mul2
  ret double %add
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumId34custom_multiply_multiple_variable2IdEEvT_S2_S2_S2_S2_(double %result, double %var1, double %var2, double %var3, double %var4) #0 comdat {
entry:
  %result.addr = alloca double, align 8
  %var1.addr = alloca double, align 8
  %var2.addr = alloca double, align 8
  %var3.addr = alloca double, align 8
  %var4.addr = alloca double, align 8
  %temp = alloca double, align 8
  store double %result, double* %result.addr, align 8
  store double %var1, double* %var1.addr, align 8
  store double %var2, double* %var2.addr, align 8
  store double %var3, double* %var3.addr, align 8
  store double %var4, double* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %1 = load double, double* %var1.addr, align 8
  %2 = load double, double* %var2.addr, align 8
  %3 = load double, double* %var3.addr, align 8
  %4 = load double, double* %var4.addr, align 8
  %call = call double @_ZN34custom_multiply_multiple_variable2IdE8do_shiftEddddd(double %0, double %1, double %2, double %3, double %4)
  %mul = fmul double 8.000000e+03, %call
  store double %mul, double* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIdEbRT_S1_(double* dereferenceable(8) %result.addr, double* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr double @_ZN33custom_multiply_multiple_variableIdE8do_shiftEddddd(double %input, double %v1, double %v2, double %v3, double %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca double, align 8
  %v1.addr = alloca double, align 8
  %v2.addr = alloca double, align 8
  %v3.addr = alloca double, align 8
  %v4.addr = alloca double, align 8
  store double %input, double* %input.addr, align 8
  store double %v1, double* %v1.addr, align 8
  store double %v2, double* %v2.addr, align 8
  store double %v3, double* %v3.addr, align 8
  store double %v4, double* %v4.addr, align 8
  %0 = load double, double* %input.addr, align 8
  %1 = load double, double* %v1.addr, align 8
  %mul = fmul double %0, %1
  %2 = load double, double* %v2.addr, align 8
  %mul1 = fmul double %mul, %2
  %3 = load double, double* %v3.addr, align 8
  %mul2 = fmul double %mul1, %3
  %4 = load double, double* %v4.addr, align 8
  %mul3 = fmul double %mul2, %4
  ret double %mul3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumId33custom_multiply_multiple_variableIdEEvT_S2_S2_S2_S2_(double %result, double %var1, double %var2, double %var3, double %var4) #0 comdat {
entry:
  %result.addr = alloca double, align 8
  %var1.addr = alloca double, align 8
  %var2.addr = alloca double, align 8
  %var3.addr = alloca double, align 8
  %var4.addr = alloca double, align 8
  %temp = alloca double, align 8
  store double %result, double* %result.addr, align 8
  store double %var1, double* %var1.addr, align 8
  store double %var2, double* %var2.addr, align 8
  store double %var3, double* %var3.addr, align 8
  store double %var4, double* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %1 = load double, double* %var1.addr, align 8
  %2 = load double, double* %var2.addr, align 8
  %3 = load double, double* %var3.addr, align 8
  %4 = load double, double* %var4.addr, align 8
  %call = call double @_ZN33custom_multiply_multiple_variableIdE8do_shiftEddddd(double %0, double %1, double %2, double %3, double %4)
  %mul = fmul double 8.000000e+03, %call
  store double %mul, double* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIdEbRT_S1_(double* dereferenceable(8) %result.addr, double* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr double @_ZN24custom_multiply_variableIdE8do_shiftEdd(double %input, double %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca double, align 8
  %v1.addr = alloca double, align 8
  store double %input, double* %input.addr, align 8
  store double %v1, double* %v1.addr, align 8
  %0 = load double, double* %input.addr, align 8
  %1 = load double, double* %v1.addr, align 8
  %mul = fmul double %0, %1
  ret double %mul
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumId24custom_multiply_variableIdEEvT_S2_(double %result, double %var) #0 comdat {
entry:
  %result.addr = alloca double, align 8
  %var.addr = alloca double, align 8
  %temp = alloca double, align 8
  store double %result, double* %result.addr, align 8
  store double %var, double* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %1 = load double, double* %var.addr, align 8
  %call = call double @_ZN24custom_multiply_variableIdE8do_shiftEdd(double %0, double %1)
  %mul = fmul double 8.000000e+03, %call
  store double %mul, double* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIdEbRT_S1_(double* dereferenceable(8) %result.addr, double* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr double @_ZN28custom_sub_multiple_variableIdE8do_shiftEddddd(double %input, double %v1, double %v2, double %v3, double %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca double, align 8
  %v1.addr = alloca double, align 8
  %v2.addr = alloca double, align 8
  %v3.addr = alloca double, align 8
  %v4.addr = alloca double, align 8
  store double %input, double* %input.addr, align 8
  store double %v1, double* %v1.addr, align 8
  store double %v2, double* %v2.addr, align 8
  store double %v3, double* %v3.addr, align 8
  store double %v4, double* %v4.addr, align 8
  %0 = load double, double* %input.addr, align 8
  %1 = load double, double* %v1.addr, align 8
  %sub = fsub double %0, %1
  %2 = load double, double* %v2.addr, align 8
  %sub1 = fsub double %sub, %2
  %3 = load double, double* %v3.addr, align 8
  %sub2 = fsub double %sub1, %3
  %4 = load double, double* %v4.addr, align 8
  %sub3 = fsub double %sub2, %4
  ret double %sub3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumId28custom_sub_multiple_variableIdEEvT_S2_S2_S2_S2_(double %result, double %var1, double %var2, double %var3, double %var4) #0 comdat {
entry:
  %result.addr = alloca double, align 8
  %var1.addr = alloca double, align 8
  %var2.addr = alloca double, align 8
  %var3.addr = alloca double, align 8
  %var4.addr = alloca double, align 8
  %temp = alloca double, align 8
  store double %result, double* %result.addr, align 8
  store double %var1, double* %var1.addr, align 8
  store double %var2, double* %var2.addr, align 8
  store double %var3, double* %var3.addr, align 8
  store double %var4, double* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %1 = load double, double* %var1.addr, align 8
  %2 = load double, double* %var2.addr, align 8
  %3 = load double, double* %var3.addr, align 8
  %4 = load double, double* %var4.addr, align 8
  %call = call double @_ZN28custom_sub_multiple_variableIdE8do_shiftEddddd(double %0, double %1, double %2, double %3, double %4)
  %mul = fmul double 8.000000e+03, %call
  store double %mul, double* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIdEbRT_S1_(double* dereferenceable(8) %result.addr, double* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr double @_ZN19custom_sub_variableIdE8do_shiftEdd(double %input, double %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca double, align 8
  %v1.addr = alloca double, align 8
  store double %input, double* %input.addr, align 8
  store double %v1, double* %v1.addr, align 8
  %0 = load double, double* %input.addr, align 8
  %1 = load double, double* %v1.addr, align 8
  %sub = fsub double %0, %1
  ret double %sub
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumId19custom_sub_variableIdEEvT_S2_(double %result, double %var) #0 comdat {
entry:
  %result.addr = alloca double, align 8
  %var.addr = alloca double, align 8
  %temp = alloca double, align 8
  store double %result, double* %result.addr, align 8
  store double %var, double* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %1 = load double, double* %var.addr, align 8
  %call = call double @_ZN19custom_sub_variableIdE8do_shiftEdd(double %0, double %1)
  %mul = fmul double 8.000000e+03, %call
  store double %mul, double* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIdEbRT_S1_(double* dereferenceable(8) %result.addr, double* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr double @_ZN28custom_add_multiple_variableIdE8do_shiftEddddd(double %input, double %v1, double %v2, double %v3, double %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca double, align 8
  %v1.addr = alloca double, align 8
  %v2.addr = alloca double, align 8
  %v3.addr = alloca double, align 8
  %v4.addr = alloca double, align 8
  store double %input, double* %input.addr, align 8
  store double %v1, double* %v1.addr, align 8
  store double %v2, double* %v2.addr, align 8
  store double %v3, double* %v3.addr, align 8
  store double %v4, double* %v4.addr, align 8
  %0 = load double, double* %input.addr, align 8
  %1 = load double, double* %v1.addr, align 8
  %add = fadd double %0, %1
  %2 = load double, double* %v2.addr, align 8
  %add1 = fadd double %add, %2
  %3 = load double, double* %v3.addr, align 8
  %add2 = fadd double %add1, %3
  %4 = load double, double* %v4.addr, align 8
  %add3 = fadd double %add2, %4
  ret double %add3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumId28custom_add_multiple_variableIdEEvT_S2_S2_S2_S2_(double %result, double %var1, double %var2, double %var3, double %var4) #0 comdat {
entry:
  %result.addr = alloca double, align 8
  %var1.addr = alloca double, align 8
  %var2.addr = alloca double, align 8
  %var3.addr = alloca double, align 8
  %var4.addr = alloca double, align 8
  %temp = alloca double, align 8
  store double %result, double* %result.addr, align 8
  store double %var1, double* %var1.addr, align 8
  store double %var2, double* %var2.addr, align 8
  store double %var3, double* %var3.addr, align 8
  store double %var4, double* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %1 = load double, double* %var1.addr, align 8
  %2 = load double, double* %var2.addr, align 8
  %3 = load double, double* %var3.addr, align 8
  %4 = load double, double* %var4.addr, align 8
  %call = call double @_ZN28custom_add_multiple_variableIdE8do_shiftEddddd(double %0, double %1, double %2, double %3, double %4)
  %mul = fmul double 8.000000e+03, %call
  store double %mul, double* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIdEbRT_S1_(double* dereferenceable(8) %result.addr, double* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumId19custom_add_variableIdEEvT_S2_(double %result, double %var) #0 comdat {
entry:
  %result.addr = alloca double, align 8
  %var.addr = alloca double, align 8
  %temp = alloca double, align 8
  store double %result, double* %result.addr, align 8
  store double %var, double* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %1 = load double, double* %var.addr, align 8
  %call = call double @_ZN19custom_add_variableIdE8do_shiftEdd(double %0, double %1)
  %mul = fmul double 8.000000e+03, %call
  store double %mul, double* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIdEbRT_S1_(double* dereferenceable(8) %result.addr, double* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr double @_ZN19custom_add_variableIdE8do_shiftEdd(double %input, double %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca double, align 8
  %v1.addr = alloca double, align 8
  store double %input, double* %input.addr, align 8
  store double %v1, double* %v1.addr, align 8
  %0 = load double, double* %input.addr, align 8
  %1 = load double, double* %v1.addr, align 8
  %add = fadd double %0, %1
  ret double %add
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr float @_ZN30custom_mixed_multiple_variableIfE8do_shiftEfffff(float %input, float %v1, float %v2, float %v3, float %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca float, align 4
  %v1.addr = alloca float, align 4
  %v2.addr = alloca float, align 4
  %v3.addr = alloca float, align 4
  %v4.addr = alloca float, align 4
  store float %input, float* %input.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store float %v2, float* %v2.addr, align 4
  store float %v3, float* %v3.addr, align 4
  store float %v4, float* %v4.addr, align 4
  %0 = load float, float* %input.addr, align 4
  %1 = load float, float* %v1.addr, align 4
  %add = fadd float %0, %1
  %2 = load float, float* %v2.addr, align 4
  %3 = load float, float* %v3.addr, align 4
  %mul = fmul float %2, %3
  %4 = load float, float* %v4.addr, align 4
  %div = fdiv float %mul, %4
  %sub = fsub float %add, %div
  ret float %sub
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIf30custom_mixed_multiple_variableIfEEvT_S2_S2_S2_S2_(float %result, float %var1, float %var2, float %var3, float %var4) #0 comdat {
entry:
  %result.addr = alloca float, align 4
  %var1.addr = alloca float, align 4
  %var2.addr = alloca float, align 4
  %var3.addr = alloca float, align 4
  %var4.addr = alloca float, align 4
  %temp = alloca float, align 4
  store float %result, float* %result.addr, align 4
  store float %var1, float* %var1.addr, align 4
  store float %var2, float* %var2.addr, align 4
  store float %var3, float* %var3.addr, align 4
  store float %var4, float* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptrunc double %0 to float
  %1 = load float, float* %var1.addr, align 4
  %2 = load float, float* %var2.addr, align 4
  %3 = load float, float* %var3.addr, align 4
  %4 = load float, float* %var4.addr, align 4
  %call = call float @_ZN30custom_mixed_multiple_variableIfE8do_shiftEfffff(float %conv, float %1, float %2, float %3, float %4)
  %mul = fmul float 8.000000e+03, %call
  store float %mul, float* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIfEbRT_S1_(float* dereferenceable(4) %result.addr, float* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr zeroext i1 @_Z15tolerance_equalIfEbRT_S1_(float* dereferenceable(4) %a, float* dereferenceable(4) %b) #0 comdat {
entry:
  %a.addr = alloca float*, align 8
  %b.addr = alloca float*, align 8
  %diff = alloca float, align 4
  %reldiff = alloca double, align 8
  store float* %a, float** %a.addr, align 8
  store float* %b, float** %b.addr, align 8
  %0 = load float*, float** %a.addr, align 8
  %1 = load float, float* %0, align 4
  %2 = load float*, float** %b.addr, align 8
  %3 = load float, float* %2, align 4
  %sub = fsub float %1, %3
  store float %sub, float* %diff, align 4
  %4 = load float, float* %diff, align 4
  %conv = fpext float %4 to double
  store double %conv, double* %reldiff, align 8
  %5 = load float*, float** %a.addr, align 8
  %6 = load float, float* %5, align 4
  %call = call float @_ZSt4fabsf(float %6)
  %conv1 = fpext float %call to double
  %cmp = fcmp ogt double %conv1, 1.000000e-04
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %7 = load float, float* %diff, align 4
  %8 = load float*, float** %a.addr, align 8
  %9 = load float, float* %8, align 4
  %div = fdiv float %7, %9
  %conv2 = fpext float %div to double
  store double %conv2, double* %reldiff, align 8
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  %10 = load double, double* %reldiff, align 8
  %call3 = call double @fabs(double %10) #8
  %cmp4 = fcmp olt double %call3, 1.000000e-03
  ret i1 %cmp4
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr float @_ZSt4fabsf(float %__x) #5 comdat {
entry:
  %__x.addr = alloca float, align 4
  store float %__x, float* %__x.addr, align 4
  %0 = load float, float* %__x.addr, align 4
  %1 = call float @llvm.fabs.f32(float %0)
  ret float %1
}

; Function Attrs: nounwind readnone
declare float @llvm.fabs.f32(float) #8

; Function Attrs: noinline nounwind uwtable
define linkonce_odr float @_ZN32custom_divide_multiple_variable2IfE8do_shiftEfffff(float %input, float %v1, float %v2, float %v3, float %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca float, align 4
  %v1.addr = alloca float, align 4
  %v2.addr = alloca float, align 4
  %v3.addr = alloca float, align 4
  %v4.addr = alloca float, align 4
  store float %input, float* %input.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store float %v2, float* %v2.addr, align 4
  store float %v3, float* %v3.addr, align 4
  store float %v4, float* %v4.addr, align 4
  %0 = load float, float* %input.addr, align 4
  %1 = load float, float* %v1.addr, align 4
  %2 = load float, float* %v2.addr, align 4
  %div = fdiv float %1, %2
  %3 = load float, float* %v3.addr, align 4
  %div1 = fdiv float %div, %3
  %4 = load float, float* %v4.addr, align 4
  %div2 = fdiv float %div1, %4
  %add = fadd float %0, %div2
  ret float %add
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIf32custom_divide_multiple_variable2IfEEvT_S2_S2_S2_S2_(float %result, float %var1, float %var2, float %var3, float %var4) #0 comdat {
entry:
  %result.addr = alloca float, align 4
  %var1.addr = alloca float, align 4
  %var2.addr = alloca float, align 4
  %var3.addr = alloca float, align 4
  %var4.addr = alloca float, align 4
  %temp = alloca float, align 4
  store float %result, float* %result.addr, align 4
  store float %var1, float* %var1.addr, align 4
  store float %var2, float* %var2.addr, align 4
  store float %var3, float* %var3.addr, align 4
  store float %var4, float* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptrunc double %0 to float
  %1 = load float, float* %var1.addr, align 4
  %2 = load float, float* %var2.addr, align 4
  %3 = load float, float* %var3.addr, align 4
  %4 = load float, float* %var4.addr, align 4
  %call = call float @_ZN32custom_divide_multiple_variable2IfE8do_shiftEfffff(float %conv, float %1, float %2, float %3, float %4)
  %mul = fmul float 8.000000e+03, %call
  store float %mul, float* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIfEbRT_S1_(float* dereferenceable(4) %result.addr, float* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr float @_ZN31custom_divide_multiple_variableIfE8do_shiftEfffff(float %input, float %v1, float %v2, float %v3, float %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca float, align 4
  %v1.addr = alloca float, align 4
  %v2.addr = alloca float, align 4
  %v3.addr = alloca float, align 4
  %v4.addr = alloca float, align 4
  store float %input, float* %input.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store float %v2, float* %v2.addr, align 4
  store float %v3, float* %v3.addr, align 4
  store float %v4, float* %v4.addr, align 4
  %0 = load float, float* %input.addr, align 4
  %1 = load float, float* %v1.addr, align 4
  %div = fdiv float %0, %1
  %2 = load float, float* %v2.addr, align 4
  %div1 = fdiv float %div, %2
  %3 = load float, float* %v3.addr, align 4
  %div2 = fdiv float %div1, %3
  %4 = load float, float* %v4.addr, align 4
  %div3 = fdiv float %div2, %4
  ret float %div3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIf31custom_divide_multiple_variableIfEEvT_S2_S2_S2_S2_(float %result, float %var1, float %var2, float %var3, float %var4) #0 comdat {
entry:
  %result.addr = alloca float, align 4
  %var1.addr = alloca float, align 4
  %var2.addr = alloca float, align 4
  %var3.addr = alloca float, align 4
  %var4.addr = alloca float, align 4
  %temp = alloca float, align 4
  store float %result, float* %result.addr, align 4
  store float %var1, float* %var1.addr, align 4
  store float %var2, float* %var2.addr, align 4
  store float %var3, float* %var3.addr, align 4
  store float %var4, float* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptrunc double %0 to float
  %1 = load float, float* %var1.addr, align 4
  %2 = load float, float* %var2.addr, align 4
  %3 = load float, float* %var3.addr, align 4
  %4 = load float, float* %var4.addr, align 4
  %call = call float @_ZN31custom_divide_multiple_variableIfE8do_shiftEfffff(float %conv, float %1, float %2, float %3, float %4)
  %mul = fmul float 8.000000e+03, %call
  store float %mul, float* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIfEbRT_S1_(float* dereferenceable(4) %result.addr, float* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr float @_ZN22custom_divide_variableIfE8do_shiftEff(float %input, float %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca float, align 4
  %v1.addr = alloca float, align 4
  store float %input, float* %input.addr, align 4
  store float %v1, float* %v1.addr, align 4
  %0 = load float, float* %input.addr, align 4
  %1 = load float, float* %v1.addr, align 4
  %div = fdiv float %0, %1
  ret float %div
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIf22custom_divide_variableIfEEvT_S2_(float %result, float %var) #0 comdat {
entry:
  %result.addr = alloca float, align 4
  %var.addr = alloca float, align 4
  %temp = alloca float, align 4
  store float %result, float* %result.addr, align 4
  store float %var, float* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptrunc double %0 to float
  %1 = load float, float* %var.addr, align 4
  %call = call float @_ZN22custom_divide_variableIfE8do_shiftEff(float %conv, float %1)
  %mul = fmul float 8.000000e+03, %call
  store float %mul, float* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIfEbRT_S1_(float* dereferenceable(4) %result.addr, float* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr float @_ZN34custom_multiply_multiple_variable2IfE8do_shiftEfffff(float %input, float %v1, float %v2, float %v3, float %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca float, align 4
  %v1.addr = alloca float, align 4
  %v2.addr = alloca float, align 4
  %v3.addr = alloca float, align 4
  %v4.addr = alloca float, align 4
  store float %input, float* %input.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store float %v2, float* %v2.addr, align 4
  store float %v3, float* %v3.addr, align 4
  store float %v4, float* %v4.addr, align 4
  %0 = load float, float* %input.addr, align 4
  %1 = load float, float* %v1.addr, align 4
  %2 = load float, float* %v2.addr, align 4
  %mul = fmul float %1, %2
  %3 = load float, float* %v3.addr, align 4
  %mul1 = fmul float %mul, %3
  %4 = load float, float* %v4.addr, align 4
  %mul2 = fmul float %mul1, %4
  %add = fadd float %0, %mul2
  ret float %add
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIf34custom_multiply_multiple_variable2IfEEvT_S2_S2_S2_S2_(float %result, float %var1, float %var2, float %var3, float %var4) #0 comdat {
entry:
  %result.addr = alloca float, align 4
  %var1.addr = alloca float, align 4
  %var2.addr = alloca float, align 4
  %var3.addr = alloca float, align 4
  %var4.addr = alloca float, align 4
  %temp = alloca float, align 4
  store float %result, float* %result.addr, align 4
  store float %var1, float* %var1.addr, align 4
  store float %var2, float* %var2.addr, align 4
  store float %var3, float* %var3.addr, align 4
  store float %var4, float* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptrunc double %0 to float
  %1 = load float, float* %var1.addr, align 4
  %2 = load float, float* %var2.addr, align 4
  %3 = load float, float* %var3.addr, align 4
  %4 = load float, float* %var4.addr, align 4
  %call = call float @_ZN34custom_multiply_multiple_variable2IfE8do_shiftEfffff(float %conv, float %1, float %2, float %3, float %4)
  %mul = fmul float 8.000000e+03, %call
  store float %mul, float* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIfEbRT_S1_(float* dereferenceable(4) %result.addr, float* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr float @_ZN33custom_multiply_multiple_variableIfE8do_shiftEfffff(float %input, float %v1, float %v2, float %v3, float %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca float, align 4
  %v1.addr = alloca float, align 4
  %v2.addr = alloca float, align 4
  %v3.addr = alloca float, align 4
  %v4.addr = alloca float, align 4
  store float %input, float* %input.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store float %v2, float* %v2.addr, align 4
  store float %v3, float* %v3.addr, align 4
  store float %v4, float* %v4.addr, align 4
  %0 = load float, float* %input.addr, align 4
  %1 = load float, float* %v1.addr, align 4
  %mul = fmul float %0, %1
  %2 = load float, float* %v2.addr, align 4
  %mul1 = fmul float %mul, %2
  %3 = load float, float* %v3.addr, align 4
  %mul2 = fmul float %mul1, %3
  %4 = load float, float* %v4.addr, align 4
  %mul3 = fmul float %mul2, %4
  ret float %mul3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIf33custom_multiply_multiple_variableIfEEvT_S2_S2_S2_S2_(float %result, float %var1, float %var2, float %var3, float %var4) #0 comdat {
entry:
  %result.addr = alloca float, align 4
  %var1.addr = alloca float, align 4
  %var2.addr = alloca float, align 4
  %var3.addr = alloca float, align 4
  %var4.addr = alloca float, align 4
  %temp = alloca float, align 4
  store float %result, float* %result.addr, align 4
  store float %var1, float* %var1.addr, align 4
  store float %var2, float* %var2.addr, align 4
  store float %var3, float* %var3.addr, align 4
  store float %var4, float* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptrunc double %0 to float
  %1 = load float, float* %var1.addr, align 4
  %2 = load float, float* %var2.addr, align 4
  %3 = load float, float* %var3.addr, align 4
  %4 = load float, float* %var4.addr, align 4
  %call = call float @_ZN33custom_multiply_multiple_variableIfE8do_shiftEfffff(float %conv, float %1, float %2, float %3, float %4)
  %mul = fmul float 8.000000e+03, %call
  store float %mul, float* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIfEbRT_S1_(float* dereferenceable(4) %result.addr, float* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr float @_ZN24custom_multiply_variableIfE8do_shiftEff(float %input, float %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca float, align 4
  %v1.addr = alloca float, align 4
  store float %input, float* %input.addr, align 4
  store float %v1, float* %v1.addr, align 4
  %0 = load float, float* %input.addr, align 4
  %1 = load float, float* %v1.addr, align 4
  %mul = fmul float %0, %1
  ret float %mul
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIf24custom_multiply_variableIfEEvT_S2_(float %result, float %var) #0 comdat {
entry:
  %result.addr = alloca float, align 4
  %var.addr = alloca float, align 4
  %temp = alloca float, align 4
  store float %result, float* %result.addr, align 4
  store float %var, float* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptrunc double %0 to float
  %1 = load float, float* %var.addr, align 4
  %call = call float @_ZN24custom_multiply_variableIfE8do_shiftEff(float %conv, float %1)
  %mul = fmul float 8.000000e+03, %call
  store float %mul, float* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIfEbRT_S1_(float* dereferenceable(4) %result.addr, float* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr float @_ZN28custom_sub_multiple_variableIfE8do_shiftEfffff(float %input, float %v1, float %v2, float %v3, float %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca float, align 4
  %v1.addr = alloca float, align 4
  %v2.addr = alloca float, align 4
  %v3.addr = alloca float, align 4
  %v4.addr = alloca float, align 4
  store float %input, float* %input.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store float %v2, float* %v2.addr, align 4
  store float %v3, float* %v3.addr, align 4
  store float %v4, float* %v4.addr, align 4
  %0 = load float, float* %input.addr, align 4
  %1 = load float, float* %v1.addr, align 4
  %sub = fsub float %0, %1
  %2 = load float, float* %v2.addr, align 4
  %sub1 = fsub float %sub, %2
  %3 = load float, float* %v3.addr, align 4
  %sub2 = fsub float %sub1, %3
  %4 = load float, float* %v4.addr, align 4
  %sub3 = fsub float %sub2, %4
  ret float %sub3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIf28custom_sub_multiple_variableIfEEvT_S2_S2_S2_S2_(float %result, float %var1, float %var2, float %var3, float %var4) #0 comdat {
entry:
  %result.addr = alloca float, align 4
  %var1.addr = alloca float, align 4
  %var2.addr = alloca float, align 4
  %var3.addr = alloca float, align 4
  %var4.addr = alloca float, align 4
  %temp = alloca float, align 4
  store float %result, float* %result.addr, align 4
  store float %var1, float* %var1.addr, align 4
  store float %var2, float* %var2.addr, align 4
  store float %var3, float* %var3.addr, align 4
  store float %var4, float* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptrunc double %0 to float
  %1 = load float, float* %var1.addr, align 4
  %2 = load float, float* %var2.addr, align 4
  %3 = load float, float* %var3.addr, align 4
  %4 = load float, float* %var4.addr, align 4
  %call = call float @_ZN28custom_sub_multiple_variableIfE8do_shiftEfffff(float %conv, float %1, float %2, float %3, float %4)
  %mul = fmul float 8.000000e+03, %call
  store float %mul, float* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIfEbRT_S1_(float* dereferenceable(4) %result.addr, float* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr float @_ZN19custom_sub_variableIfE8do_shiftEff(float %input, float %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca float, align 4
  %v1.addr = alloca float, align 4
  store float %input, float* %input.addr, align 4
  store float %v1, float* %v1.addr, align 4
  %0 = load float, float* %input.addr, align 4
  %1 = load float, float* %v1.addr, align 4
  %sub = fsub float %0, %1
  ret float %sub
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIf19custom_sub_variableIfEEvT_S2_(float %result, float %var) #0 comdat {
entry:
  %result.addr = alloca float, align 4
  %var.addr = alloca float, align 4
  %temp = alloca float, align 4
  store float %result, float* %result.addr, align 4
  store float %var, float* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptrunc double %0 to float
  %1 = load float, float* %var.addr, align 4
  %call = call float @_ZN19custom_sub_variableIfE8do_shiftEff(float %conv, float %1)
  %mul = fmul float 8.000000e+03, %call
  store float %mul, float* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIfEbRT_S1_(float* dereferenceable(4) %result.addr, float* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr float @_ZN28custom_add_multiple_variableIfE8do_shiftEfffff(float %input, float %v1, float %v2, float %v3, float %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca float, align 4
  %v1.addr = alloca float, align 4
  %v2.addr = alloca float, align 4
  %v3.addr = alloca float, align 4
  %v4.addr = alloca float, align 4
  store float %input, float* %input.addr, align 4
  store float %v1, float* %v1.addr, align 4
  store float %v2, float* %v2.addr, align 4
  store float %v3, float* %v3.addr, align 4
  store float %v4, float* %v4.addr, align 4
  %0 = load float, float* %input.addr, align 4
  %1 = load float, float* %v1.addr, align 4
  %add = fadd float %0, %1
  %2 = load float, float* %v2.addr, align 4
  %add1 = fadd float %add, %2
  %3 = load float, float* %v3.addr, align 4
  %add2 = fadd float %add1, %3
  %4 = load float, float* %v4.addr, align 4
  %add3 = fadd float %add2, %4
  ret float %add3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIf28custom_add_multiple_variableIfEEvT_S2_S2_S2_S2_(float %result, float %var1, float %var2, float %var3, float %var4) #0 comdat {
entry:
  %result.addr = alloca float, align 4
  %var1.addr = alloca float, align 4
  %var2.addr = alloca float, align 4
  %var3.addr = alloca float, align 4
  %var4.addr = alloca float, align 4
  %temp = alloca float, align 4
  store float %result, float* %result.addr, align 4
  store float %var1, float* %var1.addr, align 4
  store float %var2, float* %var2.addr, align 4
  store float %var3, float* %var3.addr, align 4
  store float %var4, float* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptrunc double %0 to float
  %1 = load float, float* %var1.addr, align 4
  %2 = load float, float* %var2.addr, align 4
  %3 = load float, float* %var3.addr, align 4
  %4 = load float, float* %var4.addr, align 4
  %call = call float @_ZN28custom_add_multiple_variableIfE8do_shiftEfffff(float %conv, float %1, float %2, float %3, float %4)
  %mul = fmul float 8.000000e+03, %call
  store float %mul, float* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIfEbRT_S1_(float* dereferenceable(4) %result.addr, float* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIf19custom_add_variableIfEEvT_S2_(float %result, float %var) #0 comdat {
entry:
  %result.addr = alloca float, align 4
  %var.addr = alloca float, align 4
  %temp = alloca float, align 4
  store float %result, float* %result.addr, align 4
  store float %var, float* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptrunc double %0 to float
  %1 = load float, float* %var.addr, align 4
  %call = call float @_ZN19custom_add_variableIfE8do_shiftEff(float %conv, float %1)
  %mul = fmul float 8.000000e+03, %call
  store float %mul, float* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIfEbRT_S1_(float* dereferenceable(4) %result.addr, float* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr float @_ZN19custom_add_variableIfE8do_shiftEff(float %input, float %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca float, align 4
  %v1.addr = alloca float, align 4
  store float %input, float* %input.addr, align 4
  store float %v1, float* %v1.addr, align 4
  %0 = load float, float* %input.addr, align 4
  %1 = load float, float* %v1.addr, align 4
  %add = fadd float %0, %1
  ret float %add
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN28custom_multiple_variable_xorImE8do_shiftEmmmmm(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %xor = xor i64 %0, %1
  %2 = load i64, i64* %v2.addr, align 8
  %xor1 = xor i64 %xor, %2
  %3 = load i64, i64* %v3.addr, align 8
  %xor2 = xor i64 %xor1, %3
  %4 = load i64, i64* %v4.addr, align 8
  %xor3 = xor i64 %xor2, %4
  ret i64 %xor3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIm28custom_multiple_variable_xorImEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN28custom_multiple_variable_xorImE8do_shiftEmmmmm(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %a, i64* dereferenceable(8) %b) #5 comdat {
entry:
  %a.addr = alloca i64*, align 8
  %b.addr = alloca i64*, align 8
  store i64* %a, i64** %a.addr, align 8
  store i64* %b, i64** %b.addr, align 8
  %0 = load i64*, i64** %a.addr, align 8
  %1 = load i64, i64* %0, align 8
  %2 = load i64*, i64** %b.addr, align 8
  %3 = load i64, i64* %2, align 8
  %cmp = icmp eq i64 %1, %3
  ret i1 %cmp
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN19custom_variable_xorImE8do_shiftEmm(i64 %input, i64 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %xor = xor i64 %0, %1
  ret i64 %xor
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIm19custom_variable_xorImEEvT_S2_(i64 %result, i64 %var) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var, i64* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i64
  %1 = load i64, i64* %var.addr, align 8
  %call = call i64 @_ZN19custom_variable_xorImE8do_shiftEmm(i64 %conv, i64 %1)
  %mul = mul i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN27custom_multiple_variable_orImE8do_shiftEmmmmm(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %or = or i64 %0, %1
  %2 = load i64, i64* %v2.addr, align 8
  %or1 = or i64 %or, %2
  %3 = load i64, i64* %v3.addr, align 8
  %or2 = or i64 %or1, %3
  %4 = load i64, i64* %v4.addr, align 8
  %or3 = or i64 %or2, %4
  ret i64 %or3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIm27custom_multiple_variable_orImEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN27custom_multiple_variable_orImE8do_shiftEmmmmm(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN18custom_variable_orImE8do_shiftEmm(i64 %input, i64 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %or = or i64 %0, %1
  ret i64 %or
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIm18custom_variable_orImEEvT_S2_(i64 %result, i64 %var) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var, i64* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i64
  %1 = load i64, i64* %var.addr, align 8
  %call = call i64 @_ZN18custom_variable_orImE8do_shiftEmm(i64 %conv, i64 %1)
  %mul = mul i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN28custom_multiple_variable_andImE8do_shiftEmmmmm(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %and = and i64 %0, %1
  %2 = load i64, i64* %v2.addr, align 8
  %and1 = and i64 %and, %2
  %3 = load i64, i64* %v3.addr, align 8
  %and2 = and i64 %and1, %3
  %4 = load i64, i64* %v4.addr, align 8
  %and3 = and i64 %and2, %4
  ret i64 %and3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIm28custom_multiple_variable_andImEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN28custom_multiple_variable_andImE8do_shiftEmmmmm(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN19custom_variable_andImE8do_shiftEmm(i64 %input, i64 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %and = and i64 %0, %1
  ret i64 %and
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIm19custom_variable_andImEEvT_S2_(i64 %result, i64 %var) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var, i64* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i64
  %1 = load i64, i64* %var.addr, align 8
  %call = call i64 @_ZN19custom_variable_andImE8do_shiftEmm(i64 %conv, i64 %1)
  %mul = mul i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN30custom_mixed_multiple_variableImE8do_shiftEmmmmm(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %add = add i64 %0, %1
  %2 = load i64, i64* %v2.addr, align 8
  %3 = load i64, i64* %v3.addr, align 8
  %mul = mul i64 %2, %3
  %4 = load i64, i64* %v4.addr, align 8
  %div = udiv i64 %mul, %4
  %sub = sub i64 %add, %div
  ret i64 %sub
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIm30custom_mixed_multiple_variableImEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN30custom_mixed_multiple_variableImE8do_shiftEmmmmm(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN32custom_divide_multiple_variable2ImE8do_shiftEmmmmm(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %2 = load i64, i64* %v2.addr, align 8
  %div = udiv i64 %1, %2
  %3 = load i64, i64* %v3.addr, align 8
  %div1 = udiv i64 %div, %3
  %4 = load i64, i64* %v4.addr, align 8
  %div2 = udiv i64 %div1, %4
  %add = add i64 %0, %div2
  ret i64 %add
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIm32custom_divide_multiple_variable2ImEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN32custom_divide_multiple_variable2ImE8do_shiftEmmmmm(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN31custom_divide_multiple_variableImE8do_shiftEmmmmm(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %div = udiv i64 %0, %1
  %2 = load i64, i64* %v2.addr, align 8
  %div1 = udiv i64 %div, %2
  %3 = load i64, i64* %v3.addr, align 8
  %div2 = udiv i64 %div1, %3
  %4 = load i64, i64* %v4.addr, align 8
  %div3 = udiv i64 %div2, %4
  ret i64 %div3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIm31custom_divide_multiple_variableImEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN31custom_divide_multiple_variableImE8do_shiftEmmmmm(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN22custom_divide_variableImE8do_shiftEmm(i64 %input, i64 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %div = udiv i64 %0, %1
  ret i64 %div
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIm22custom_divide_variableImEEvT_S2_(i64 %result, i64 %var) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var, i64* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i64
  %1 = load i64, i64* %var.addr, align 8
  %call = call i64 @_ZN22custom_divide_variableImE8do_shiftEmm(i64 %conv, i64 %1)
  %mul = mul i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN34custom_multiply_multiple_variable2ImE8do_shiftEmmmmm(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %2 = load i64, i64* %v2.addr, align 8
  %mul = mul i64 %1, %2
  %3 = load i64, i64* %v3.addr, align 8
  %mul1 = mul i64 %mul, %3
  %4 = load i64, i64* %v4.addr, align 8
  %mul2 = mul i64 %mul1, %4
  %add = add i64 %0, %mul2
  ret i64 %add
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIm34custom_multiply_multiple_variable2ImEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN34custom_multiply_multiple_variable2ImE8do_shiftEmmmmm(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN33custom_multiply_multiple_variableImE8do_shiftEmmmmm(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %mul = mul i64 %0, %1
  %2 = load i64, i64* %v2.addr, align 8
  %mul1 = mul i64 %mul, %2
  %3 = load i64, i64* %v3.addr, align 8
  %mul2 = mul i64 %mul1, %3
  %4 = load i64, i64* %v4.addr, align 8
  %mul3 = mul i64 %mul2, %4
  ret i64 %mul3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIm33custom_multiply_multiple_variableImEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN33custom_multiply_multiple_variableImE8do_shiftEmmmmm(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN24custom_multiply_variableImE8do_shiftEmm(i64 %input, i64 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %mul = mul i64 %0, %1
  ret i64 %mul
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIm24custom_multiply_variableImEEvT_S2_(i64 %result, i64 %var) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var, i64* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i64
  %1 = load i64, i64* %var.addr, align 8
  %call = call i64 @_ZN24custom_multiply_variableImE8do_shiftEmm(i64 %conv, i64 %1)
  %mul = mul i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN28custom_sub_multiple_variableImE8do_shiftEmmmmm(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %sub = sub i64 %0, %1
  %2 = load i64, i64* %v2.addr, align 8
  %sub1 = sub i64 %sub, %2
  %3 = load i64, i64* %v3.addr, align 8
  %sub2 = sub i64 %sub1, %3
  %4 = load i64, i64* %v4.addr, align 8
  %sub3 = sub i64 %sub2, %4
  ret i64 %sub3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIm28custom_sub_multiple_variableImEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN28custom_sub_multiple_variableImE8do_shiftEmmmmm(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN19custom_sub_variableImE8do_shiftEmm(i64 %input, i64 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %sub = sub i64 %0, %1
  ret i64 %sub
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIm19custom_sub_variableImEEvT_S2_(i64 %result, i64 %var) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var, i64* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i64
  %1 = load i64, i64* %var.addr, align 8
  %call = call i64 @_ZN19custom_sub_variableImE8do_shiftEmm(i64 %conv, i64 %1)
  %mul = mul i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN28custom_add_multiple_variableImE8do_shiftEmmmmm(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %add = add i64 %0, %1
  %2 = load i64, i64* %v2.addr, align 8
  %add1 = add i64 %add, %2
  %3 = load i64, i64* %v3.addr, align 8
  %add2 = add i64 %add1, %3
  %4 = load i64, i64* %v4.addr, align 8
  %add3 = add i64 %add2, %4
  ret i64 %add3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIm28custom_add_multiple_variableImEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN28custom_add_multiple_variableImE8do_shiftEmmmmm(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIm19custom_add_variableImEEvT_S2_(i64 %result, i64 %var) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var, i64* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i64
  %1 = load i64, i64* %var.addr, align 8
  %call = call i64 @_ZN19custom_add_variableImE8do_shiftEmm(i64 %conv, i64 %1)
  %mul = mul i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalImEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN19custom_add_variableImE8do_shiftEmm(i64 %input, i64 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %add = add i64 %0, %1
  ret i64 %add
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN28custom_multiple_variable_xorIlE8do_shiftElllll(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %xor = xor i64 %0, %1
  %2 = load i64, i64* %v2.addr, align 8
  %xor1 = xor i64 %xor, %2
  %3 = load i64, i64* %v3.addr, align 8
  %xor2 = xor i64 %xor1, %3
  %4 = load i64, i64* %v4.addr, align 8
  %xor3 = xor i64 %xor2, %4
  ret i64 %xor3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIl28custom_multiple_variable_xorIlEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN28custom_multiple_variable_xorIlE8do_shiftElllll(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul nsw i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %a, i64* dereferenceable(8) %b) #5 comdat {
entry:
  %a.addr = alloca i64*, align 8
  %b.addr = alloca i64*, align 8
  store i64* %a, i64** %a.addr, align 8
  store i64* %b, i64** %b.addr, align 8
  %0 = load i64*, i64** %a.addr, align 8
  %1 = load i64, i64* %0, align 8
  %2 = load i64*, i64** %b.addr, align 8
  %3 = load i64, i64* %2, align 8
  %cmp = icmp eq i64 %1, %3
  ret i1 %cmp
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN19custom_variable_xorIlE8do_shiftEll(i64 %input, i64 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %xor = xor i64 %0, %1
  ret i64 %xor
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIl19custom_variable_xorIlEEvT_S2_(i64 %result, i64 %var) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var, i64* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i64
  %1 = load i64, i64* %var.addr, align 8
  %call = call i64 @_ZN19custom_variable_xorIlE8do_shiftEll(i64 %conv, i64 %1)
  %mul = mul nsw i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN27custom_multiple_variable_orIlE8do_shiftElllll(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %or = or i64 %0, %1
  %2 = load i64, i64* %v2.addr, align 8
  %or1 = or i64 %or, %2
  %3 = load i64, i64* %v3.addr, align 8
  %or2 = or i64 %or1, %3
  %4 = load i64, i64* %v4.addr, align 8
  %or3 = or i64 %or2, %4
  ret i64 %or3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIl27custom_multiple_variable_orIlEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN27custom_multiple_variable_orIlE8do_shiftElllll(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul nsw i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN18custom_variable_orIlE8do_shiftEll(i64 %input, i64 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %or = or i64 %0, %1
  ret i64 %or
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIl18custom_variable_orIlEEvT_S2_(i64 %result, i64 %var) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var, i64* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i64
  %1 = load i64, i64* %var.addr, align 8
  %call = call i64 @_ZN18custom_variable_orIlE8do_shiftEll(i64 %conv, i64 %1)
  %mul = mul nsw i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN28custom_multiple_variable_andIlE8do_shiftElllll(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %and = and i64 %0, %1
  %2 = load i64, i64* %v2.addr, align 8
  %and1 = and i64 %and, %2
  %3 = load i64, i64* %v3.addr, align 8
  %and2 = and i64 %and1, %3
  %4 = load i64, i64* %v4.addr, align 8
  %and3 = and i64 %and2, %4
  ret i64 %and3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIl28custom_multiple_variable_andIlEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN28custom_multiple_variable_andIlE8do_shiftElllll(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul nsw i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN19custom_variable_andIlE8do_shiftEll(i64 %input, i64 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %and = and i64 %0, %1
  ret i64 %and
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIl19custom_variable_andIlEEvT_S2_(i64 %result, i64 %var) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var, i64* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i64
  %1 = load i64, i64* %var.addr, align 8
  %call = call i64 @_ZN19custom_variable_andIlE8do_shiftEll(i64 %conv, i64 %1)
  %mul = mul nsw i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN30custom_mixed_multiple_variableIlE8do_shiftElllll(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %add = add nsw i64 %0, %1
  %2 = load i64, i64* %v2.addr, align 8
  %3 = load i64, i64* %v3.addr, align 8
  %mul = mul nsw i64 %2, %3
  %4 = load i64, i64* %v4.addr, align 8
  %div = sdiv i64 %mul, %4
  %sub = sub nsw i64 %add, %div
  ret i64 %sub
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIl30custom_mixed_multiple_variableIlEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN30custom_mixed_multiple_variableIlE8do_shiftElllll(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul nsw i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN32custom_divide_multiple_variable2IlE8do_shiftElllll(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %2 = load i64, i64* %v2.addr, align 8
  %div = sdiv i64 %1, %2
  %3 = load i64, i64* %v3.addr, align 8
  %div1 = sdiv i64 %div, %3
  %4 = load i64, i64* %v4.addr, align 8
  %div2 = sdiv i64 %div1, %4
  %add = add nsw i64 %0, %div2
  ret i64 %add
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIl32custom_divide_multiple_variable2IlEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN32custom_divide_multiple_variable2IlE8do_shiftElllll(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul nsw i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN31custom_divide_multiple_variableIlE8do_shiftElllll(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %div = sdiv i64 %0, %1
  %2 = load i64, i64* %v2.addr, align 8
  %div1 = sdiv i64 %div, %2
  %3 = load i64, i64* %v3.addr, align 8
  %div2 = sdiv i64 %div1, %3
  %4 = load i64, i64* %v4.addr, align 8
  %div3 = sdiv i64 %div2, %4
  ret i64 %div3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIl31custom_divide_multiple_variableIlEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN31custom_divide_multiple_variableIlE8do_shiftElllll(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul nsw i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN22custom_divide_variableIlE8do_shiftEll(i64 %input, i64 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %div = sdiv i64 %0, %1
  ret i64 %div
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIl22custom_divide_variableIlEEvT_S2_(i64 %result, i64 %var) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var, i64* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i64
  %1 = load i64, i64* %var.addr, align 8
  %call = call i64 @_ZN22custom_divide_variableIlE8do_shiftEll(i64 %conv, i64 %1)
  %mul = mul nsw i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN34custom_multiply_multiple_variable2IlE8do_shiftElllll(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %2 = load i64, i64* %v2.addr, align 8
  %mul = mul nsw i64 %1, %2
  %3 = load i64, i64* %v3.addr, align 8
  %mul1 = mul nsw i64 %mul, %3
  %4 = load i64, i64* %v4.addr, align 8
  %mul2 = mul nsw i64 %mul1, %4
  %add = add nsw i64 %0, %mul2
  ret i64 %add
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIl34custom_multiply_multiple_variable2IlEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN34custom_multiply_multiple_variable2IlE8do_shiftElllll(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul nsw i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN33custom_multiply_multiple_variableIlE8do_shiftElllll(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %mul = mul nsw i64 %0, %1
  %2 = load i64, i64* %v2.addr, align 8
  %mul1 = mul nsw i64 %mul, %2
  %3 = load i64, i64* %v3.addr, align 8
  %mul2 = mul nsw i64 %mul1, %3
  %4 = load i64, i64* %v4.addr, align 8
  %mul3 = mul nsw i64 %mul2, %4
  ret i64 %mul3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIl33custom_multiply_multiple_variableIlEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN33custom_multiply_multiple_variableIlE8do_shiftElllll(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul nsw i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN24custom_multiply_variableIlE8do_shiftEll(i64 %input, i64 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %mul = mul nsw i64 %0, %1
  ret i64 %mul
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIl24custom_multiply_variableIlEEvT_S2_(i64 %result, i64 %var) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var, i64* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i64
  %1 = load i64, i64* %var.addr, align 8
  %call = call i64 @_ZN24custom_multiply_variableIlE8do_shiftEll(i64 %conv, i64 %1)
  %mul = mul nsw i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN28custom_sub_multiple_variableIlE8do_shiftElllll(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %sub = sub nsw i64 %0, %1
  %2 = load i64, i64* %v2.addr, align 8
  %sub1 = sub nsw i64 %sub, %2
  %3 = load i64, i64* %v3.addr, align 8
  %sub2 = sub nsw i64 %sub1, %3
  %4 = load i64, i64* %v4.addr, align 8
  %sub3 = sub nsw i64 %sub2, %4
  ret i64 %sub3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIl28custom_sub_multiple_variableIlEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN28custom_sub_multiple_variableIlE8do_shiftElllll(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul nsw i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN19custom_sub_variableIlE8do_shiftEll(i64 %input, i64 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %sub = sub nsw i64 %0, %1
  ret i64 %sub
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIl19custom_sub_variableIlEEvT_S2_(i64 %result, i64 %var) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var, i64* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i64
  %1 = load i64, i64* %var.addr, align 8
  %call = call i64 @_ZN19custom_sub_variableIlE8do_shiftEll(i64 %conv, i64 %1)
  %mul = mul nsw i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN28custom_add_multiple_variableIlE8do_shiftElllll(i64 %input, i64 %v1, i64 %v2, i64 %v3, i64 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  %v2.addr = alloca i64, align 8
  %v3.addr = alloca i64, align 8
  %v4.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  store i64 %v2, i64* %v2.addr, align 8
  store i64 %v3, i64* %v3.addr, align 8
  store i64 %v4, i64* %v4.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %add = add nsw i64 %0, %1
  %2 = load i64, i64* %v2.addr, align 8
  %add1 = add nsw i64 %add, %2
  %3 = load i64, i64* %v3.addr, align 8
  %add2 = add nsw i64 %add1, %3
  %4 = load i64, i64* %v4.addr, align 8
  %add3 = add nsw i64 %add2, %4
  ret i64 %add3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIl28custom_add_multiple_variableIlEEvT_S2_S2_S2_S2_(i64 %result, i64 %var1, i64 %var2, i64 %var3, i64 %var4) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var1.addr = alloca i64, align 8
  %var2.addr = alloca i64, align 8
  %var3.addr = alloca i64, align 8
  %var4.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var1, i64* %var1.addr, align 8
  store i64 %var2, i64* %var2.addr, align 8
  store i64 %var3, i64* %var3.addr, align 8
  store i64 %var4, i64* %var4.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i64
  %1 = load i64, i64* %var1.addr, align 8
  %2 = load i64, i64* %var2.addr, align 8
  %3 = load i64, i64* %var3.addr, align 8
  %4 = load i64, i64* %var4.addr, align 8
  %call = call i64 @_ZN28custom_add_multiple_variableIlE8do_shiftElllll(i64 %conv, i64 %1, i64 %2, i64 %3, i64 %4)
  %mul = mul nsw i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIl19custom_add_variableIlEEvT_S2_(i64 %result, i64 %var) #0 comdat {
entry:
  %result.addr = alloca i64, align 8
  %var.addr = alloca i64, align 8
  %temp = alloca i64, align 8
  store i64 %result, i64* %result.addr, align 8
  store i64 %var, i64* %var.addr, align 8
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i64
  %1 = load i64, i64* %var.addr, align 8
  %call = call i64 @_ZN19custom_add_variableIlE8do_shiftEll(i64 %conv, i64 %1)
  %mul = mul nsw i64 8000, %call
  store i64 %mul, i64* %temp, align 8
  %call1 = call zeroext i1 @_Z15tolerance_equalIlEbRT_S1_(i64* dereferenceable(8) %result.addr, i64* dereferenceable(8) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i64 @_ZN19custom_add_variableIlE8do_shiftEll(i64 %input, i64 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i64, align 8
  %v1.addr = alloca i64, align 8
  store i64 %input, i64* %input.addr, align 8
  store i64 %v1, i64* %v1.addr, align 8
  %0 = load i64, i64* %input.addr, align 8
  %1 = load i64, i64* %v1.addr, align 8
  %add = add nsw i64 %0, %1
  ret i64 %add
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN28custom_multiple_variable_xorIjE8do_shiftEjjjjj(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %xor = xor i32 %0, %1
  %2 = load i32, i32* %v2.addr, align 4
  %xor1 = xor i32 %xor, %2
  %3 = load i32, i32* %v3.addr, align 4
  %xor2 = xor i32 %xor1, %3
  %4 = load i32, i32* %v4.addr, align 4
  %xor3 = xor i32 %xor2, %4
  ret i32 %xor3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIj28custom_multiple_variable_xorIjEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN28custom_multiple_variable_xorIjE8do_shiftEjjjjj(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %a, i32* dereferenceable(4) %b) #5 comdat {
entry:
  %a.addr = alloca i32*, align 8
  %b.addr = alloca i32*, align 8
  store i32* %a, i32** %a.addr, align 8
  store i32* %b, i32** %b.addr, align 8
  %0 = load i32*, i32** %a.addr, align 8
  %1 = load i32, i32* %0, align 4
  %2 = load i32*, i32** %b.addr, align 8
  %3 = load i32, i32* %2, align 4
  %cmp = icmp eq i32 %1, %3
  ret i1 %cmp
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN19custom_variable_xorIjE8do_shiftEjj(i32 %input, i32 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %xor = xor i32 %0, %1
  ret i32 %xor
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIj19custom_variable_xorIjEEvT_S2_(i32 %result, i32 %var) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var, i32* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i32
  %1 = load i32, i32* %var.addr, align 4
  %call = call i32 @_ZN19custom_variable_xorIjE8do_shiftEjj(i32 %conv, i32 %1)
  %mul = mul i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN27custom_multiple_variable_orIjE8do_shiftEjjjjj(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %or = or i32 %0, %1
  %2 = load i32, i32* %v2.addr, align 4
  %or1 = or i32 %or, %2
  %3 = load i32, i32* %v3.addr, align 4
  %or2 = or i32 %or1, %3
  %4 = load i32, i32* %v4.addr, align 4
  %or3 = or i32 %or2, %4
  ret i32 %or3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIj27custom_multiple_variable_orIjEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN27custom_multiple_variable_orIjE8do_shiftEjjjjj(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN18custom_variable_orIjE8do_shiftEjj(i32 %input, i32 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %or = or i32 %0, %1
  ret i32 %or
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIj18custom_variable_orIjEEvT_S2_(i32 %result, i32 %var) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var, i32* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i32
  %1 = load i32, i32* %var.addr, align 4
  %call = call i32 @_ZN18custom_variable_orIjE8do_shiftEjj(i32 %conv, i32 %1)
  %mul = mul i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN28custom_multiple_variable_andIjE8do_shiftEjjjjj(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %and = and i32 %0, %1
  %2 = load i32, i32* %v2.addr, align 4
  %and1 = and i32 %and, %2
  %3 = load i32, i32* %v3.addr, align 4
  %and2 = and i32 %and1, %3
  %4 = load i32, i32* %v4.addr, align 4
  %and3 = and i32 %and2, %4
  ret i32 %and3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIj28custom_multiple_variable_andIjEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN28custom_multiple_variable_andIjE8do_shiftEjjjjj(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN19custom_variable_andIjE8do_shiftEjj(i32 %input, i32 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %and = and i32 %0, %1
  ret i32 %and
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIj19custom_variable_andIjEEvT_S2_(i32 %result, i32 %var) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var, i32* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i32
  %1 = load i32, i32* %var.addr, align 4
  %call = call i32 @_ZN19custom_variable_andIjE8do_shiftEjj(i32 %conv, i32 %1)
  %mul = mul i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN30custom_mixed_multiple_variableIjE8do_shiftEjjjjj(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %add = add i32 %0, %1
  %2 = load i32, i32* %v2.addr, align 4
  %3 = load i32, i32* %v3.addr, align 4
  %mul = mul i32 %2, %3
  %4 = load i32, i32* %v4.addr, align 4
  %div = udiv i32 %mul, %4
  %sub = sub i32 %add, %div
  ret i32 %sub
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIj30custom_mixed_multiple_variableIjEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN30custom_mixed_multiple_variableIjE8do_shiftEjjjjj(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN32custom_divide_multiple_variable2IjE8do_shiftEjjjjj(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %2 = load i32, i32* %v2.addr, align 4
  %div = udiv i32 %1, %2
  %3 = load i32, i32* %v3.addr, align 4
  %div1 = udiv i32 %div, %3
  %4 = load i32, i32* %v4.addr, align 4
  %div2 = udiv i32 %div1, %4
  %add = add i32 %0, %div2
  ret i32 %add
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIj32custom_divide_multiple_variable2IjEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN32custom_divide_multiple_variable2IjE8do_shiftEjjjjj(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN31custom_divide_multiple_variableIjE8do_shiftEjjjjj(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %div = udiv i32 %0, %1
  %2 = load i32, i32* %v2.addr, align 4
  %div1 = udiv i32 %div, %2
  %3 = load i32, i32* %v3.addr, align 4
  %div2 = udiv i32 %div1, %3
  %4 = load i32, i32* %v4.addr, align 4
  %div3 = udiv i32 %div2, %4
  ret i32 %div3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIj31custom_divide_multiple_variableIjEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN31custom_divide_multiple_variableIjE8do_shiftEjjjjj(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN22custom_divide_variableIjE8do_shiftEjj(i32 %input, i32 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %div = udiv i32 %0, %1
  ret i32 %div
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIj22custom_divide_variableIjEEvT_S2_(i32 %result, i32 %var) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var, i32* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i32
  %1 = load i32, i32* %var.addr, align 4
  %call = call i32 @_ZN22custom_divide_variableIjE8do_shiftEjj(i32 %conv, i32 %1)
  %mul = mul i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN34custom_multiply_multiple_variable2IjE8do_shiftEjjjjj(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %2 = load i32, i32* %v2.addr, align 4
  %mul = mul i32 %1, %2
  %3 = load i32, i32* %v3.addr, align 4
  %mul1 = mul i32 %mul, %3
  %4 = load i32, i32* %v4.addr, align 4
  %mul2 = mul i32 %mul1, %4
  %add = add i32 %0, %mul2
  ret i32 %add
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIj34custom_multiply_multiple_variable2IjEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN34custom_multiply_multiple_variable2IjE8do_shiftEjjjjj(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN33custom_multiply_multiple_variableIjE8do_shiftEjjjjj(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %mul = mul i32 %0, %1
  %2 = load i32, i32* %v2.addr, align 4
  %mul1 = mul i32 %mul, %2
  %3 = load i32, i32* %v3.addr, align 4
  %mul2 = mul i32 %mul1, %3
  %4 = load i32, i32* %v4.addr, align 4
  %mul3 = mul i32 %mul2, %4
  ret i32 %mul3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIj33custom_multiply_multiple_variableIjEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN33custom_multiply_multiple_variableIjE8do_shiftEjjjjj(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN24custom_multiply_variableIjE8do_shiftEjj(i32 %input, i32 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %mul = mul i32 %0, %1
  ret i32 %mul
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIj24custom_multiply_variableIjEEvT_S2_(i32 %result, i32 %var) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var, i32* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i32
  %1 = load i32, i32* %var.addr, align 4
  %call = call i32 @_ZN24custom_multiply_variableIjE8do_shiftEjj(i32 %conv, i32 %1)
  %mul = mul i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN28custom_sub_multiple_variableIjE8do_shiftEjjjjj(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %sub = sub i32 %0, %1
  %2 = load i32, i32* %v2.addr, align 4
  %sub1 = sub i32 %sub, %2
  %3 = load i32, i32* %v3.addr, align 4
  %sub2 = sub i32 %sub1, %3
  %4 = load i32, i32* %v4.addr, align 4
  %sub3 = sub i32 %sub2, %4
  ret i32 %sub3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIj28custom_sub_multiple_variableIjEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN28custom_sub_multiple_variableIjE8do_shiftEjjjjj(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN19custom_sub_variableIjE8do_shiftEjj(i32 %input, i32 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %sub = sub i32 %0, %1
  ret i32 %sub
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIj19custom_sub_variableIjEEvT_S2_(i32 %result, i32 %var) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var, i32* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i32
  %1 = load i32, i32* %var.addr, align 4
  %call = call i32 @_ZN19custom_sub_variableIjE8do_shiftEjj(i32 %conv, i32 %1)
  %mul = mul i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN28custom_add_multiple_variableIjE8do_shiftEjjjjj(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %add = add i32 %0, %1
  %2 = load i32, i32* %v2.addr, align 4
  %add1 = add i32 %add, %2
  %3 = load i32, i32* %v3.addr, align 4
  %add2 = add i32 %add1, %3
  %4 = load i32, i32* %v4.addr, align 4
  %add3 = add i32 %add2, %4
  ret i32 %add3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIj28custom_add_multiple_variableIjEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN28custom_add_multiple_variableIjE8do_shiftEjjjjj(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIj19custom_add_variableIjEEvT_S2_(i32 %result, i32 %var) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var, i32* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i32
  %1 = load i32, i32* %var.addr, align 4
  %call = call i32 @_ZN19custom_add_variableIjE8do_shiftEjj(i32 %conv, i32 %1)
  %mul = mul i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIjEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN19custom_add_variableIjE8do_shiftEjj(i32 %input, i32 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %add = add i32 %0, %1
  ret i32 %add
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN28custom_multiple_variable_xorIiE8do_shiftEiiiii(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %xor = xor i32 %0, %1
  %2 = load i32, i32* %v2.addr, align 4
  %xor1 = xor i32 %xor, %2
  %3 = load i32, i32* %v3.addr, align 4
  %xor2 = xor i32 %xor1, %3
  %4 = load i32, i32* %v4.addr, align 4
  %xor3 = xor i32 %xor2, %4
  ret i32 %xor3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIi28custom_multiple_variable_xorIiEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN28custom_multiple_variable_xorIiE8do_shiftEiiiii(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul nsw i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %a, i32* dereferenceable(4) %b) #5 comdat {
entry:
  %a.addr = alloca i32*, align 8
  %b.addr = alloca i32*, align 8
  store i32* %a, i32** %a.addr, align 8
  store i32* %b, i32** %b.addr, align 8
  %0 = load i32*, i32** %a.addr, align 8
  %1 = load i32, i32* %0, align 4
  %2 = load i32*, i32** %b.addr, align 8
  %3 = load i32, i32* %2, align 4
  %cmp = icmp eq i32 %1, %3
  ret i1 %cmp
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN19custom_variable_xorIiE8do_shiftEii(i32 %input, i32 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %xor = xor i32 %0, %1
  ret i32 %xor
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIi19custom_variable_xorIiEEvT_S2_(i32 %result, i32 %var) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var, i32* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i32
  %1 = load i32, i32* %var.addr, align 4
  %call = call i32 @_ZN19custom_variable_xorIiE8do_shiftEii(i32 %conv, i32 %1)
  %mul = mul nsw i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN27custom_multiple_variable_orIiE8do_shiftEiiiii(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %or = or i32 %0, %1
  %2 = load i32, i32* %v2.addr, align 4
  %or1 = or i32 %or, %2
  %3 = load i32, i32* %v3.addr, align 4
  %or2 = or i32 %or1, %3
  %4 = load i32, i32* %v4.addr, align 4
  %or3 = or i32 %or2, %4
  ret i32 %or3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIi27custom_multiple_variable_orIiEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN27custom_multiple_variable_orIiE8do_shiftEiiiii(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul nsw i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN18custom_variable_orIiE8do_shiftEii(i32 %input, i32 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %or = or i32 %0, %1
  ret i32 %or
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIi18custom_variable_orIiEEvT_S2_(i32 %result, i32 %var) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var, i32* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i32
  %1 = load i32, i32* %var.addr, align 4
  %call = call i32 @_ZN18custom_variable_orIiE8do_shiftEii(i32 %conv, i32 %1)
  %mul = mul nsw i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN28custom_multiple_variable_andIiE8do_shiftEiiiii(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %and = and i32 %0, %1
  %2 = load i32, i32* %v2.addr, align 4
  %and1 = and i32 %and, %2
  %3 = load i32, i32* %v3.addr, align 4
  %and2 = and i32 %and1, %3
  %4 = load i32, i32* %v4.addr, align 4
  %and3 = and i32 %and2, %4
  ret i32 %and3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIi28custom_multiple_variable_andIiEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN28custom_multiple_variable_andIiE8do_shiftEiiiii(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul nsw i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN19custom_variable_andIiE8do_shiftEii(i32 %input, i32 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %and = and i32 %0, %1
  ret i32 %and
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIi19custom_variable_andIiEEvT_S2_(i32 %result, i32 %var) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var, i32* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i32
  %1 = load i32, i32* %var.addr, align 4
  %call = call i32 @_ZN19custom_variable_andIiE8do_shiftEii(i32 %conv, i32 %1)
  %mul = mul nsw i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN30custom_mixed_multiple_variableIiE8do_shiftEiiiii(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %add = add nsw i32 %0, %1
  %2 = load i32, i32* %v2.addr, align 4
  %3 = load i32, i32* %v3.addr, align 4
  %mul = mul nsw i32 %2, %3
  %4 = load i32, i32* %v4.addr, align 4
  %div = sdiv i32 %mul, %4
  %sub = sub nsw i32 %add, %div
  ret i32 %sub
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIi30custom_mixed_multiple_variableIiEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN30custom_mixed_multiple_variableIiE8do_shiftEiiiii(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul nsw i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN32custom_divide_multiple_variable2IiE8do_shiftEiiiii(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %2 = load i32, i32* %v2.addr, align 4
  %div = sdiv i32 %1, %2
  %3 = load i32, i32* %v3.addr, align 4
  %div1 = sdiv i32 %div, %3
  %4 = load i32, i32* %v4.addr, align 4
  %div2 = sdiv i32 %div1, %4
  %add = add nsw i32 %0, %div2
  ret i32 %add
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIi32custom_divide_multiple_variable2IiEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN32custom_divide_multiple_variable2IiE8do_shiftEiiiii(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul nsw i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN31custom_divide_multiple_variableIiE8do_shiftEiiiii(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %div = sdiv i32 %0, %1
  %2 = load i32, i32* %v2.addr, align 4
  %div1 = sdiv i32 %div, %2
  %3 = load i32, i32* %v3.addr, align 4
  %div2 = sdiv i32 %div1, %3
  %4 = load i32, i32* %v4.addr, align 4
  %div3 = sdiv i32 %div2, %4
  ret i32 %div3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIi31custom_divide_multiple_variableIiEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN31custom_divide_multiple_variableIiE8do_shiftEiiiii(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul nsw i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN22custom_divide_variableIiE8do_shiftEii(i32 %input, i32 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %div = sdiv i32 %0, %1
  ret i32 %div
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIi22custom_divide_variableIiEEvT_S2_(i32 %result, i32 %var) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var, i32* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i32
  %1 = load i32, i32* %var.addr, align 4
  %call = call i32 @_ZN22custom_divide_variableIiE8do_shiftEii(i32 %conv, i32 %1)
  %mul = mul nsw i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN34custom_multiply_multiple_variable2IiE8do_shiftEiiiii(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %2 = load i32, i32* %v2.addr, align 4
  %mul = mul nsw i32 %1, %2
  %3 = load i32, i32* %v3.addr, align 4
  %mul1 = mul nsw i32 %mul, %3
  %4 = load i32, i32* %v4.addr, align 4
  %mul2 = mul nsw i32 %mul1, %4
  %add = add nsw i32 %0, %mul2
  ret i32 %add
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIi34custom_multiply_multiple_variable2IiEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN34custom_multiply_multiple_variable2IiE8do_shiftEiiiii(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul nsw i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN33custom_multiply_multiple_variableIiE8do_shiftEiiiii(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %mul = mul nsw i32 %0, %1
  %2 = load i32, i32* %v2.addr, align 4
  %mul1 = mul nsw i32 %mul, %2
  %3 = load i32, i32* %v3.addr, align 4
  %mul2 = mul nsw i32 %mul1, %3
  %4 = load i32, i32* %v4.addr, align 4
  %mul3 = mul nsw i32 %mul2, %4
  ret i32 %mul3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIi33custom_multiply_multiple_variableIiEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN33custom_multiply_multiple_variableIiE8do_shiftEiiiii(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul nsw i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN24custom_multiply_variableIiE8do_shiftEii(i32 %input, i32 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %mul = mul nsw i32 %0, %1
  ret i32 %mul
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIi24custom_multiply_variableIiEEvT_S2_(i32 %result, i32 %var) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var, i32* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i32
  %1 = load i32, i32* %var.addr, align 4
  %call = call i32 @_ZN24custom_multiply_variableIiE8do_shiftEii(i32 %conv, i32 %1)
  %mul = mul nsw i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN28custom_sub_multiple_variableIiE8do_shiftEiiiii(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %sub = sub nsw i32 %0, %1
  %2 = load i32, i32* %v2.addr, align 4
  %sub1 = sub nsw i32 %sub, %2
  %3 = load i32, i32* %v3.addr, align 4
  %sub2 = sub nsw i32 %sub1, %3
  %4 = load i32, i32* %v4.addr, align 4
  %sub3 = sub nsw i32 %sub2, %4
  ret i32 %sub3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIi28custom_sub_multiple_variableIiEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN28custom_sub_multiple_variableIiE8do_shiftEiiiii(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul nsw i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN19custom_sub_variableIiE8do_shiftEii(i32 %input, i32 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %sub = sub nsw i32 %0, %1
  ret i32 %sub
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIi19custom_sub_variableIiEEvT_S2_(i32 %result, i32 %var) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var, i32* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i32
  %1 = load i32, i32* %var.addr, align 4
  %call = call i32 @_ZN19custom_sub_variableIiE8do_shiftEii(i32 %conv, i32 %1)
  %mul = mul nsw i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN28custom_add_multiple_variableIiE8do_shiftEiiiii(i32 %input, i32 %v1, i32 %v2, i32 %v3, i32 %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  %v2.addr = alloca i32, align 4
  %v3.addr = alloca i32, align 4
  %v4.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  store i32 %v2, i32* %v2.addr, align 4
  store i32 %v3, i32* %v3.addr, align 4
  store i32 %v4, i32* %v4.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %add = add nsw i32 %0, %1
  %2 = load i32, i32* %v2.addr, align 4
  %add1 = add nsw i32 %add, %2
  %3 = load i32, i32* %v3.addr, align 4
  %add2 = add nsw i32 %add1, %3
  %4 = load i32, i32* %v4.addr, align 4
  %add3 = add nsw i32 %add2, %4
  ret i32 %add3
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIi28custom_add_multiple_variableIiEEvT_S2_S2_S2_S2_(i32 %result, i32 %var1, i32 %var2, i32 %var3, i32 %var4) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var1.addr = alloca i32, align 4
  %var2.addr = alloca i32, align 4
  %var3.addr = alloca i32, align 4
  %var4.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var1, i32* %var1.addr, align 4
  store i32 %var2, i32* %var2.addr, align 4
  store i32 %var3, i32* %var3.addr, align 4
  store i32 %var4, i32* %var4.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i32
  %1 = load i32, i32* %var1.addr, align 4
  %2 = load i32, i32* %var2.addr, align 4
  %3 = load i32, i32* %var3.addr, align 4
  %4 = load i32, i32* %var4.addr, align 4
  %call = call i32 @_ZN28custom_add_multiple_variableIiE8do_shiftEiiiii(i32 %conv, i32 %1, i32 %2, i32 %3, i32 %4)
  %mul = mul nsw i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIi19custom_add_variableIiEEvT_S2_(i32 %result, i32 %var) #0 comdat {
entry:
  %result.addr = alloca i32, align 4
  %var.addr = alloca i32, align 4
  %temp = alloca i32, align 4
  store i32 %result, i32* %result.addr, align 4
  store i32 %var, i32* %var.addr, align 4
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i32
  %1 = load i32, i32* %var.addr, align 4
  %call = call i32 @_ZN19custom_add_variableIiE8do_shiftEii(i32 %conv, i32 %1)
  %mul = mul nsw i32 8000, %call
  store i32 %mul, i32* %temp, align 4
  %call1 = call zeroext i1 @_Z15tolerance_equalIiEbRT_S1_(i32* dereferenceable(4) %result.addr, i32* dereferenceable(4) %temp)
  br i1 %call1, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call2 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr i32 @_ZN19custom_add_variableIiE8do_shiftEii(i32 %input, i32 %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i32, align 4
  %v1.addr = alloca i32, align 4
  store i32 %input, i32* %input.addr, align 4
  store i32 %v1, i32* %v1.addr, align 4
  %0 = load i32, i32* %input.addr, align 4
  %1 = load i32, i32* %v1.addr, align 4
  %add = add nsw i32 %0, %1
  ret i32 %add
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i16 @_ZN28custom_multiple_variable_xorItE8do_shiftEttttt(i16 zeroext %input, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %xor = xor i32 %conv, %conv1
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = zext i16 %2 to i32
  %xor3 = xor i32 %xor, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv4 = zext i16 %3 to i32
  %xor5 = xor i32 %xor3, %conv4
  %4 = load i16, i16* %v4.addr, align 2
  %conv6 = zext i16 %4 to i32
  %xor7 = xor i32 %xor5, %conv6
  %conv8 = trunc i32 %xor7 to i16
  ret i16 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIt28custom_multiple_variable_xorItEEvT_S2_S2_S2_S2_(i16 zeroext %result, i16 zeroext %var1, i16 zeroext %var2, i16 zeroext %var3, i16 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call zeroext i16 @_ZN28custom_multiple_variable_xorItE8do_shiftEttttt(i16 zeroext %conv, i16 zeroext %1, i16 zeroext %2, i16 zeroext %3, i16 zeroext %4)
  %conv1 = zext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %a, i16* dereferenceable(2) %b) #5 comdat {
entry:
  %a.addr = alloca i16*, align 8
  %b.addr = alloca i16*, align 8
  %diff = alloca i16, align 2
  store i16* %a, i16** %a.addr, align 8
  store i16* %b, i16** %b.addr, align 8
  %0 = load i16*, i16** %a.addr, align 8
  %1 = load i16, i16* %0, align 2
  %conv = zext i16 %1 to i32
  %2 = load i16*, i16** %b.addr, align 8
  %3 = load i16, i16* %2, align 2
  %conv1 = zext i16 %3 to i32
  %sub = sub nsw i32 %conv, %conv1
  %conv2 = trunc i32 %sub to i16
  store i16 %conv2, i16* %diff, align 2
  %4 = load i16, i16* %diff, align 2
  %conv3 = zext i16 %4 to i32
  %call = call i32 @abs(i32 %conv3) #8
  %conv4 = sitofp i32 %call to double
  %cmp = fcmp olt double %conv4, 1.000000e-06
  ret i1 %cmp
}

; Function Attrs: nounwind readnone
declare i32 @abs(i32) #7

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i16 @_ZN19custom_variable_xorItE8do_shiftEtt(i16 zeroext %input, i16 zeroext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %xor = xor i32 %conv, %conv1
  %conv2 = trunc i32 %xor to i16
  ret i16 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIt19custom_variable_xorItEEvT_S2_(i16 zeroext %result, i16 zeroext %var) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var, i16* %var.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i16
  %1 = load i16, i16* %var.addr, align 2
  %call = call zeroext i16 @_ZN19custom_variable_xorItE8do_shiftEtt(i16 zeroext %conv, i16 zeroext %1)
  %conv1 = zext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i16 @_ZN27custom_multiple_variable_orItE8do_shiftEttttt(i16 zeroext %input, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %or = or i32 %conv, %conv1
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = zext i16 %2 to i32
  %or3 = or i32 %or, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv4 = zext i16 %3 to i32
  %or5 = or i32 %or3, %conv4
  %4 = load i16, i16* %v4.addr, align 2
  %conv6 = zext i16 %4 to i32
  %or7 = or i32 %or5, %conv6
  %conv8 = trunc i32 %or7 to i16
  ret i16 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIt27custom_multiple_variable_orItEEvT_S2_S2_S2_S2_(i16 zeroext %result, i16 zeroext %var1, i16 zeroext %var2, i16 zeroext %var3, i16 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call zeroext i16 @_ZN27custom_multiple_variable_orItE8do_shiftEttttt(i16 zeroext %conv, i16 zeroext %1, i16 zeroext %2, i16 zeroext %3, i16 zeroext %4)
  %conv1 = zext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i16 @_ZN18custom_variable_orItE8do_shiftEtt(i16 zeroext %input, i16 zeroext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %or = or i32 %conv, %conv1
  %conv2 = trunc i32 %or to i16
  ret i16 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIt18custom_variable_orItEEvT_S2_(i16 zeroext %result, i16 zeroext %var) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var, i16* %var.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i16
  %1 = load i16, i16* %var.addr, align 2
  %call = call zeroext i16 @_ZN18custom_variable_orItE8do_shiftEtt(i16 zeroext %conv, i16 zeroext %1)
  %conv1 = zext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i16 @_ZN28custom_multiple_variable_andItE8do_shiftEttttt(i16 zeroext %input, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %and = and i32 %conv, %conv1
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = zext i16 %2 to i32
  %and3 = and i32 %and, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv4 = zext i16 %3 to i32
  %and5 = and i32 %and3, %conv4
  %4 = load i16, i16* %v4.addr, align 2
  %conv6 = zext i16 %4 to i32
  %and7 = and i32 %and5, %conv6
  %conv8 = trunc i32 %and7 to i16
  ret i16 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIt28custom_multiple_variable_andItEEvT_S2_S2_S2_S2_(i16 zeroext %result, i16 zeroext %var1, i16 zeroext %var2, i16 zeroext %var3, i16 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call zeroext i16 @_ZN28custom_multiple_variable_andItE8do_shiftEttttt(i16 zeroext %conv, i16 zeroext %1, i16 zeroext %2, i16 zeroext %3, i16 zeroext %4)
  %conv1 = zext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i16 @_ZN19custom_variable_andItE8do_shiftEtt(i16 zeroext %input, i16 zeroext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %and = and i32 %conv, %conv1
  %conv2 = trunc i32 %and to i16
  ret i16 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIt19custom_variable_andItEEvT_S2_(i16 zeroext %result, i16 zeroext %var) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var, i16* %var.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i16
  %1 = load i16, i16* %var.addr, align 2
  %call = call zeroext i16 @_ZN19custom_variable_andItE8do_shiftEtt(i16 zeroext %conv, i16 zeroext %1)
  %conv1 = zext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i16 @_ZN30custom_mixed_multiple_variableItE8do_shiftEttttt(i16 zeroext %input, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %add = add nsw i32 %conv, %conv1
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = zext i16 %2 to i32
  %3 = load i16, i16* %v3.addr, align 2
  %conv3 = zext i16 %3 to i32
  %mul = mul nsw i32 %conv2, %conv3
  %4 = load i16, i16* %v4.addr, align 2
  %conv4 = zext i16 %4 to i32
  %div = sdiv i32 %mul, %conv4
  %sub = sub nsw i32 %add, %div
  %conv5 = trunc i32 %sub to i16
  ret i16 %conv5
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIt30custom_mixed_multiple_variableItEEvT_S2_S2_S2_S2_(i16 zeroext %result, i16 zeroext %var1, i16 zeroext %var2, i16 zeroext %var3, i16 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call zeroext i16 @_ZN30custom_mixed_multiple_variableItE8do_shiftEttttt(i16 zeroext %conv, i16 zeroext %1, i16 zeroext %2, i16 zeroext %3, i16 zeroext %4)
  %conv1 = zext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i16 @_ZN32custom_divide_multiple_variable2ItE8do_shiftEttttt(i16 zeroext %input, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = zext i16 %2 to i32
  %div = sdiv i32 %conv1, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv3 = zext i16 %3 to i32
  %div4 = sdiv i32 %div, %conv3
  %4 = load i16, i16* %v4.addr, align 2
  %conv5 = zext i16 %4 to i32
  %div6 = sdiv i32 %div4, %conv5
  %add = add nsw i32 %conv, %div6
  %conv7 = trunc i32 %add to i16
  ret i16 %conv7
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIt32custom_divide_multiple_variable2ItEEvT_S2_S2_S2_S2_(i16 zeroext %result, i16 zeroext %var1, i16 zeroext %var2, i16 zeroext %var3, i16 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call zeroext i16 @_ZN32custom_divide_multiple_variable2ItE8do_shiftEttttt(i16 zeroext %conv, i16 zeroext %1, i16 zeroext %2, i16 zeroext %3, i16 zeroext %4)
  %conv1 = zext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i16 @_ZN31custom_divide_multiple_variableItE8do_shiftEttttt(i16 zeroext %input, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %div = sdiv i32 %conv, %conv1
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = zext i16 %2 to i32
  %div3 = sdiv i32 %div, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv4 = zext i16 %3 to i32
  %div5 = sdiv i32 %div3, %conv4
  %4 = load i16, i16* %v4.addr, align 2
  %conv6 = zext i16 %4 to i32
  %div7 = sdiv i32 %div5, %conv6
  %conv8 = trunc i32 %div7 to i16
  ret i16 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIt31custom_divide_multiple_variableItEEvT_S2_S2_S2_S2_(i16 zeroext %result, i16 zeroext %var1, i16 zeroext %var2, i16 zeroext %var3, i16 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call zeroext i16 @_ZN31custom_divide_multiple_variableItE8do_shiftEttttt(i16 zeroext %conv, i16 zeroext %1, i16 zeroext %2, i16 zeroext %3, i16 zeroext %4)
  %conv1 = zext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i16 @_ZN22custom_divide_variableItE8do_shiftEtt(i16 zeroext %input, i16 zeroext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %div = sdiv i32 %conv, %conv1
  %conv2 = trunc i32 %div to i16
  ret i16 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIt22custom_divide_variableItEEvT_S2_(i16 zeroext %result, i16 zeroext %var) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var, i16* %var.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i16
  %1 = load i16, i16* %var.addr, align 2
  %call = call zeroext i16 @_ZN22custom_divide_variableItE8do_shiftEtt(i16 zeroext %conv, i16 zeroext %1)
  %conv1 = zext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i16 @_ZN34custom_multiply_multiple_variable2ItE8do_shiftEttttt(i16 zeroext %input, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = zext i16 %2 to i32
  %mul = mul nsw i32 %conv1, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv3 = zext i16 %3 to i32
  %mul4 = mul nsw i32 %mul, %conv3
  %4 = load i16, i16* %v4.addr, align 2
  %conv5 = zext i16 %4 to i32
  %mul6 = mul nsw i32 %mul4, %conv5
  %add = add nsw i32 %conv, %mul6
  %conv7 = trunc i32 %add to i16
  ret i16 %conv7
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIt34custom_multiply_multiple_variable2ItEEvT_S2_S2_S2_S2_(i16 zeroext %result, i16 zeroext %var1, i16 zeroext %var2, i16 zeroext %var3, i16 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call zeroext i16 @_ZN34custom_multiply_multiple_variable2ItE8do_shiftEttttt(i16 zeroext %conv, i16 zeroext %1, i16 zeroext %2, i16 zeroext %3, i16 zeroext %4)
  %conv1 = zext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i16 @_ZN33custom_multiply_multiple_variableItE8do_shiftEttttt(i16 zeroext %input, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %mul = mul nsw i32 %conv, %conv1
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = zext i16 %2 to i32
  %mul3 = mul nsw i32 %mul, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv4 = zext i16 %3 to i32
  %mul5 = mul nsw i32 %mul3, %conv4
  %4 = load i16, i16* %v4.addr, align 2
  %conv6 = zext i16 %4 to i32
  %mul7 = mul nsw i32 %mul5, %conv6
  %conv8 = trunc i32 %mul7 to i16
  ret i16 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIt33custom_multiply_multiple_variableItEEvT_S2_S2_S2_S2_(i16 zeroext %result, i16 zeroext %var1, i16 zeroext %var2, i16 zeroext %var3, i16 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call zeroext i16 @_ZN33custom_multiply_multiple_variableItE8do_shiftEttttt(i16 zeroext %conv, i16 zeroext %1, i16 zeroext %2, i16 zeroext %3, i16 zeroext %4)
  %conv1 = zext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i16 @_ZN24custom_multiply_variableItE8do_shiftEtt(i16 zeroext %input, i16 zeroext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %mul = mul nsw i32 %conv, %conv1
  %conv2 = trunc i32 %mul to i16
  ret i16 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIt24custom_multiply_variableItEEvT_S2_(i16 zeroext %result, i16 zeroext %var) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var, i16* %var.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i16
  %1 = load i16, i16* %var.addr, align 2
  %call = call zeroext i16 @_ZN24custom_multiply_variableItE8do_shiftEtt(i16 zeroext %conv, i16 zeroext %1)
  %conv1 = zext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i16 @_ZN28custom_sub_multiple_variableItE8do_shiftEttttt(i16 zeroext %input, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %sub = sub nsw i32 %conv, %conv1
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = zext i16 %2 to i32
  %sub3 = sub nsw i32 %sub, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv4 = zext i16 %3 to i32
  %sub5 = sub nsw i32 %sub3, %conv4
  %4 = load i16, i16* %v4.addr, align 2
  %conv6 = zext i16 %4 to i32
  %sub7 = sub nsw i32 %sub5, %conv6
  %conv8 = trunc i32 %sub7 to i16
  ret i16 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIt28custom_sub_multiple_variableItEEvT_S2_S2_S2_S2_(i16 zeroext %result, i16 zeroext %var1, i16 zeroext %var2, i16 zeroext %var3, i16 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call zeroext i16 @_ZN28custom_sub_multiple_variableItE8do_shiftEttttt(i16 zeroext %conv, i16 zeroext %1, i16 zeroext %2, i16 zeroext %3, i16 zeroext %4)
  %conv1 = zext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i16 @_ZN19custom_sub_variableItE8do_shiftEtt(i16 zeroext %input, i16 zeroext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %sub = sub nsw i32 %conv, %conv1
  %conv2 = trunc i32 %sub to i16
  ret i16 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIt19custom_sub_variableItEEvT_S2_(i16 zeroext %result, i16 zeroext %var) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var, i16* %var.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i16
  %1 = load i16, i16* %var.addr, align 2
  %call = call zeroext i16 @_ZN19custom_sub_variableItE8do_shiftEtt(i16 zeroext %conv, i16 zeroext %1)
  %conv1 = zext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i16 @_ZN28custom_add_multiple_variableItE8do_shiftEttttt(i16 zeroext %input, i16 zeroext %v1, i16 zeroext %v2, i16 zeroext %v3, i16 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %add = add nsw i32 %conv, %conv1
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = zext i16 %2 to i32
  %add3 = add nsw i32 %add, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv4 = zext i16 %3 to i32
  %add5 = add nsw i32 %add3, %conv4
  %4 = load i16, i16* %v4.addr, align 2
  %conv6 = zext i16 %4 to i32
  %add7 = add nsw i32 %add5, %conv6
  %conv8 = trunc i32 %add7 to i16
  ret i16 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIt28custom_add_multiple_variableItEEvT_S2_S2_S2_S2_(i16 zeroext %result, i16 zeroext %var1, i16 zeroext %var2, i16 zeroext %var3, i16 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call zeroext i16 @_ZN28custom_add_multiple_variableItE8do_shiftEttttt(i16 zeroext %conv, i16 zeroext %1, i16 zeroext %2, i16 zeroext %3, i16 zeroext %4)
  %conv1 = zext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIt19custom_add_variableItEEvT_S2_(i16 zeroext %result, i16 zeroext %var) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var, i16* %var.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i16
  %1 = load i16, i16* %var.addr, align 2
  %call = call zeroext i16 @_ZN19custom_add_variableItE8do_shiftEtt(i16 zeroext %conv, i16 zeroext %1)
  %conv1 = zext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalItEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i16 @_ZN19custom_add_variableItE8do_shiftEtt(i16 zeroext %input, i16 zeroext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = zext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = zext i16 %1 to i32
  %add = add nsw i32 %conv, %conv1
  %conv2 = trunc i32 %add to i16
  ret i16 %conv2
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i16 @_ZN28custom_multiple_variable_xorIsE8do_shiftEsssss(i16 signext %input, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %xor = xor i32 %conv, %conv1
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = sext i16 %2 to i32
  %xor3 = xor i32 %xor, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv4 = sext i16 %3 to i32
  %xor5 = xor i32 %xor3, %conv4
  %4 = load i16, i16* %v4.addr, align 2
  %conv6 = sext i16 %4 to i32
  %xor7 = xor i32 %xor5, %conv6
  %conv8 = trunc i32 %xor7 to i16
  ret i16 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIs28custom_multiple_variable_xorIsEEvT_S2_S2_S2_S2_(i16 signext %result, i16 signext %var1, i16 signext %var2, i16 signext %var3, i16 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call signext i16 @_ZN28custom_multiple_variable_xorIsE8do_shiftEsssss(i16 signext %conv, i16 signext %1, i16 signext %2, i16 signext %3, i16 signext %4)
  %conv1 = sext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %a, i16* dereferenceable(2) %b) #5 comdat {
entry:
  %a.addr = alloca i16*, align 8
  %b.addr = alloca i16*, align 8
  %diff = alloca i16, align 2
  store i16* %a, i16** %a.addr, align 8
  store i16* %b, i16** %b.addr, align 8
  %0 = load i16*, i16** %a.addr, align 8
  %1 = load i16, i16* %0, align 2
  %conv = sext i16 %1 to i32
  %2 = load i16*, i16** %b.addr, align 8
  %3 = load i16, i16* %2, align 2
  %conv1 = sext i16 %3 to i32
  %sub = sub nsw i32 %conv, %conv1
  %conv2 = trunc i32 %sub to i16
  store i16 %conv2, i16* %diff, align 2
  %4 = load i16, i16* %diff, align 2
  %conv3 = sext i16 %4 to i32
  %call = call i32 @abs(i32 %conv3) #8
  %conv4 = sitofp i32 %call to double
  %cmp = fcmp olt double %conv4, 1.000000e-06
  ret i1 %cmp
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i16 @_ZN19custom_variable_xorIsE8do_shiftEss(i16 signext %input, i16 signext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %xor = xor i32 %conv, %conv1
  %conv2 = trunc i32 %xor to i16
  ret i16 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIs19custom_variable_xorIsEEvT_S2_(i16 signext %result, i16 signext %var) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var, i16* %var.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i16
  %1 = load i16, i16* %var.addr, align 2
  %call = call signext i16 @_ZN19custom_variable_xorIsE8do_shiftEss(i16 signext %conv, i16 signext %1)
  %conv1 = sext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i16 @_ZN27custom_multiple_variable_orIsE8do_shiftEsssss(i16 signext %input, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %or = or i32 %conv, %conv1
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = sext i16 %2 to i32
  %or3 = or i32 %or, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv4 = sext i16 %3 to i32
  %or5 = or i32 %or3, %conv4
  %4 = load i16, i16* %v4.addr, align 2
  %conv6 = sext i16 %4 to i32
  %or7 = or i32 %or5, %conv6
  %conv8 = trunc i32 %or7 to i16
  ret i16 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIs27custom_multiple_variable_orIsEEvT_S2_S2_S2_S2_(i16 signext %result, i16 signext %var1, i16 signext %var2, i16 signext %var3, i16 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call signext i16 @_ZN27custom_multiple_variable_orIsE8do_shiftEsssss(i16 signext %conv, i16 signext %1, i16 signext %2, i16 signext %3, i16 signext %4)
  %conv1 = sext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i16 @_ZN18custom_variable_orIsE8do_shiftEss(i16 signext %input, i16 signext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %or = or i32 %conv, %conv1
  %conv2 = trunc i32 %or to i16
  ret i16 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIs18custom_variable_orIsEEvT_S2_(i16 signext %result, i16 signext %var) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var, i16* %var.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i16
  %1 = load i16, i16* %var.addr, align 2
  %call = call signext i16 @_ZN18custom_variable_orIsE8do_shiftEss(i16 signext %conv, i16 signext %1)
  %conv1 = sext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i16 @_ZN28custom_multiple_variable_andIsE8do_shiftEsssss(i16 signext %input, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %and = and i32 %conv, %conv1
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = sext i16 %2 to i32
  %and3 = and i32 %and, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv4 = sext i16 %3 to i32
  %and5 = and i32 %and3, %conv4
  %4 = load i16, i16* %v4.addr, align 2
  %conv6 = sext i16 %4 to i32
  %and7 = and i32 %and5, %conv6
  %conv8 = trunc i32 %and7 to i16
  ret i16 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIs28custom_multiple_variable_andIsEEvT_S2_S2_S2_S2_(i16 signext %result, i16 signext %var1, i16 signext %var2, i16 signext %var3, i16 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call signext i16 @_ZN28custom_multiple_variable_andIsE8do_shiftEsssss(i16 signext %conv, i16 signext %1, i16 signext %2, i16 signext %3, i16 signext %4)
  %conv1 = sext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i16 @_ZN19custom_variable_andIsE8do_shiftEss(i16 signext %input, i16 signext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %and = and i32 %conv, %conv1
  %conv2 = trunc i32 %and to i16
  ret i16 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIs19custom_variable_andIsEEvT_S2_(i16 signext %result, i16 signext %var) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var, i16* %var.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i16
  %1 = load i16, i16* %var.addr, align 2
  %call = call signext i16 @_ZN19custom_variable_andIsE8do_shiftEss(i16 signext %conv, i16 signext %1)
  %conv1 = sext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i16 @_ZN30custom_mixed_multiple_variableIsE8do_shiftEsssss(i16 signext %input, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %add = add nsw i32 %conv, %conv1
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = sext i16 %2 to i32
  %3 = load i16, i16* %v3.addr, align 2
  %conv3 = sext i16 %3 to i32
  %mul = mul nsw i32 %conv2, %conv3
  %4 = load i16, i16* %v4.addr, align 2
  %conv4 = sext i16 %4 to i32
  %div = sdiv i32 %mul, %conv4
  %sub = sub nsw i32 %add, %div
  %conv5 = trunc i32 %sub to i16
  ret i16 %conv5
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIs30custom_mixed_multiple_variableIsEEvT_S2_S2_S2_S2_(i16 signext %result, i16 signext %var1, i16 signext %var2, i16 signext %var3, i16 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call signext i16 @_ZN30custom_mixed_multiple_variableIsE8do_shiftEsssss(i16 signext %conv, i16 signext %1, i16 signext %2, i16 signext %3, i16 signext %4)
  %conv1 = sext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i16 @_ZN32custom_divide_multiple_variable2IsE8do_shiftEsssss(i16 signext %input, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = sext i16 %2 to i32
  %div = sdiv i32 %conv1, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv3 = sext i16 %3 to i32
  %div4 = sdiv i32 %div, %conv3
  %4 = load i16, i16* %v4.addr, align 2
  %conv5 = sext i16 %4 to i32
  %div6 = sdiv i32 %div4, %conv5
  %add = add nsw i32 %conv, %div6
  %conv7 = trunc i32 %add to i16
  ret i16 %conv7
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIs32custom_divide_multiple_variable2IsEEvT_S2_S2_S2_S2_(i16 signext %result, i16 signext %var1, i16 signext %var2, i16 signext %var3, i16 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call signext i16 @_ZN32custom_divide_multiple_variable2IsE8do_shiftEsssss(i16 signext %conv, i16 signext %1, i16 signext %2, i16 signext %3, i16 signext %4)
  %conv1 = sext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i16 @_ZN31custom_divide_multiple_variableIsE8do_shiftEsssss(i16 signext %input, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %div = sdiv i32 %conv, %conv1
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = sext i16 %2 to i32
  %div3 = sdiv i32 %div, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv4 = sext i16 %3 to i32
  %div5 = sdiv i32 %div3, %conv4
  %4 = load i16, i16* %v4.addr, align 2
  %conv6 = sext i16 %4 to i32
  %div7 = sdiv i32 %div5, %conv6
  %conv8 = trunc i32 %div7 to i16
  ret i16 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIs31custom_divide_multiple_variableIsEEvT_S2_S2_S2_S2_(i16 signext %result, i16 signext %var1, i16 signext %var2, i16 signext %var3, i16 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call signext i16 @_ZN31custom_divide_multiple_variableIsE8do_shiftEsssss(i16 signext %conv, i16 signext %1, i16 signext %2, i16 signext %3, i16 signext %4)
  %conv1 = sext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i16 @_ZN22custom_divide_variableIsE8do_shiftEss(i16 signext %input, i16 signext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %div = sdiv i32 %conv, %conv1
  %conv2 = trunc i32 %div to i16
  ret i16 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIs22custom_divide_variableIsEEvT_S2_(i16 signext %result, i16 signext %var) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var, i16* %var.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i16
  %1 = load i16, i16* %var.addr, align 2
  %call = call signext i16 @_ZN22custom_divide_variableIsE8do_shiftEss(i16 signext %conv, i16 signext %1)
  %conv1 = sext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i16 @_ZN34custom_multiply_multiple_variable2IsE8do_shiftEsssss(i16 signext %input, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = sext i16 %2 to i32
  %mul = mul nsw i32 %conv1, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv3 = sext i16 %3 to i32
  %mul4 = mul nsw i32 %mul, %conv3
  %4 = load i16, i16* %v4.addr, align 2
  %conv5 = sext i16 %4 to i32
  %mul6 = mul nsw i32 %mul4, %conv5
  %add = add nsw i32 %conv, %mul6
  %conv7 = trunc i32 %add to i16
  ret i16 %conv7
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIs34custom_multiply_multiple_variable2IsEEvT_S2_S2_S2_S2_(i16 signext %result, i16 signext %var1, i16 signext %var2, i16 signext %var3, i16 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call signext i16 @_ZN34custom_multiply_multiple_variable2IsE8do_shiftEsssss(i16 signext %conv, i16 signext %1, i16 signext %2, i16 signext %3, i16 signext %4)
  %conv1 = sext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i16 @_ZN33custom_multiply_multiple_variableIsE8do_shiftEsssss(i16 signext %input, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %mul = mul nsw i32 %conv, %conv1
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = sext i16 %2 to i32
  %mul3 = mul nsw i32 %mul, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv4 = sext i16 %3 to i32
  %mul5 = mul nsw i32 %mul3, %conv4
  %4 = load i16, i16* %v4.addr, align 2
  %conv6 = sext i16 %4 to i32
  %mul7 = mul nsw i32 %mul5, %conv6
  %conv8 = trunc i32 %mul7 to i16
  ret i16 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIs33custom_multiply_multiple_variableIsEEvT_S2_S2_S2_S2_(i16 signext %result, i16 signext %var1, i16 signext %var2, i16 signext %var3, i16 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call signext i16 @_ZN33custom_multiply_multiple_variableIsE8do_shiftEsssss(i16 signext %conv, i16 signext %1, i16 signext %2, i16 signext %3, i16 signext %4)
  %conv1 = sext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i16 @_ZN24custom_multiply_variableIsE8do_shiftEss(i16 signext %input, i16 signext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %mul = mul nsw i32 %conv, %conv1
  %conv2 = trunc i32 %mul to i16
  ret i16 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIs24custom_multiply_variableIsEEvT_S2_(i16 signext %result, i16 signext %var) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var, i16* %var.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i16
  %1 = load i16, i16* %var.addr, align 2
  %call = call signext i16 @_ZN24custom_multiply_variableIsE8do_shiftEss(i16 signext %conv, i16 signext %1)
  %conv1 = sext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i16 @_ZN28custom_sub_multiple_variableIsE8do_shiftEsssss(i16 signext %input, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %sub = sub nsw i32 %conv, %conv1
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = sext i16 %2 to i32
  %sub3 = sub nsw i32 %sub, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv4 = sext i16 %3 to i32
  %sub5 = sub nsw i32 %sub3, %conv4
  %4 = load i16, i16* %v4.addr, align 2
  %conv6 = sext i16 %4 to i32
  %sub7 = sub nsw i32 %sub5, %conv6
  %conv8 = trunc i32 %sub7 to i16
  ret i16 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIs28custom_sub_multiple_variableIsEEvT_S2_S2_S2_S2_(i16 signext %result, i16 signext %var1, i16 signext %var2, i16 signext %var3, i16 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call signext i16 @_ZN28custom_sub_multiple_variableIsE8do_shiftEsssss(i16 signext %conv, i16 signext %1, i16 signext %2, i16 signext %3, i16 signext %4)
  %conv1 = sext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i16 @_ZN19custom_sub_variableIsE8do_shiftEss(i16 signext %input, i16 signext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %sub = sub nsw i32 %conv, %conv1
  %conv2 = trunc i32 %sub to i16
  ret i16 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIs19custom_sub_variableIsEEvT_S2_(i16 signext %result, i16 signext %var) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var, i16* %var.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i16
  %1 = load i16, i16* %var.addr, align 2
  %call = call signext i16 @_ZN19custom_sub_variableIsE8do_shiftEss(i16 signext %conv, i16 signext %1)
  %conv1 = sext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i16 @_ZN28custom_add_multiple_variableIsE8do_shiftEsssss(i16 signext %input, i16 signext %v1, i16 signext %v2, i16 signext %v3, i16 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  %v2.addr = alloca i16, align 2
  %v3.addr = alloca i16, align 2
  %v4.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  store i16 %v2, i16* %v2.addr, align 2
  store i16 %v3, i16* %v3.addr, align 2
  store i16 %v4, i16* %v4.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %add = add nsw i32 %conv, %conv1
  %2 = load i16, i16* %v2.addr, align 2
  %conv2 = sext i16 %2 to i32
  %add3 = add nsw i32 %add, %conv2
  %3 = load i16, i16* %v3.addr, align 2
  %conv4 = sext i16 %3 to i32
  %add5 = add nsw i32 %add3, %conv4
  %4 = load i16, i16* %v4.addr, align 2
  %conv6 = sext i16 %4 to i32
  %add7 = add nsw i32 %add5, %conv6
  %conv8 = trunc i32 %add7 to i16
  ret i16 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIs28custom_add_multiple_variableIsEEvT_S2_S2_S2_S2_(i16 signext %result, i16 signext %var1, i16 signext %var2, i16 signext %var3, i16 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var1.addr = alloca i16, align 2
  %var2.addr = alloca i16, align 2
  %var3.addr = alloca i16, align 2
  %var4.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var1, i16* %var1.addr, align 2
  store i16 %var2, i16* %var2.addr, align 2
  store i16 %var3, i16* %var3.addr, align 2
  store i16 %var4, i16* %var4.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i16
  %1 = load i16, i16* %var1.addr, align 2
  %2 = load i16, i16* %var2.addr, align 2
  %3 = load i16, i16* %var3.addr, align 2
  %4 = load i16, i16* %var4.addr, align 2
  %call = call signext i16 @_ZN28custom_add_multiple_variableIsE8do_shiftEsssss(i16 signext %conv, i16 signext %1, i16 signext %2, i16 signext %3, i16 signext %4)
  %conv1 = sext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIs19custom_add_variableIsEEvT_S2_(i16 signext %result, i16 signext %var) #0 comdat {
entry:
  %result.addr = alloca i16, align 2
  %var.addr = alloca i16, align 2
  %temp = alloca i16, align 2
  store i16 %result, i16* %result.addr, align 2
  store i16 %var, i16* %var.addr, align 2
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i16
  %1 = load i16, i16* %var.addr, align 2
  %call = call signext i16 @_ZN19custom_add_variableIsE8do_shiftEss(i16 signext %conv, i16 signext %1)
  %conv1 = sext i16 %call to i32
  %mul = mul nsw i32 8000, %conv1
  %conv2 = trunc i32 %mul to i16
  store i16 %conv2, i16* %temp, align 2
  %call3 = call zeroext i1 @_Z15tolerance_equalIsEbRT_S1_(i16* dereferenceable(2) %result.addr, i16* dereferenceable(2) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i16 @_ZN19custom_add_variableIsE8do_shiftEss(i16 signext %input, i16 signext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i16, align 2
  %v1.addr = alloca i16, align 2
  store i16 %input, i16* %input.addr, align 2
  store i16 %v1, i16* %v1.addr, align 2
  %0 = load i16, i16* %input.addr, align 2
  %conv = sext i16 %0 to i32
  %1 = load i16, i16* %v1.addr, align 2
  %conv1 = sext i16 %1 to i32
  %add = add nsw i32 %conv, %conv1
  %conv2 = trunc i32 %add to i16
  ret i16 %conv2
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i8 @_ZN28custom_multiple_variable_xorIhE8do_shiftEhhhhh(i8 zeroext %input, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = zext i8 %1 to i32
  %xor = xor i32 %conv, %conv1
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = zext i8 %2 to i32
  %xor3 = xor i32 %xor, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv4 = zext i8 %3 to i32
  %xor5 = xor i32 %xor3, %conv4
  %4 = load i8, i8* %v4.addr, align 1
  %conv6 = zext i8 %4 to i32
  %xor7 = xor i32 %xor5, %conv6
  %conv8 = trunc i32 %xor7 to i8
  ret i8 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIh28custom_multiple_variable_xorIhEEvT_S2_S2_S2_S2_(i8 zeroext %result, i8 zeroext %var1, i8 zeroext %var2, i8 zeroext %var3, i8 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call zeroext i8 @_ZN28custom_multiple_variable_xorIhE8do_shiftEhhhhh(i8 zeroext %conv, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3, i8 zeroext %4)
  %conv1 = zext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %a, i8* dereferenceable(1) %b) #5 comdat {
entry:
  %a.addr = alloca i8*, align 8
  %b.addr = alloca i8*, align 8
  %diff = alloca i8, align 1
  store i8* %a, i8** %a.addr, align 8
  store i8* %b, i8** %b.addr, align 8
  %0 = load i8*, i8** %a.addr, align 8
  %1 = load i8, i8* %0, align 1
  %conv = zext i8 %1 to i32
  %2 = load i8*, i8** %b.addr, align 8
  %3 = load i8, i8* %2, align 1
  %conv1 = zext i8 %3 to i32
  %sub = sub nsw i32 %conv, %conv1
  %conv2 = trunc i32 %sub to i8
  store i8 %conv2, i8* %diff, align 1
  %4 = load i8, i8* %diff, align 1
  %conv3 = zext i8 %4 to i32
  %call = call i32 @abs(i32 %conv3) #8
  %conv4 = sitofp i32 %call to double
  %cmp = fcmp olt double %conv4, 1.000000e-06
  ret i1 %cmp
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i8 @_ZN19custom_variable_xorIhE8do_shiftEhh(i8 zeroext %input, i8 zeroext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = zext i8 %1 to i32
  %xor = xor i32 %conv, %conv1
  %conv2 = trunc i32 %xor to i8
  ret i8 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIh19custom_variable_xorIhEEvT_S2_(i8 zeroext %result, i8 zeroext %var) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var, i8* %var.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i8
  %1 = load i8, i8* %var.addr, align 1
  %call = call zeroext i8 @_ZN19custom_variable_xorIhE8do_shiftEhh(i8 zeroext %conv, i8 zeroext %1)
  %conv1 = zext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i8 @_ZN27custom_multiple_variable_orIhE8do_shiftEhhhhh(i8 zeroext %input, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = zext i8 %1 to i32
  %or = or i32 %conv, %conv1
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = zext i8 %2 to i32
  %or3 = or i32 %or, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv4 = zext i8 %3 to i32
  %or5 = or i32 %or3, %conv4
  %4 = load i8, i8* %v4.addr, align 1
  %conv6 = zext i8 %4 to i32
  %or7 = or i32 %or5, %conv6
  %conv8 = trunc i32 %or7 to i8
  ret i8 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIh27custom_multiple_variable_orIhEEvT_S2_S2_S2_S2_(i8 zeroext %result, i8 zeroext %var1, i8 zeroext %var2, i8 zeroext %var3, i8 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call zeroext i8 @_ZN27custom_multiple_variable_orIhE8do_shiftEhhhhh(i8 zeroext %conv, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3, i8 zeroext %4)
  %conv1 = zext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i8 @_ZN18custom_variable_orIhE8do_shiftEhh(i8 zeroext %input, i8 zeroext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = zext i8 %1 to i32
  %or = or i32 %conv, %conv1
  %conv2 = trunc i32 %or to i8
  ret i8 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIh18custom_variable_orIhEEvT_S2_(i8 zeroext %result, i8 zeroext %var) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var, i8* %var.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i8
  %1 = load i8, i8* %var.addr, align 1
  %call = call zeroext i8 @_ZN18custom_variable_orIhE8do_shiftEhh(i8 zeroext %conv, i8 zeroext %1)
  %conv1 = zext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i8 @_ZN28custom_multiple_variable_andIhE8do_shiftEhhhhh(i8 zeroext %input, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = zext i8 %1 to i32
  %and = and i32 %conv, %conv1
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = zext i8 %2 to i32
  %and3 = and i32 %and, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv4 = zext i8 %3 to i32
  %and5 = and i32 %and3, %conv4
  %4 = load i8, i8* %v4.addr, align 1
  %conv6 = zext i8 %4 to i32
  %and7 = and i32 %and5, %conv6
  %conv8 = trunc i32 %and7 to i8
  ret i8 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIh28custom_multiple_variable_andIhEEvT_S2_S2_S2_S2_(i8 zeroext %result, i8 zeroext %var1, i8 zeroext %var2, i8 zeroext %var3, i8 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call zeroext i8 @_ZN28custom_multiple_variable_andIhE8do_shiftEhhhhh(i8 zeroext %conv, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3, i8 zeroext %4)
  %conv1 = zext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i8 @_ZN19custom_variable_andIhE8do_shiftEhh(i8 zeroext %input, i8 zeroext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = zext i8 %1 to i32
  %and = and i32 %conv, %conv1
  %conv2 = trunc i32 %and to i8
  ret i8 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIh19custom_variable_andIhEEvT_S2_(i8 zeroext %result, i8 zeroext %var) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var, i8* %var.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i8
  %1 = load i8, i8* %var.addr, align 1
  %call = call zeroext i8 @_ZN19custom_variable_andIhE8do_shiftEhh(i8 zeroext %conv, i8 zeroext %1)
  %conv1 = zext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i8 @_ZN30custom_mixed_multiple_variableIhE8do_shiftEhhhhh(i8 zeroext %input, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = zext i8 %1 to i32
  %add = add nsw i32 %conv, %conv1
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = zext i8 %2 to i32
  %3 = load i8, i8* %v3.addr, align 1
  %conv3 = zext i8 %3 to i32
  %mul = mul nsw i32 %conv2, %conv3
  %4 = load i8, i8* %v4.addr, align 1
  %conv4 = zext i8 %4 to i32
  %div = sdiv i32 %mul, %conv4
  %sub = sub nsw i32 %add, %div
  %conv5 = trunc i32 %sub to i8
  ret i8 %conv5
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIh30custom_mixed_multiple_variableIhEEvT_S2_S2_S2_S2_(i8 zeroext %result, i8 zeroext %var1, i8 zeroext %var2, i8 zeroext %var3, i8 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call zeroext i8 @_ZN30custom_mixed_multiple_variableIhE8do_shiftEhhhhh(i8 zeroext %conv, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3, i8 zeroext %4)
  %conv1 = zext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i8 @_ZN32custom_divide_multiple_variable2IhE8do_shiftEhhhhh(i8 zeroext %input, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = zext i8 %1 to i32
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = zext i8 %2 to i32
  %div = sdiv i32 %conv1, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv3 = zext i8 %3 to i32
  %div4 = sdiv i32 %div, %conv3
  %4 = load i8, i8* %v4.addr, align 1
  %conv5 = zext i8 %4 to i32
  %div6 = sdiv i32 %div4, %conv5
  %add = add nsw i32 %conv, %div6
  %conv7 = trunc i32 %add to i8
  ret i8 %conv7
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIh32custom_divide_multiple_variable2IhEEvT_S2_S2_S2_S2_(i8 zeroext %result, i8 zeroext %var1, i8 zeroext %var2, i8 zeroext %var3, i8 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call zeroext i8 @_ZN32custom_divide_multiple_variable2IhE8do_shiftEhhhhh(i8 zeroext %conv, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3, i8 zeroext %4)
  %conv1 = zext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i8 @_ZN31custom_divide_multiple_variableIhE8do_shiftEhhhhh(i8 zeroext %input, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = zext i8 %1 to i32
  %div = sdiv i32 %conv, %conv1
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = zext i8 %2 to i32
  %div3 = sdiv i32 %div, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv4 = zext i8 %3 to i32
  %div5 = sdiv i32 %div3, %conv4
  %4 = load i8, i8* %v4.addr, align 1
  %conv6 = zext i8 %4 to i32
  %div7 = sdiv i32 %div5, %conv6
  %conv8 = trunc i32 %div7 to i8
  ret i8 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIh31custom_divide_multiple_variableIhEEvT_S2_S2_S2_S2_(i8 zeroext %result, i8 zeroext %var1, i8 zeroext %var2, i8 zeroext %var3, i8 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call zeroext i8 @_ZN31custom_divide_multiple_variableIhE8do_shiftEhhhhh(i8 zeroext %conv, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3, i8 zeroext %4)
  %conv1 = zext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i8 @_ZN22custom_divide_variableIhE8do_shiftEhh(i8 zeroext %input, i8 zeroext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = zext i8 %1 to i32
  %div = sdiv i32 %conv, %conv1
  %conv2 = trunc i32 %div to i8
  ret i8 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIh22custom_divide_variableIhEEvT_S2_(i8 zeroext %result, i8 zeroext %var) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var, i8* %var.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i8
  %1 = load i8, i8* %var.addr, align 1
  %call = call zeroext i8 @_ZN22custom_divide_variableIhE8do_shiftEhh(i8 zeroext %conv, i8 zeroext %1)
  %conv1 = zext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i8 @_ZN34custom_multiply_multiple_variable2IhE8do_shiftEhhhhh(i8 zeroext %input, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = zext i8 %1 to i32
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = zext i8 %2 to i32
  %mul = mul nsw i32 %conv1, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv3 = zext i8 %3 to i32
  %mul4 = mul nsw i32 %mul, %conv3
  %4 = load i8, i8* %v4.addr, align 1
  %conv5 = zext i8 %4 to i32
  %mul6 = mul nsw i32 %mul4, %conv5
  %add = add nsw i32 %conv, %mul6
  %conv7 = trunc i32 %add to i8
  ret i8 %conv7
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIh34custom_multiply_multiple_variable2IhEEvT_S2_S2_S2_S2_(i8 zeroext %result, i8 zeroext %var1, i8 zeroext %var2, i8 zeroext %var3, i8 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call zeroext i8 @_ZN34custom_multiply_multiple_variable2IhE8do_shiftEhhhhh(i8 zeroext %conv, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3, i8 zeroext %4)
  %conv1 = zext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i8 @_ZN33custom_multiply_multiple_variableIhE8do_shiftEhhhhh(i8 zeroext %input, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = zext i8 %1 to i32
  %mul = mul nsw i32 %conv, %conv1
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = zext i8 %2 to i32
  %mul3 = mul nsw i32 %mul, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv4 = zext i8 %3 to i32
  %mul5 = mul nsw i32 %mul3, %conv4
  %4 = load i8, i8* %v4.addr, align 1
  %conv6 = zext i8 %4 to i32
  %mul7 = mul nsw i32 %mul5, %conv6
  %conv8 = trunc i32 %mul7 to i8
  ret i8 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIh33custom_multiply_multiple_variableIhEEvT_S2_S2_S2_S2_(i8 zeroext %result, i8 zeroext %var1, i8 zeroext %var2, i8 zeroext %var3, i8 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call zeroext i8 @_ZN33custom_multiply_multiple_variableIhE8do_shiftEhhhhh(i8 zeroext %conv, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3, i8 zeroext %4)
  %conv1 = zext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i8 @_ZN24custom_multiply_variableIhE8do_shiftEhh(i8 zeroext %input, i8 zeroext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = zext i8 %1 to i32
  %mul = mul nsw i32 %conv, %conv1
  %conv2 = trunc i32 %mul to i8
  ret i8 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIh24custom_multiply_variableIhEEvT_S2_(i8 zeroext %result, i8 zeroext %var) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var, i8* %var.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i8
  %1 = load i8, i8* %var.addr, align 1
  %call = call zeroext i8 @_ZN24custom_multiply_variableIhE8do_shiftEhh(i8 zeroext %conv, i8 zeroext %1)
  %conv1 = zext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i8 @_ZN28custom_sub_multiple_variableIhE8do_shiftEhhhhh(i8 zeroext %input, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = zext i8 %1 to i32
  %sub = sub nsw i32 %conv, %conv1
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = zext i8 %2 to i32
  %sub3 = sub nsw i32 %sub, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv4 = zext i8 %3 to i32
  %sub5 = sub nsw i32 %sub3, %conv4
  %4 = load i8, i8* %v4.addr, align 1
  %conv6 = zext i8 %4 to i32
  %sub7 = sub nsw i32 %sub5, %conv6
  %conv8 = trunc i32 %sub7 to i8
  ret i8 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIh28custom_sub_multiple_variableIhEEvT_S2_S2_S2_S2_(i8 zeroext %result, i8 zeroext %var1, i8 zeroext %var2, i8 zeroext %var3, i8 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call zeroext i8 @_ZN28custom_sub_multiple_variableIhE8do_shiftEhhhhh(i8 zeroext %conv, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3, i8 zeroext %4)
  %conv1 = zext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i8 @_ZN19custom_sub_variableIhE8do_shiftEhh(i8 zeroext %input, i8 zeroext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = zext i8 %1 to i32
  %sub = sub nsw i32 %conv, %conv1
  %conv2 = trunc i32 %sub to i8
  ret i8 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIh19custom_sub_variableIhEEvT_S2_(i8 zeroext %result, i8 zeroext %var) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var, i8* %var.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i8
  %1 = load i8, i8* %var.addr, align 1
  %call = call zeroext i8 @_ZN19custom_sub_variableIhE8do_shiftEhh(i8 zeroext %conv, i8 zeroext %1)
  %conv1 = zext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i8 @_ZN28custom_add_multiple_variableIhE8do_shiftEhhhhh(i8 zeroext %input, i8 zeroext %v1, i8 zeroext %v2, i8 zeroext %v3, i8 zeroext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = zext i8 %1 to i32
  %add = add nsw i32 %conv, %conv1
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = zext i8 %2 to i32
  %add3 = add nsw i32 %add, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv4 = zext i8 %3 to i32
  %add5 = add nsw i32 %add3, %conv4
  %4 = load i8, i8* %v4.addr, align 1
  %conv6 = zext i8 %4 to i32
  %add7 = add nsw i32 %add5, %conv6
  %conv8 = trunc i32 %add7 to i8
  ret i8 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIh28custom_add_multiple_variableIhEEvT_S2_S2_S2_S2_(i8 zeroext %result, i8 zeroext %var1, i8 zeroext %var2, i8 zeroext %var3, i8 zeroext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call zeroext i8 @_ZN28custom_add_multiple_variableIhE8do_shiftEhhhhh(i8 zeroext %conv, i8 zeroext %1, i8 zeroext %2, i8 zeroext %3, i8 zeroext %4)
  %conv1 = zext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIh19custom_add_variableIhEEvT_S2_(i8 zeroext %result, i8 zeroext %var) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var, i8* %var.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptoui double %0 to i8
  %1 = load i8, i8* %var.addr, align 1
  %call = call zeroext i8 @_ZN19custom_add_variableIhE8do_shiftEhh(i8 zeroext %conv, i8 zeroext %1)
  %conv1 = zext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIhEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i8 @_ZN19custom_add_variableIhE8do_shiftEhh(i8 zeroext %input, i8 zeroext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = zext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = zext i8 %1 to i32
  %add = add nsw i32 %conv, %conv1
  %conv2 = trunc i32 %add to i8
  ret i8 %conv2
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i8 @_ZN28custom_multiple_variable_xorIaE8do_shiftEaaaaa(i8 signext %input, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = sext i8 %1 to i32
  %xor = xor i32 %conv, %conv1
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = sext i8 %2 to i32
  %xor3 = xor i32 %xor, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv4 = sext i8 %3 to i32
  %xor5 = xor i32 %xor3, %conv4
  %4 = load i8, i8* %v4.addr, align 1
  %conv6 = sext i8 %4 to i32
  %xor7 = xor i32 %xor5, %conv6
  %conv8 = trunc i32 %xor7 to i8
  ret i8 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIa28custom_multiple_variable_xorIaEEvT_S2_S2_S2_S2_(i8 signext %result, i8 signext %var1, i8 signext %var2, i8 signext %var3, i8 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call signext i8 @_ZN28custom_multiple_variable_xorIaE8do_shiftEaaaaa(i8 signext %conv, i8 signext %1, i8 signext %2, i8 signext %3, i8 signext %4)
  %conv1 = sext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %a, i8* dereferenceable(1) %b) #5 comdat {
entry:
  %a.addr = alloca i8*, align 8
  %b.addr = alloca i8*, align 8
  %diff = alloca i8, align 1
  store i8* %a, i8** %a.addr, align 8
  store i8* %b, i8** %b.addr, align 8
  %0 = load i8*, i8** %a.addr, align 8
  %1 = load i8, i8* %0, align 1
  %conv = sext i8 %1 to i32
  %2 = load i8*, i8** %b.addr, align 8
  %3 = load i8, i8* %2, align 1
  %conv1 = sext i8 %3 to i32
  %sub = sub nsw i32 %conv, %conv1
  %conv2 = trunc i32 %sub to i8
  store i8 %conv2, i8* %diff, align 1
  %4 = load i8, i8* %diff, align 1
  %conv3 = sext i8 %4 to i32
  %call = call i32 @abs(i32 %conv3) #8
  %conv4 = sitofp i32 %call to double
  %cmp = fcmp olt double %conv4, 1.000000e-06
  ret i1 %cmp
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i8 @_ZN19custom_variable_xorIaE8do_shiftEaa(i8 signext %input, i8 signext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = sext i8 %1 to i32
  %xor = xor i32 %conv, %conv1
  %conv2 = trunc i32 %xor to i8
  ret i8 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIa19custom_variable_xorIaEEvT_S2_(i8 signext %result, i8 signext %var) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var, i8* %var.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i8
  %1 = load i8, i8* %var.addr, align 1
  %call = call signext i8 @_ZN19custom_variable_xorIaE8do_shiftEaa(i8 signext %conv, i8 signext %1)
  %conv1 = sext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i8 @_ZN27custom_multiple_variable_orIaE8do_shiftEaaaaa(i8 signext %input, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = sext i8 %1 to i32
  %or = or i32 %conv, %conv1
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = sext i8 %2 to i32
  %or3 = or i32 %or, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv4 = sext i8 %3 to i32
  %or5 = or i32 %or3, %conv4
  %4 = load i8, i8* %v4.addr, align 1
  %conv6 = sext i8 %4 to i32
  %or7 = or i32 %or5, %conv6
  %conv8 = trunc i32 %or7 to i8
  ret i8 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIa27custom_multiple_variable_orIaEEvT_S2_S2_S2_S2_(i8 signext %result, i8 signext %var1, i8 signext %var2, i8 signext %var3, i8 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call signext i8 @_ZN27custom_multiple_variable_orIaE8do_shiftEaaaaa(i8 signext %conv, i8 signext %1, i8 signext %2, i8 signext %3, i8 signext %4)
  %conv1 = sext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i8 @_ZN18custom_variable_orIaE8do_shiftEaa(i8 signext %input, i8 signext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = sext i8 %1 to i32
  %or = or i32 %conv, %conv1
  %conv2 = trunc i32 %or to i8
  ret i8 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIa18custom_variable_orIaEEvT_S2_(i8 signext %result, i8 signext %var) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var, i8* %var.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i8
  %1 = load i8, i8* %var.addr, align 1
  %call = call signext i8 @_ZN18custom_variable_orIaE8do_shiftEaa(i8 signext %conv, i8 signext %1)
  %conv1 = sext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i8 @_ZN28custom_multiple_variable_andIaE8do_shiftEaaaaa(i8 signext %input, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = sext i8 %1 to i32
  %and = and i32 %conv, %conv1
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = sext i8 %2 to i32
  %and3 = and i32 %and, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv4 = sext i8 %3 to i32
  %and5 = and i32 %and3, %conv4
  %4 = load i8, i8* %v4.addr, align 1
  %conv6 = sext i8 %4 to i32
  %and7 = and i32 %and5, %conv6
  %conv8 = trunc i32 %and7 to i8
  ret i8 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIa28custom_multiple_variable_andIaEEvT_S2_S2_S2_S2_(i8 signext %result, i8 signext %var1, i8 signext %var2, i8 signext %var3, i8 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call signext i8 @_ZN28custom_multiple_variable_andIaE8do_shiftEaaaaa(i8 signext %conv, i8 signext %1, i8 signext %2, i8 signext %3, i8 signext %4)
  %conv1 = sext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i8 @_ZN19custom_variable_andIaE8do_shiftEaa(i8 signext %input, i8 signext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = sext i8 %1 to i32
  %and = and i32 %conv, %conv1
  %conv2 = trunc i32 %and to i8
  ret i8 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIa19custom_variable_andIaEEvT_S2_(i8 signext %result, i8 signext %var) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var, i8* %var.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i8
  %1 = load i8, i8* %var.addr, align 1
  %call = call signext i8 @_ZN19custom_variable_andIaE8do_shiftEaa(i8 signext %conv, i8 signext %1)
  %conv1 = sext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i8 @_ZN30custom_mixed_multiple_variableIaE8do_shiftEaaaaa(i8 signext %input, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = sext i8 %1 to i32
  %add = add nsw i32 %conv, %conv1
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = sext i8 %2 to i32
  %3 = load i8, i8* %v3.addr, align 1
  %conv3 = sext i8 %3 to i32
  %mul = mul nsw i32 %conv2, %conv3
  %4 = load i8, i8* %v4.addr, align 1
  %conv4 = sext i8 %4 to i32
  %div = sdiv i32 %mul, %conv4
  %sub = sub nsw i32 %add, %div
  %conv5 = trunc i32 %sub to i8
  ret i8 %conv5
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIa30custom_mixed_multiple_variableIaEEvT_S2_S2_S2_S2_(i8 signext %result, i8 signext %var1, i8 signext %var2, i8 signext %var3, i8 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call signext i8 @_ZN30custom_mixed_multiple_variableIaE8do_shiftEaaaaa(i8 signext %conv, i8 signext %1, i8 signext %2, i8 signext %3, i8 signext %4)
  %conv1 = sext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i8 @_ZN32custom_divide_multiple_variable2IaE8do_shiftEaaaaa(i8 signext %input, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = sext i8 %1 to i32
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = sext i8 %2 to i32
  %div = sdiv i32 %conv1, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv3 = sext i8 %3 to i32
  %div4 = sdiv i32 %div, %conv3
  %4 = load i8, i8* %v4.addr, align 1
  %conv5 = sext i8 %4 to i32
  %div6 = sdiv i32 %div4, %conv5
  %add = add nsw i32 %conv, %div6
  %conv7 = trunc i32 %add to i8
  ret i8 %conv7
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIa32custom_divide_multiple_variable2IaEEvT_S2_S2_S2_S2_(i8 signext %result, i8 signext %var1, i8 signext %var2, i8 signext %var3, i8 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call signext i8 @_ZN32custom_divide_multiple_variable2IaE8do_shiftEaaaaa(i8 signext %conv, i8 signext %1, i8 signext %2, i8 signext %3, i8 signext %4)
  %conv1 = sext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i8 @_ZN31custom_divide_multiple_variableIaE8do_shiftEaaaaa(i8 signext %input, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = sext i8 %1 to i32
  %div = sdiv i32 %conv, %conv1
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = sext i8 %2 to i32
  %div3 = sdiv i32 %div, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv4 = sext i8 %3 to i32
  %div5 = sdiv i32 %div3, %conv4
  %4 = load i8, i8* %v4.addr, align 1
  %conv6 = sext i8 %4 to i32
  %div7 = sdiv i32 %div5, %conv6
  %conv8 = trunc i32 %div7 to i8
  ret i8 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIa31custom_divide_multiple_variableIaEEvT_S2_S2_S2_S2_(i8 signext %result, i8 signext %var1, i8 signext %var2, i8 signext %var3, i8 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call signext i8 @_ZN31custom_divide_multiple_variableIaE8do_shiftEaaaaa(i8 signext %conv, i8 signext %1, i8 signext %2, i8 signext %3, i8 signext %4)
  %conv1 = sext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i8 @_ZN22custom_divide_variableIaE8do_shiftEaa(i8 signext %input, i8 signext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = sext i8 %1 to i32
  %div = sdiv i32 %conv, %conv1
  %conv2 = trunc i32 %div to i8
  ret i8 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIa22custom_divide_variableIaEEvT_S2_(i8 signext %result, i8 signext %var) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var, i8* %var.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i8
  %1 = load i8, i8* %var.addr, align 1
  %call = call signext i8 @_ZN22custom_divide_variableIaE8do_shiftEaa(i8 signext %conv, i8 signext %1)
  %conv1 = sext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i8 @_ZN34custom_multiply_multiple_variable2IaE8do_shiftEaaaaa(i8 signext %input, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = sext i8 %1 to i32
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = sext i8 %2 to i32
  %mul = mul nsw i32 %conv1, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv3 = sext i8 %3 to i32
  %mul4 = mul nsw i32 %mul, %conv3
  %4 = load i8, i8* %v4.addr, align 1
  %conv5 = sext i8 %4 to i32
  %mul6 = mul nsw i32 %mul4, %conv5
  %add = add nsw i32 %conv, %mul6
  %conv7 = trunc i32 %add to i8
  ret i8 %conv7
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIa34custom_multiply_multiple_variable2IaEEvT_S2_S2_S2_S2_(i8 signext %result, i8 signext %var1, i8 signext %var2, i8 signext %var3, i8 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call signext i8 @_ZN34custom_multiply_multiple_variable2IaE8do_shiftEaaaaa(i8 signext %conv, i8 signext %1, i8 signext %2, i8 signext %3, i8 signext %4)
  %conv1 = sext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i8 @_ZN33custom_multiply_multiple_variableIaE8do_shiftEaaaaa(i8 signext %input, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = sext i8 %1 to i32
  %mul = mul nsw i32 %conv, %conv1
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = sext i8 %2 to i32
  %mul3 = mul nsw i32 %mul, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv4 = sext i8 %3 to i32
  %mul5 = mul nsw i32 %mul3, %conv4
  %4 = load i8, i8* %v4.addr, align 1
  %conv6 = sext i8 %4 to i32
  %mul7 = mul nsw i32 %mul5, %conv6
  %conv8 = trunc i32 %mul7 to i8
  ret i8 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIa33custom_multiply_multiple_variableIaEEvT_S2_S2_S2_S2_(i8 signext %result, i8 signext %var1, i8 signext %var2, i8 signext %var3, i8 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call signext i8 @_ZN33custom_multiply_multiple_variableIaE8do_shiftEaaaaa(i8 signext %conv, i8 signext %1, i8 signext %2, i8 signext %3, i8 signext %4)
  %conv1 = sext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i8 @_ZN24custom_multiply_variableIaE8do_shiftEaa(i8 signext %input, i8 signext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = sext i8 %1 to i32
  %mul = mul nsw i32 %conv, %conv1
  %conv2 = trunc i32 %mul to i8
  ret i8 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIa24custom_multiply_variableIaEEvT_S2_(i8 signext %result, i8 signext %var) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var, i8* %var.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i8
  %1 = load i8, i8* %var.addr, align 1
  %call = call signext i8 @_ZN24custom_multiply_variableIaE8do_shiftEaa(i8 signext %conv, i8 signext %1)
  %conv1 = sext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i8 @_ZN28custom_sub_multiple_variableIaE8do_shiftEaaaaa(i8 signext %input, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = sext i8 %1 to i32
  %sub = sub nsw i32 %conv, %conv1
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = sext i8 %2 to i32
  %sub3 = sub nsw i32 %sub, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv4 = sext i8 %3 to i32
  %sub5 = sub nsw i32 %sub3, %conv4
  %4 = load i8, i8* %v4.addr, align 1
  %conv6 = sext i8 %4 to i32
  %sub7 = sub nsw i32 %sub5, %conv6
  %conv8 = trunc i32 %sub7 to i8
  ret i8 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIa28custom_sub_multiple_variableIaEEvT_S2_S2_S2_S2_(i8 signext %result, i8 signext %var1, i8 signext %var2, i8 signext %var3, i8 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call signext i8 @_ZN28custom_sub_multiple_variableIaE8do_shiftEaaaaa(i8 signext %conv, i8 signext %1, i8 signext %2, i8 signext %3, i8 signext %4)
  %conv1 = sext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i8 @_ZN19custom_sub_variableIaE8do_shiftEaa(i8 signext %input, i8 signext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = sext i8 %1 to i32
  %sub = sub nsw i32 %conv, %conv1
  %conv2 = trunc i32 %sub to i8
  ret i8 %conv2
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIa19custom_sub_variableIaEEvT_S2_(i8 signext %result, i8 signext %var) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var, i8* %var.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i8
  %1 = load i8, i8* %var.addr, align 1
  %call = call signext i8 @_ZN19custom_sub_variableIaE8do_shiftEaa(i8 signext %conv, i8 signext %1)
  %conv1 = sext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i8 @_ZN28custom_add_multiple_variableIaE8do_shiftEaaaaa(i8 signext %input, i8 signext %v1, i8 signext %v2, i8 signext %v3, i8 signext %v4) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  %v2.addr = alloca i8, align 1
  %v3.addr = alloca i8, align 1
  %v4.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  store i8 %v2, i8* %v2.addr, align 1
  store i8 %v3, i8* %v3.addr, align 1
  store i8 %v4, i8* %v4.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = sext i8 %1 to i32
  %add = add nsw i32 %conv, %conv1
  %2 = load i8, i8* %v2.addr, align 1
  %conv2 = sext i8 %2 to i32
  %add3 = add nsw i32 %add, %conv2
  %3 = load i8, i8* %v3.addr, align 1
  %conv4 = sext i8 %3 to i32
  %add5 = add nsw i32 %add3, %conv4
  %4 = load i8, i8* %v4.addr, align 1
  %conv6 = sext i8 %4 to i32
  %add7 = add nsw i32 %add5, %conv6
  %conv8 = trunc i32 %add7 to i8
  ret i8 %conv8
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIa28custom_add_multiple_variableIaEEvT_S2_S2_S2_S2_(i8 signext %result, i8 signext %var1, i8 signext %var2, i8 signext %var3, i8 signext %var4) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var1.addr = alloca i8, align 1
  %var2.addr = alloca i8, align 1
  %var3.addr = alloca i8, align 1
  %var4.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var1, i8* %var1.addr, align 1
  store i8 %var2, i8* %var2.addr, align 1
  store i8 %var3, i8* %var3.addr, align 1
  store i8 %var4, i8* %var4.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i8
  %1 = load i8, i8* %var1.addr, align 1
  %2 = load i8, i8* %var2.addr, align 1
  %3 = load i8, i8* %var3.addr, align 1
  %4 = load i8, i8* %var4.addr, align 1
  %call = call signext i8 @_ZN28custom_add_multiple_variableIaE8do_shiftEaaaaa(i8 signext %conv, i8 signext %1, i8 signext %2, i8 signext %3, i8 signext %4)
  %conv1 = sext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %5 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %5)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline uwtable
define linkonce_odr void @_Z26check_shifted_variable_sumIa19custom_add_variableIaEEvT_S2_(i8 signext %result, i8 signext %var) #0 comdat {
entry:
  %result.addr = alloca i8, align 1
  %var.addr = alloca i8, align 1
  %temp = alloca i8, align 1
  store i8 %result, i8* %result.addr, align 1
  store i8 %var, i8* %var.addr, align 1
  %0 = load double, double* @init_value, align 8
  %conv = fptosi double %0 to i8
  %1 = load i8, i8* %var.addr, align 1
  %call = call signext i8 @_ZN19custom_add_variableIaE8do_shiftEaa(i8 signext %conv, i8 signext %1)
  %conv1 = sext i8 %call to i32
  %mul = mul nsw i32 64, %conv1
  %conv2 = trunc i32 %mul to i8
  store i8 %conv2, i8* %temp, align 1
  %call3 = call zeroext i1 @_Z15tolerance_equalIaEbRT_S1_(i8* dereferenceable(1) %result.addr, i8* dereferenceable(1) %temp)
  br i1 %call3, label %if.end, label %if.then

if.then:                                          ; preds = %entry
  %2 = load i32, i32* @current_test, align 4
  %call4 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([16 x i8], [16 x i8]* @.str.179, i32 0, i32 0), i32 %2)
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  ret void
}

; Function Attrs: noinline nounwind uwtable
define linkonce_odr signext i8 @_ZN19custom_add_variableIaE8do_shiftEaa(i8 signext %input, i8 signext %v1) #5 comdat align 2 {
entry:
  %input.addr = alloca i8, align 1
  %v1.addr = alloca i8, align 1
  store i8 %input, i8* %input.addr, align 1
  store i8 %v1, i8* %v1.addr, align 1
  %0 = load i8, i8* %input.addr, align 1
  %conv = sext i8 %0 to i32
  %1 = load i8, i8* %v1.addr, align 1
  %conv1 = sext i8 %1 to i32
  %add = add nsw i32 %conv, %conv1
  %conv2 = trunc i32 %add to i8
  ret i8 %conv2
}

attributes #0 = { noinline uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #2 = { "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #3 = { noreturn nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #4 = { nounwind readonly "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #5 = { noinline nounwind uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #6 = { noinline norecurse uwtable "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #7 = { nounwind readnone "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="x86-64" "target-features"="+fxsr,+mmx,+sse,+sse2,+x87" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #8 = { nounwind readnone }
attributes #9 = { nounwind }
attributes #10 = { noreturn nounwind }
attributes #11 = { nounwind readonly }

!llvm.ident = !{!0}

!0 = !{!"clang version 4.0.0 (tags/RELEASE_400/final)"}

#include "llvm/Pass.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/InstrTypes.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/IR/Instruction.h"
#include "llvm/IR/Instructions.h"
#include <vector>

using namespace llvm;

namespace {
    struct func : public FunctionPass {
        static char ID;
        func() : FunctionPass(ID) {}
        bool runOnFunction(Function &F) override {
            outs().write_escaped(F.getName()) << "\n";
//            LLVMContext &Context = F.getContext();
//            FunctionType *b = FunctionType::get(Type::getVoidTy(Context), false);
//            Constant *begin = F.getParent()->getOrInsertFunction("funcBegin", b);
//            FunctionType *e = FunctionType::get(Type::getVoidTy(Context), false);
//            Constant *end = F.getParent()->getOrInsertFunction("funcEnd", e);
//            errs() << "Function Body: " << F << "\n";
            for(auto &Block : F) {
//                errs() << "Basic Block: " << Block << "\n";
                for(llvm::BasicBlock::iterator it = Block.begin(); it != Block.end(); it++) {
			//Type of Return Value
			outs() << "Return Value: ";
			it->getType()->print(outs());	
			outs() << "\n";
			// Type of Operands
			unsigned numops = it->getNumOperands();
			for(unsigned i = 0; i < numops; i++) {
				outs() << "Operand: ";
				it->getOperand(i)->getType()->print(outs());	
				outs() << "\n";
				outs() << "Has Double or Vector? ";
				llvm::Type *t = it->getOperand(i)->getType();
				bool isInvalidType = (t->isPointerTy() ? (t->isHalfTy() || t->isDoubleTy() || t->isFloatTy() || t->isVectorTy()) :
						      t->getElementType()->isHalfTy() || t->getElementType()->isDoubleTy() || t->getElementType()->isFloatTy() || t->getElementType()->isVectorTy());
				outs() << isInvalidType << "\n\n";
			}
			outs() << "Number of Operands: " << it->getNumOperands() << "\n";
			outs() << "instend" << "\n";
			
//                    BasicBlock::iterator copy = it;
//                    if(it == Block.begin()) {
//                        IRBuilder<> builder(&(*it));
//                        builder.SetInsertPoint(&Block, ++builder.GetInsertPoint());
//                        builder.CreateCall(begin);
//                    }
//                    errs() << "Instruction: " << *it << "\n";
//                   if(++copy == Block.end()) {
//                        IRBuilder<> builder(&(*it));
//                        builder.SetInsertPoint(&Block, builder.GetInsertPoint());
//                        builder.CreateCall(end);
//                    }
                }
            }
            return false;
        }
    };
}

char func::ID = 0;
static RegisterPass<func> X("func", "Gets function names, instructions sizes, and whether they have double/vector operations", false, false);
